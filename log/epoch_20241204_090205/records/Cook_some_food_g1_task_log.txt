From agent.py
Reset goals: The sub-goals are: 
['1. Find vegetables that need to be boiled.', '2. Clean the vegetables.', '3. Boil the vegetables in a pot on the stove.']
##############################
Goal representation from planning.py

#exp_behavior

behavior find_food_carrot_2014_around_fridge_289(food_carrot:item):
    goal: not unknown(food_carrot)
    body:
        assert is_food_carrot(food_carrot)
        bind fridge_instance:item where:
            is_fridge(fridge_instance) and id[fridge_instance]==289
        achieve close_char(char,fridge_instance)
        if can_open(fridge_instance):
            achieve_once open(fridge_instance)
            exp(food_carrot,fridge_instance)
        else:
            exp(food_carrot,fridge_instance)
    eff:
        unknown[food_carrot]=False
        close[food_carrot,fridge_instance]=True
        close[fridge_instance,food_carrot]=True
    

behavior find_food_food_2022_around_fridge_289(food_food:item):
    goal: not unknown(food_food)
    body:
        assert is_food_food(food_food)
        bind fridge_instance:item where:
            is_fridge(fridge_instance) and id[fridge_instance]==289
        achieve close_char(char,fridge_instance)
        if can_open(fridge_instance):
            achieve_once open(fridge_instance)
            exp(food_food,fridge_instance)
        else:
            exp(food_food,fridge_instance)
    eff:
        unknown[food_food]=False
        close[food_food,fridge_instance]=True
        close[fridge_instance,food_food]=True
    

behavior find_food_potato_2035_around_fridge_289(food_potato:item):
    goal: not unknown(food_potato)
    body:
        assert is_food_potato(food_potato)
        bind fridge_instance:item where:
            is_fridge(fridge_instance) and id[fridge_instance]==289
        achieve close_char(char,fridge_instance)
        if can_open(fridge_instance):
            achieve_once open(fridge_instance)
            exp(food_potato,fridge_instance)
        else:
            exp(food_potato,fridge_instance)
    eff:
        unknown[food_potato]=False
        close[food_potato,fridge_instance]=True
        close[fridge_instance,food_potato]=True
    

behavior find_food_onion_2032_around_fridge_289(food_onion:item):
    goal: not unknown(food_onion)
    body:
        assert is_food_onion(food_onion)
        bind fridge_instance:item where:
            is_fridge(fridge_instance) and id[fridge_instance]==289
        achieve close_char(char,fridge_instance)
        if can_open(fridge_instance):
            achieve_once open(fridge_instance)
            exp(food_onion,fridge_instance)
        else:
            exp(food_onion,fridge_instance)
    eff:
        unknown[food_onion]=False
        close[food_onion,fridge_instance]=True
        close[fridge_instance,food_onion]=True
    

#exp_behavior_end

#goal_representation
 
def is_vegetable(o:item):
    # Determine if an item is classified as a vegetable
    symbol is_vegetable=exists category: item : is_food_vegetable(category) and o==category
    return is_vegetable

behavior __goal__():
    body:
        if exists vegetable: item : is_vegetable(vegetable):
            # Check if there is a vegetable based on the available information
            bind vegetable: item where:
                is_vegetable(vegetable)
            observe(vegetable, "Confirm if it needs to be boiled")
        
        else:
            # If no vegetable is found, initiate exploration to locate one
            foreach vegetable: item:
                if is_food_vegetable(vegetable) and not visited(vegetable):
                    observe(vegetable, "Check if it needs to be boiled")

#goal_representation_end

##############################
From agent.py->reset_goal
 
def is_vegetable(o:item):
    # Determine if an item is classified as a vegetable
    symbol is_vegetable=exists category: item : is_food_vegetable(category) and o==category
    return is_vegetable

behavior __goal__():
    body:
        if exists vegetable: item : is_vegetable(vegetable):
            # Check if there is a vegetable based on the available information
            bind vegetable: item where:
                is_vegetable(vegetable)
            observe(vegetable, "Confirm if it needs to be boiled")
        
        else:
            # If no vegetable is found, initiate exploration to locate one
            foreach vegetable: item:
                if is_food_vegetable(vegetable) and not visited(vegetable):
                    observe(vegetable, "Check if it needs to be boiled")

##############################
From agent.py
Record from func query_LLM_human in agent.py
Question: Can you tell me how to find vegetables that need to be boiled.
Answer: Need to replan: Yes  
Guidance: Your plan needs to include steps specific to finding vegetables. Consider checking the refrigerator or pantry for vegetables, or referencing a list of vegetables that need boiling before proceeding with the cleaning and boiling steps.

##############################
From agent.py
Record from func query_LLM_human in agent.py
Question: Can you tell me how to clean the vegetables.
Answer: Need to replan: Yes  
Guidance: The plan should be adjusted to include the step of cleaning the vegetables properly before they are put in a pot or boiled.

##############################
From agent.py
Record from func query_LLM_human in agent.py
Question: Can you tell me how to boil the vegetables in a pot on the stove.
Answer: Need to replan: No  
Guidance: Put vegetables in a pot. Fill the pot with water. Put the pot on the stove. Turn on the stove.

##############################
From agent.py
Reset goals: The sub-goals are: 
['Boil the vegetables with a pot on the stove.']
##############################
Goal representation from planning.py

#exp_behavior

behavior find_pot_2069_around_cupboard_229(pot:item):
    goal: not unknown(pot)
    body:
        assert is_pot(pot)
        bind cupboard_instance:item where:
            is_cupboard(cupboard_instance) and id[cupboard_instance]==229
        achieve close_char(char,cupboard_instance)
        if can_open(cupboard_instance):
            achieve_once open(cupboard_instance)
            exp(pot,cupboard_instance)
        else:
            exp(pot,cupboard_instance)
    eff:
        unknown[pot]=False
        close[pot,cupboard_instance]=True
        close[cupboard_instance,pot]=True
    

behavior find_food_cheese_2016_around_fridge_289(food_cheese:item):
    goal: not unknown(food_cheese)
    body:
        assert is_food_cheese(food_cheese)
        bind fridge_instance:item where:
            is_fridge(fridge_instance) and id[fridge_instance]==289
        achieve close_char(char,fridge_instance)
        if can_open(fridge_instance):
            achieve_once open(fridge_instance)
            exp(food_cheese,fridge_instance)
        else:
            exp(food_cheese,fridge_instance)
    eff:
        unknown[food_cheese]=False
        close[food_cheese,fridge_instance]=True
        close[fridge_instance,food_cheese]=True
    

behavior find_food_vegetable_2041_around_fridge_289(food_vegetable:item):
    goal: not unknown(food_vegetable)
    body:
        assert is_food_vegetable(food_vegetable)
        bind fridge_instance:item where:
            is_fridge(fridge_instance) and id[fridge_instance]==289
        achieve close_char(char,fridge_instance)
        if can_open(fridge_instance):
            achieve_once open(fridge_instance)
            exp(food_vegetable,fridge_instance)
        else:
            exp(food_vegetable,fridge_instance)
    eff:
        unknown[food_vegetable]=False
        close[food_vegetable,fridge_instance]=True
        close[fridge_instance,food_vegetable]=True
    

#exp_behavior_end

#goal_representation
 
def is_pot_on_stove(pot: item, stove: item):
    # Check if a specific pot is on a stove
    symbol pot_on_stove=on(pot, stove)
    return pot_on_stove

def has_water_in_pot(pot: item):
    # Check if a specific pot has water
    symbol has_water=has_water(pot)
    return has_water

behavior boil_vegetables(pot: item, stove: item, vegetables: item):
    body:
        achieve is_on(stove)
        # The stove should be turned on

        assert is_food_vegetable(vegetables)
        # Ensure the item is vegetables

        achieve inside(vegetables, pot)
        # Put the vegetables inside the pot

behavior __goal__():
    body:
        bind pot: item where:
            is_pot(pot)
        # Select a pot

        bind stove: item where:
            is_stove(stove)
        # Select a stove

        bind vegetables: item where:
            is_food_vegetable(vegetables)
        # Select vegetables

        if not is_pot_on_stove(pot, stove):
            achieve on(pot, stove)
            # Place the pot on the stove

        if not has_water_in_pot(pot):
            water(pot)
            # Fill the pot with water

        boil_vegetables(pot, stove, vegetables)

#goal_representation_end

##############################
Inner TransformationError Debug
Error trying to process rule "behavior_definition":

'Function water not found. Note that recursive function calls are not supported in the current version.'
##############################
Goal representation after debugging in planning.py
#exp_behavior

behavior find_pot_2069_around_cupboard_229(pot:item):
    goal: not unknown(pot)
    body:
        assert is_pot(pot)
        bind cupboard_instance:item where:
            is_cupboard(cupboard_instance) and id[cupboard_instance]==229
        achieve close_char(char,cupboard_instance)
        if can_open(cupboard_instance):
            achieve_once open(cupboard_instance)
            exp(pot,cupboard_instance)
        else:
            exp(pot,cupboard_instance)
    eff:
        unknown[pot]=False
        close[pot,cupboard_instance]=True
        close[cupboard_instance,pot]=True
    

behavior find_food_cheese_2016_around_fridge_289(food_cheese:item):
    goal: not unknown(food_cheese)
    body:
        assert is_food_cheese(food_cheese)
        bind fridge_instance:item where:
            is_fridge(fridge_instance) and id[fridge_instance]==289
        achieve close_char(char,fridge_instance)
        if can_open(fridge_instance):
            achieve_once open(fridge_instance)
            exp(food_cheese,fridge_instance)
        else:
            exp(food_cheese,fridge_instance)
    eff:
        unknown[food_cheese]=False
        close[food_cheese,fridge_instance]=True
        close[fridge_instance,food_cheese]=True
    

behavior find_food_vegetable_2041_around_fridge_289(food_vegetable:item):
    goal: not unknown(food_vegetable)
    body:
        assert is_food_vegetable(food_vegetable)
        bind fridge_instance:item where:
            is_fridge(fridge_instance) and id[fridge_instance]==289
        achieve close_char(char,fridge_instance)
        if can_open(fridge_instance):
            achieve_once open(fridge_instance)
            exp(food_vegetable,fridge_instance)
        else:
            exp(food_vegetable,fridge_instance)
    eff:
        unknown[food_vegetable]=False
        close[food_vegetable,fridge_instance]=True
        close[fridge_instance,food_vegetable]=True
    

#goal_representation
 
def is_pot_on_stove(pot: item, stove: item):
    # Check if a specific pot is on a stove
    symbol pot_on_stove=on(pot, stove)
    return pot_on_stove

def has_water_in_pot(pot: item):
    # Check if a specific pot has water
    symbol has_water=has_water(pot)
    return has_water

behavior boil_vegetables(pot: item, stove: item, vegetables: item):
    body:
        achieve is_on(stove)
        # The stove should be turned on

        assert is_food_vegetable(vegetables)
        # Ensure the item is vegetables

        achieve inside(vegetables, pot)
        # Put the vegetables inside the pot

behavior __goal__():
    body:
        bind pot: item where:
            is_pot(pot)
        # Select a pot

        bind stove: item where:
            is_stove(stove)
        # Select a stove

        bind vegetables: item where:
            is_food_vegetable(vegetables)
        # Select vegetables

        if not is_pot_on_stove(pot, stove):
            achieve on(pot, stove)
            # Place the pot on the stove

        if not has_water_in_pot(pot):
            achieve has_oil(pot)
            # Fill the pot with oil

        boil_vegetables(pot, stove, vegetables)

#goal_representation_end

##############################
Inner TransformationError Debug
Error trying to process rule "behavior_definition":

'Function has_oil not found. Note that recursive function calls are not supported in the current version.'
##############################
Goal representation after debugging in planning.py
#exp_behavior

behavior find_pot_2069_around_cupboard_229(pot:item):
    goal: not unknown(pot)
    body:
        assert is_pot(pot)
        bind cupboard_instance:item where:
            is_cupboard(cupboard_instance) and id[cupboard_instance]==229
        achieve close_char(char,cupboard_instance)
        if can_open(cupboard_instance):
            achieve_once open(cupboard_instance)
            exp(pot,cupboard_instance)
        else:
            exp(pot,cupboard_instance)
    eff:
        unknown[pot]=False
        close[pot,cupboard_instance]=True
        close[cupboard_instance,pot]=True
    

behavior find_food_cheese_2016_around_fridge_289(food_cheese:item):
    goal: not unknown(food_cheese)
    body:
        assert is_food_cheese(food_cheese)
        bind fridge_instance:item where:
            is_fridge(fridge_instance) and id[fridge_instance]==289
        achieve close_char(char,fridge_instance)
        if can_open(fridge_instance):
            achieve_once open(fridge_instance)
            exp(food_cheese,fridge_instance)
        else:
            exp(food_cheese,fridge_instance)
    eff:
        unknown[food_cheese]=False
        close[food_cheese,fridge_instance]=True
        close[fridge_instance,food_cheese]=True
    

behavior find_food_vegetable_2041_around_fridge_289(food_vegetable:item):
    goal: not unknown(food_vegetable)
    body:
        assert is_food_vegetable(food_vegetable)
        bind fridge_instance:item where:
            is_fridge(fridge_instance) and id[fridge_instance]==289
        achieve close_char(char,fridge_instance)
        if can_open(fridge_instance):
            achieve_once open(fridge_instance)
            exp(food_vegetable,fridge_instance)
        else:
            exp(food_vegetable,fridge_instance)
    eff:
        unknown[food_vegetable]=False
        close[food_vegetable,fridge_instance]=True
        close[fridge_instance,food_vegetable]=True
    

#goal_representation
 
def is_pot_on_stove(pot: item, stove: item):
    # Check if a specific pot is on a stove
    symbol pot_on_stove=on(pot, stove)
    return pot_on_stove

def has_water_in_pot(pot: item):
    # Check if a specific pot has water
    symbol has_water=has_water(pot)
    return has_water

behavior boil_vegetables(pot: item, stove: item, vegetables: item):
    body:
        achieve is_on(stove)
        # The stove should be turned on

        assert is_food_vegetable(vegetables)
        # Ensure the item is vegetables

        achieve inside(vegetables, pot)
        # Put the vegetables inside the pot

behavior __goal__():
    body:
        bind pot: item where:
            is_pot(pot)
        # Select a pot

        bind stove: item where:
            is_stove(stove)
        # Select a stove

        bind vegetables: item where:
            is_food_vegetable(vegetables)
        # Select vegetables

        if not is_pot_on_stove(pot, stove):
            achieve on(pot, stove)
            # Place the pot on the stove

        if not has_water_in_pot(pot):
            achieve is_oil(pot)
            # Fill the pot with oil

        boil_vegetables(pot, stove, vegetables)

#goal_representation_end

##############################
