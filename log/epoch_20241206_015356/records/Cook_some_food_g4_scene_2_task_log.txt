From agent.py
Reset goals: The sub-goals are: 
['1. Wash all the vegetables.', '2. Put all the washed vegetables into a pot and boil them on the stove.', '3. Store the whole pot in the fridge.']
##############################
Goal representation from planning.py

#exp_behavior

behavior find_food_dessert_2051_around_cupboard_131(food_dessert:item):
    goal: not unknown(food_dessert)
    body:
        assert is_food_dessert(food_dessert)
        bind cupboard_instance:item where:
            is_cupboard(cupboard_instance) and id[cupboard_instance]==131
        achieve close_char(char,cupboard_instance)
        if can_open(cupboard_instance):
            achieve_once open(cupboard_instance)
            exp(food_dessert,cupboard_instance)
        else:
            exp(food_dessert,cupboard_instance)
    eff:
        unknown[food_dessert]=False
        close[food_dessert,cupboard_instance]=True
        close[cupboard_instance,food_dessert]=True
    

behavior find_food_carrot_2047_around_kitchen_counter_132(food_carrot:item):
    goal: not unknown(food_carrot)
    body:
        assert is_food_carrot(food_carrot)
        bind kitchen_counter_instance:item where:
            is_kitchen_counter(kitchen_counter_instance) and id[kitchen_counter_instance]==132
        achieve close_char(char,kitchen_counter_instance)
        if can_open(kitchen_counter_instance):
            achieve_once open(kitchen_counter_instance)
            exp(food_carrot,kitchen_counter_instance)
        else:
            exp(food_carrot,kitchen_counter_instance)
    eff:
        unknown[food_carrot]=False
        close[food_carrot,kitchen_counter_instance]=True
        close[kitchen_counter_instance,food_carrot]=True
    

behavior find_food_vegetable_2072_around_kitchen_counter_132(food_vegetable:item):
    goal: not unknown(food_vegetable)
    body:
        assert is_food_vegetable(food_vegetable)
        bind kitchen_counter_instance:item where:
            is_kitchen_counter(kitchen_counter_instance) and id[kitchen_counter_instance]==132
        achieve close_char(char,kitchen_counter_instance)
        if can_open(kitchen_counter_instance):
            achieve_once open(kitchen_counter_instance)
            exp(food_vegetable,kitchen_counter_instance)
        else:
            exp(food_vegetable,kitchen_counter_instance)
    eff:
        unknown[food_vegetable]=False
        close[food_vegetable,kitchen_counter_instance]=True
        close[kitchen_counter_instance,food_vegetable]=True
    

behavior find_food_food_2055_around_kitchen_counter_132(food_food:item):
    goal: not unknown(food_food)
    body:
        assert is_food_food(food_food)
        bind kitchen_counter_instance:item where:
            is_kitchen_counter(kitchen_counter_instance) and id[kitchen_counter_instance]==132
        achieve close_char(char,kitchen_counter_instance)
        if can_open(kitchen_counter_instance):
            achieve_once open(kitchen_counter_instance)
            exp(food_food,kitchen_counter_instance)
        else:
            exp(food_food,kitchen_counter_instance)
    eff:
        unknown[food_food]=False
        close[food_food,kitchen_counter_instance]=True
        close[kitchen_counter_instance,food_food]=True
    

behavior find_food_fruit_2056_around_cupboard_131(food_fruit:item):
    goal: not unknown(food_fruit)
    body:
        assert is_food_fruit(food_fruit)
        bind cupboard_instance:item where:
            is_cupboard(cupboard_instance) and id[cupboard_instance]==131
        achieve close_char(char,cupboard_instance)
        if can_open(cupboard_instance):
            achieve_once open(cupboard_instance)
            exp(food_fruit,cupboard_instance)
        else:
            exp(food_fruit,cupboard_instance)
    eff:
        unknown[food_fruit]=False
        close[food_fruit,cupboard_instance]=True
        close[cupboard_instance,food_fruit]=True
    

behavior find_food_apple_2043_around_cupboard_131(food_apple:item):
    goal: not unknown(food_apple)
    body:
        assert is_food_apple(food_apple)
        bind cupboard_instance:item where:
            is_cupboard(cupboard_instance) and id[cupboard_instance]==131
        achieve close_char(char,cupboard_instance)
        if can_open(cupboard_instance):
            achieve_once open(cupboard_instance)
            exp(food_apple,cupboard_instance)
        else:
            exp(food_apple,cupboard_instance)
    eff:
        unknown[food_apple]=False
        close[food_apple,cupboard_instance]=True
        close[cupboard_instance,food_apple]=True
    

#exp_behavior_end

#goal_representation
 
behavior wash_vegetables(vegetable:item):
    body:
        wash(vegetable)
        # Perform washing on the vegetable

behavior __goal__():
    body:
        foreach vegetable: item:
            if is_food_vegetable(vegetable) and dirty(vegetable):
                wash_vegetables(vegetable)
                # Wash each dirty vegetable

#goal_representation_end

##############################
Goal representation from planning.py

#exp_behavior

behavior find_food_carrot_2047_around_kitchen_counter_132(food_carrot:item):
    goal: not unknown(food_carrot)
    body:
        assert is_food_carrot(food_carrot)
        bind kitchen_counter_instance:item where:
            is_kitchen_counter(kitchen_counter_instance) and id[kitchen_counter_instance]==132
        achieve close_char(char,kitchen_counter_instance)
        if can_open(kitchen_counter_instance):
            achieve_once open(kitchen_counter_instance)
            exp(food_carrot,kitchen_counter_instance)
        else:
            exp(food_carrot,kitchen_counter_instance)
    eff:
        unknown[food_carrot]=False
        close[food_carrot,kitchen_counter_instance]=True
        close[kitchen_counter_instance,food_carrot]=True
    

behavior find_food_food_2055_around_cupboard_131(food_food:item):
    goal: not unknown(food_food)
    body:
        assert is_food_food(food_food)
        bind cupboard_instance:item where:
            is_cupboard(cupboard_instance) and id[cupboard_instance]==131
        achieve close_char(char,cupboard_instance)
        if can_open(cupboard_instance):
            achieve_once open(cupboard_instance)
            exp(food_food,cupboard_instance)
        else:
            exp(food_food,cupboard_instance)
    eff:
        unknown[food_food]=False
        close[food_food,cupboard_instance]=True
        close[cupboard_instance,food_food]=True
    

behavior find_food_vegetable_2072_around_kitchen_counter_132(food_vegetable:item):
    goal: not unknown(food_vegetable)
    body:
        assert is_food_vegetable(food_vegetable)
        bind kitchen_counter_instance:item where:
            is_kitchen_counter(kitchen_counter_instance) and id[kitchen_counter_instance]==132
        achieve close_char(char,kitchen_counter_instance)
        if can_open(kitchen_counter_instance):
            achieve_once open(kitchen_counter_instance)
            exp(food_vegetable,kitchen_counter_instance)
        else:
            exp(food_vegetable,kitchen_counter_instance)
    eff:
        unknown[food_vegetable]=False
        close[food_vegetable,kitchen_counter_instance]=True
        close[kitchen_counter_instance,food_vegetable]=True
    

#exp_behavior_end

#goal_representation
 
def is_food_vegetable(x: item):
    return is_food(x) and is_vegetable(x)

behavior clean_vegetable(vegetable:item):
    body:
        achieve has_water(vegetable)
        wash(vegetable)
        achieve clean(vegetable)

behavior __goal__():
    body:
        foreach vegetable: item:
            if is_food_vegetable(vegetable) and dirty(vegetable):
                clean_vegetable(vegetable)

#goal_representation_end

##############################
Inner TransformationError Debug
Error trying to process rule "function_definition":

'Function is_vegetable not found. Note that recursive function calls are not supported in the current version.'
##############################
Goal representation after debugging in planning.py
#exp_behavior

behavior find_food_carrot_2047_around_kitchen_counter_132(food_carrot:item):
    goal: not unknown(food_carrot)
    body:
        assert is_food_carrot(food_carrot)
        bind kitchen_counter_instance:item where:
            is_kitchen_counter(kitchen_counter_instance) and id[kitchen_counter_instance]==132
        achieve close_char(char,kitchen_counter_instance)
        if can_open(kitchen_counter_instance):
            achieve_once open(kitchen_counter_instance)
            exp(food_carrot,kitchen_counter_instance)
        else:
            exp(food_carrot,kitchen_counter_instance)
    eff:
        unknown[food_carrot]=False
        close[food_carrot,kitchen_counter_instance]=True
        close[kitchen_counter_instance,food_carrot]=True
    

behavior find_food_vegetable_2072_around_kitchen_counter_132(food_vegetable:item):
    goal: not unknown(food_vegetable)
    body:
        assert is_food_vegetable(food_vegetable)
        bind kitchen_counter_instance:item where:
            is_kitchen_counter(kitchen_counter_instance) and id[kitchen_counter_instance]==132
        achieve close_char(char,kitchen_counter_instance)
        if can_open(kitchen_counter_instance):
            achieve_once open(kitchen_counter_instance)
            exp(food_vegetable,kitchen_counter_instance)
        else:
            exp(food_vegetable,kitchen_counter_instance)
    eff:
        unknown[food_vegetable]=False
        close[food_vegetable,kitchen_counter_instance]=True
        close[kitchen_counter_instance,food_vegetable]=True
    

behavior find_food_food_2055_around_cupboard_131(food_food:item):
    goal: not unknown(food_food)
    body:
        assert is_food_food(food_food)
        bind cupboard_instance:item where:
            is_cupboard(cupboard_instance) and id[cupboard_instance]==131
        achieve close_char(char,cupboard_instance)
        if can_open(cupboard_instance):
            achieve_once open(cupboard_instance)
            exp(food_food,cupboard_instance)
        else:
            exp(food_food,cupboard_instance)
    eff:
        unknown[food_food]=False
        close[food_food,cupboard_instance]=True
        close[cupboard_instance,food_food]=True
    

#goal_representation
 
def is_food_vegetable(x: item):
    return is_food(x) and is_food_vegetable(x)

behavior clean_vegetable(vegetable:item):
    body:
        achieve has_water(vegetable)
        wash(vegetable)
        achieve clean(vegetable)

behavior __goal__():
    body:
        foreach vegetable: item:
            if is_food_vegetable(vegetable) and dirty(vegetable):
                clean_vegetable(vegetable)

#goal_representation_end

##############################
From agent.py->reset_goal
Failed to generate the goal representation
##############################
From agent.py
Record from func query_LLM_human in agent.py
Question: Can you teach me how to "1. wash all the vegetables." ?
Answer: Wash all the vegetables.
Re-decompose: False

##############################
Goal representation from planning.py

#exp_behavior

behavior find_food_dessert_2051_around_kitchen_counter_132(food_dessert:item):
    goal: not unknown(food_dessert)
    body:
        assert is_food_dessert(food_dessert)
        bind kitchen_counter_instance:item where:
            is_kitchen_counter(kitchen_counter_instance) and id[kitchen_counter_instance]==132
        achieve close_char(char,kitchen_counter_instance)
        if can_open(kitchen_counter_instance):
            achieve_once open(kitchen_counter_instance)
            exp(food_dessert,kitchen_counter_instance)
        else:
            exp(food_dessert,kitchen_counter_instance)
    eff:
        unknown[food_dessert]=False
        close[food_dessert,kitchen_counter_instance]=True
        close[kitchen_counter_instance,food_dessert]=True
    

behavior find_food_carrot_2047_around_kitchen_counter_132(food_carrot:item):
    goal: not unknown(food_carrot)
    body:
        assert is_food_carrot(food_carrot)
        bind kitchen_counter_instance:item where:
            is_kitchen_counter(kitchen_counter_instance) and id[kitchen_counter_instance]==132
        achieve close_char(char,kitchen_counter_instance)
        if can_open(kitchen_counter_instance):
            achieve_once open(kitchen_counter_instance)
            exp(food_carrot,kitchen_counter_instance)
        else:
            exp(food_carrot,kitchen_counter_instance)
    eff:
        unknown[food_carrot]=False
        close[food_carrot,kitchen_counter_instance]=True
        close[kitchen_counter_instance,food_carrot]=True
    

behavior find_food_vegetable_2072_around_kitchen_counter_132(food_vegetable:item):
    goal: not unknown(food_vegetable)
    body:
        assert is_food_vegetable(food_vegetable)
        bind kitchen_counter_instance:item where:
            is_kitchen_counter(kitchen_counter_instance) and id[kitchen_counter_instance]==132
        achieve close_char(char,kitchen_counter_instance)
        if can_open(kitchen_counter_instance):
            achieve_once open(kitchen_counter_instance)
            exp(food_vegetable,kitchen_counter_instance)
        else:
            exp(food_vegetable,kitchen_counter_instance)
    eff:
        unknown[food_vegetable]=False
        close[food_vegetable,kitchen_counter_instance]=True
        close[kitchen_counter_instance,food_vegetable]=True
    

behavior find_food_lemon_2061_around_cupboard_131(food_lemon:item):
    goal: not unknown(food_lemon)
    body:
        assert is_food_lemon(food_lemon)
        bind cupboard_instance:item where:
            is_cupboard(cupboard_instance) and id[cupboard_instance]==131
        achieve close_char(char,cupboard_instance)
        if can_open(cupboard_instance):
            achieve_once open(cupboard_instance)
            exp(food_lemon,cupboard_instance)
        else:
            exp(food_lemon,cupboard_instance)
    eff:
        unknown[food_lemon]=False
        close[food_lemon,cupboard_instance]=True
        close[cupboard_instance,food_lemon]=True
    

behavior find_food_food_2055_around_kitchen_counter_132(food_food:item):
    goal: not unknown(food_food)
    body:
        assert is_food_food(food_food)
        bind kitchen_counter_instance:item where:
            is_kitchen_counter(kitchen_counter_instance) and id[kitchen_counter_instance]==132
        achieve close_char(char,kitchen_counter_instance)
        if can_open(kitchen_counter_instance):
            achieve_once open(kitchen_counter_instance)
            exp(food_food,kitchen_counter_instance)
        else:
            exp(food_food,kitchen_counter_instance)
    eff:
        unknown[food_food]=False
        close[food_food,kitchen_counter_instance]=True
        close[kitchen_counter_instance,food_food]=True
    

behavior find_food_onion_2026_around_cupboard_131(food_onion:item):
    goal: not unknown(food_onion)
    body:
        assert is_food_onion(food_onion)
        bind cupboard_instance:item where:
            is_cupboard(cupboard_instance) and id[cupboard_instance]==131
        achieve close_char(char,cupboard_instance)
        if can_open(cupboard_instance):
            achieve_once open(cupboard_instance)
            exp(food_onion,cupboard_instance)
        else:
            exp(food_onion,cupboard_instance)
    eff:
        unknown[food_onion]=False
        close[food_onion,cupboard_instance]=True
        close[cupboard_instance,food_onion]=True
    

behavior find_food_potato_2066_around_kitchen_counter_132(food_potato:item):
    goal: not unknown(food_potato)
    body:
        assert is_food_potato(food_potato)
        bind kitchen_counter_instance:item where:
            is_kitchen_counter(kitchen_counter_instance) and id[kitchen_counter_instance]==132
        achieve close_char(char,kitchen_counter_instance)
        if can_open(kitchen_counter_instance):
            achieve_once open(kitchen_counter_instance)
            exp(food_potato,kitchen_counter_instance)
        else:
            exp(food_potato,kitchen_counter_instance)
    eff:
        unknown[food_potato]=False
        close[food_potato,kitchen_counter_instance]=True
        close[kitchen_counter_instance,food_potato]=True
    

#exp_behavior_end

#goal_representation

def is_vegetable_clean(vegetable: item):
    # Determine if the vegetable is clean
    symbol clean_status = clean(vegetable)
    return clean_status

behavior wash_vegetable(vegetable: item):
    body:
        wash(vegetable)
        # Wash the vegetable to ensure cleanliness

behavior __goal__():
    body:
        foreach vegetable: item:
            if is_food_vegetable(vegetable) and not is_vegetable_clean(vegetable):
                # Check all vegetables that are not already clean
                wash_vegetable(vegetable)

#goal_representation_end

##############################
From agent.py-> find a plan in act()
walk_executor(kitchen_counter_132)exp(food_vegetable_2072, kitchen_counter_132)walk_executor(food_vegetable_2072)wash_executor(food_vegetable_2072)
##############################
From agent.py
walk_executor(kitchen_counter_132)
Find pot_54. Find tray_142. Robot is inside dining_room_1. Robot is close kitchen_counter_132. Robot is no longer inside home_office_161.
##############################
From evaluation.py
cdl_dataset/dataset/Cook_some_food/g4.txt
Checking k1
missed actions: walk_executor(pot_54);open_executor(pot_54);walk_executor(freezer_140);switchoff_executor(freezer_140);open_executor(freezer_140);walk_executor(food_vegetable_2072);grab_executor(food_vegetable_2072);walk_executor(pot_54);putin_executor(food_vegetable_2072, pot_54);walk_executor(oven_141);switchon_executor(oven_141);
missed action num: 11
##############################
From evaluation.py
cdl_dataset/dataset/Cook_some_food/g4.txt
Checking k2
missed actions: walk_executor(pot_2093);open_executor(pot_2093);walk_executor(freezer_140);switchoff_executor(freezer_140);open_executor(freezer_140);walk_executor(food_vegetable_2072);grab_executor(food_vegetable_2072);walk_executor(pot_2093);putin_executor(food_vegetable_2072, pot_2093);walk_executor(stove_2090);open_executor(stove_2090);walk_executor(pot_2093);grab_executor(pot_2093);walk_executor(stove_2090);putin_executor(pot_2093, stove_2090);close_executor(stove_2090);switchon_executor(stove_2090);
missed action num: 17
##############################
From agent.py
exp(food_vegetable_2072, kitchen_counter_132)
Failed to find food_vegetable_2072 around kitchen_counter_132. 
##############################
From agent.py-> find a plan in act()
walk_executor(cupboard_131)open_executor(cupboard_131)exp(food_vegetable_2072, cupboard_131)walk_executor(food_vegetable_2072)wash_executor(food_vegetable_2072)
##############################
From agent.py
walk_executor(cupboard_131)
Robot is inside dining_room_1. Robot is close cupboard_131. Robot is no longer close kitchen_counter_132.
##############################
From evaluation.py
cdl_dataset/dataset/Cook_some_food/g4.txt
Checking k1
missed actions: walk_executor(pot_54);open_executor(pot_54);walk_executor(freezer_140);switchoff_executor(freezer_140);open_executor(freezer_140);walk_executor(food_vegetable_2072);grab_executor(food_vegetable_2072);walk_executor(pot_54);putin_executor(food_vegetable_2072, pot_54);walk_executor(oven_141);switchon_executor(oven_141);
missed action num: 11
##############################
From evaluation.py
cdl_dataset/dataset/Cook_some_food/g4.txt
Checking k2
missed actions: walk_executor(pot_2093);open_executor(pot_2093);walk_executor(freezer_140);switchoff_executor(freezer_140);open_executor(freezer_140);walk_executor(food_vegetable_2072);grab_executor(food_vegetable_2072);walk_executor(pot_2093);putin_executor(food_vegetable_2072, pot_2093);walk_executor(stove_2090);open_executor(stove_2090);walk_executor(pot_2093);grab_executor(pot_2093);walk_executor(stove_2090);putin_executor(pot_2093, stove_2090);close_executor(stove_2090);switchon_executor(stove_2090);
missed action num: 17
##############################
From agent.py
open_executor(cupboard_131)
Robot is inside dining_room_1. Robot is close cupboard_131. 
##############################
From evaluation.py
cdl_dataset/dataset/Cook_some_food/g4.txt
Checking k1
missed actions: walk_executor(pot_54);open_executor(pot_54);walk_executor(freezer_140);switchoff_executor(freezer_140);open_executor(freezer_140);walk_executor(food_vegetable_2072);grab_executor(food_vegetable_2072);walk_executor(pot_54);putin_executor(food_vegetable_2072, pot_54);walk_executor(oven_141);switchon_executor(oven_141);
missed action num: 11
##############################
From evaluation.py
cdl_dataset/dataset/Cook_some_food/g4.txt
Checking k2
missed actions: walk_executor(pot_2093);open_executor(pot_2093);walk_executor(freezer_140);switchoff_executor(freezer_140);open_executor(freezer_140);walk_executor(food_vegetable_2072);grab_executor(food_vegetable_2072);walk_executor(pot_2093);putin_executor(food_vegetable_2072, pot_2093);walk_executor(stove_2090);open_executor(stove_2090);walk_executor(pot_2093);grab_executor(pot_2093);walk_executor(stove_2090);putin_executor(pot_2093, stove_2090);close_executor(stove_2090);switchon_executor(stove_2090);
missed action num: 17
##############################
From agent.py
exp(food_vegetable_2072, cupboard_131)
Failed to find food_vegetable_2072 around cupboard_131. 
##############################
From agent.py-> find a plan in act()
walk_executor(kitchen_counter_129)exp(food_vegetable_2072, kitchen_counter_129)walk_executor(food_vegetable_2072)wash_executor(food_vegetable_2072)
##############################
From agent.py
walk_executor(kitchen_counter_129)
Find oil_2102. Find pot_2093. Find fryingpan_2107. Robot is inside dining_room_1. Robot is close kitchen_counter_129. Robot is no longer close cupboard_131.
##############################
From evaluation.py
cdl_dataset/dataset/Cook_some_food/g4.txt
Checking k1
missed actions: walk_executor(pot_54);open_executor(pot_54);walk_executor(freezer_140);switchoff_executor(freezer_140);open_executor(freezer_140);walk_executor(food_vegetable_2072);grab_executor(food_vegetable_2072);walk_executor(pot_54);putin_executor(food_vegetable_2072, pot_54);walk_executor(oven_141);switchon_executor(oven_141);
missed action num: 11
##############################
From evaluation.py
cdl_dataset/dataset/Cook_some_food/g4.txt
Checking k2
missed actions: walk_executor(pot_2093);open_executor(pot_2093);walk_executor(freezer_140);switchoff_executor(freezer_140);open_executor(freezer_140);walk_executor(food_vegetable_2072);grab_executor(food_vegetable_2072);walk_executor(pot_2093);putin_executor(food_vegetable_2072, pot_2093);walk_executor(stove_2090);open_executor(stove_2090);walk_executor(pot_2093);grab_executor(pot_2093);walk_executor(stove_2090);putin_executor(pot_2093, stove_2090);close_executor(stove_2090);switchon_executor(stove_2090);
missed action num: 17
##############################
From agent.py
exp(food_vegetable_2072, kitchen_counter_129)
Failed to find food_vegetable_2072 around kitchen_counter_129. 
##############################
From agent.py-> find a plan in act()
walk_executor(sink_307)exp(food_vegetable_2072, sink_307)walk_executor(food_vegetable_2072)wash_executor(food_vegetable_2072)
##############################
From agent.py
walk_executor(sink_307)
Find detergent_2108. Find drawing_296. Find towel_rack_298. Robot is inside bathroom_265. Robot is close bathroom_counter_306. Robot is close sink_307. Robot is no longer inside dining_room_1.Robot is no longer close kitchen_counter_129.
##############################
From evaluation.py
cdl_dataset/dataset/Cook_some_food/g4.txt
Checking k1
missed actions: walk_executor(pot_54);open_executor(pot_54);walk_executor(freezer_140);switchoff_executor(freezer_140);open_executor(freezer_140);walk_executor(food_vegetable_2072);grab_executor(food_vegetable_2072);walk_executor(pot_54);putin_executor(food_vegetable_2072, pot_54);walk_executor(oven_141);switchon_executor(oven_141);
missed action num: 11
##############################
From evaluation.py
cdl_dataset/dataset/Cook_some_food/g4.txt
Checking k2
missed actions: walk_executor(pot_2093);open_executor(pot_2093);walk_executor(freezer_140);switchoff_executor(freezer_140);open_executor(freezer_140);walk_executor(food_vegetable_2072);grab_executor(food_vegetable_2072);walk_executor(pot_2093);putin_executor(food_vegetable_2072, pot_2093);walk_executor(stove_2090);open_executor(stove_2090);walk_executor(pot_2093);grab_executor(pot_2093);walk_executor(stove_2090);putin_executor(pot_2093, stove_2090);close_executor(stove_2090);switchon_executor(stove_2090);
missed action num: 17
##############################
From agent.py
exp(food_vegetable_2072, sink_307)
Failed to find food_vegetable_2072 around sink_307. 
##############################
From agent.py-> find a plan in act()
walk_executor(pot_2093)open_executor(pot_2093)exp(food_vegetable_2072, pot_2093)walk_executor(food_vegetable_2072)wash_executor(food_vegetable_2072)
##############################
From agent.py
walk_executor(pot_2093)
Robot is inside dining_room_1. Robot is close kitchen_counter_129. Robot is close pot_2093. Robot is no longer inside bathroom_265.Robot is no longer close bathroom_counter_306.Robot is no longer close sink_307.
##############################
From evaluation.py
cdl_dataset/dataset/Cook_some_food/g4.txt
Checking k1
missed actions: walk_executor(pot_54);open_executor(pot_54);walk_executor(freezer_140);switchoff_executor(freezer_140);open_executor(freezer_140);walk_executor(food_vegetable_2072);grab_executor(food_vegetable_2072);walk_executor(pot_54);putin_executor(food_vegetable_2072, pot_54);walk_executor(oven_141);switchon_executor(oven_141);
missed action num: 11
##############################
From evaluation.py
cdl_dataset/dataset/Cook_some_food/g4.txt
Checking k2
missed actions: open_executor(pot_2093);walk_executor(freezer_140);switchoff_executor(freezer_140);open_executor(freezer_140);walk_executor(food_vegetable_2072);grab_executor(food_vegetable_2072);walk_executor(pot_2093);putin_executor(food_vegetable_2072, pot_2093);walk_executor(stove_2090);open_executor(stove_2090);walk_executor(pot_2093);grab_executor(pot_2093);walk_executor(stove_2090);putin_executor(pot_2093, stove_2090);close_executor(stove_2090);switchon_executor(stove_2090);
missed action num: 16
##############################
From agent.py
open_executor(pot_2093)
Robot is inside dining_room_1. Robot is close kitchen_counter_129. Robot is close pot_2093. 
##############################
From evaluation.py
cdl_dataset/dataset/Cook_some_food/g4.txt
Checking k1
missed actions: walk_executor(pot_54);open_executor(pot_54);walk_executor(freezer_140);switchoff_executor(freezer_140);open_executor(freezer_140);walk_executor(food_vegetable_2072);grab_executor(food_vegetable_2072);walk_executor(pot_54);putin_executor(food_vegetable_2072, pot_54);walk_executor(oven_141);switchon_executor(oven_141);
missed action num: 11
##############################
From evaluation.py
cdl_dataset/dataset/Cook_some_food/g4.txt
Checking k2
missed actions: walk_executor(freezer_140);switchoff_executor(freezer_140);open_executor(freezer_140);walk_executor(food_vegetable_2072);grab_executor(food_vegetable_2072);walk_executor(pot_2093);putin_executor(food_vegetable_2072, pot_2093);walk_executor(stove_2090);open_executor(stove_2090);walk_executor(pot_2093);grab_executor(pot_2093);walk_executor(stove_2090);putin_executor(pot_2093, stove_2090);close_executor(stove_2090);switchon_executor(stove_2090);
missed action num: 15
##############################
From agent.py
exp(food_vegetable_2072, pot_2093)
Failed to find food_vegetable_2072 around pot_2093. 
##############################
From agent.py
Reset goals: The sub-goals are: 
['1. Wash all the vegetables.', '2. Put the vegetables in a pot and boil them on the stove.', '3. Store the pot in the fridge.']
##############################
Goal representation from planning.py

#exp_behavior

behavior find_food_carrot_2047_around_kitchen_counter_128(food_carrot:item):
    goal: not unknown(food_carrot)
    body:
        assert is_food_carrot(food_carrot)
        bind kitchen_counter_instance:item where:
            is_kitchen_counter(kitchen_counter_instance) and id[kitchen_counter_instance]==128
        achieve close_char(char,kitchen_counter_instance)
        if can_open(kitchen_counter_instance):
            achieve_once open(kitchen_counter_instance)
            exp(food_carrot,kitchen_counter_instance)
        else:
            exp(food_carrot,kitchen_counter_instance)
    eff:
        unknown[food_carrot]=False
        close[food_carrot,kitchen_counter_instance]=True
        close[kitchen_counter_instance,food_carrot]=True
    

behavior find_food_food_2055_around_toaster_144(food_food:item):
    goal: not unknown(food_food)
    body:
        assert is_food_food(food_food)
        bind toaster_instance:item where:
            is_toaster(toaster_instance) and id[toaster_instance]==144
        achieve close_char(char,toaster_instance)
        if can_open(toaster_instance):
            achieve_once open(toaster_instance)
            exp(food_food,toaster_instance)
        else:
            exp(food_food,toaster_instance)
    eff:
        unknown[food_food]=False
        close[food_food,toaster_instance]=True
        close[toaster_instance,food_food]=True
    

behavior find_food_vegetable_2072_around_kitchen_counter_128(food_vegetable:item):
    goal: not unknown(food_vegetable)
    body:
        assert is_food_vegetable(food_vegetable)
        bind kitchen_counter_instance:item where:
            is_kitchen_counter(kitchen_counter_instance) and id[kitchen_counter_instance]==128
        achieve close_char(char,kitchen_counter_instance)
        if can_open(kitchen_counter_instance):
            achieve_once open(kitchen_counter_instance)
            exp(food_vegetable,kitchen_counter_instance)
        else:
            exp(food_vegetable,kitchen_counter_instance)
    eff:
        unknown[food_vegetable]=False
        close[food_vegetable,kitchen_counter_instance]=True
        close[kitchen_counter_instance,food_vegetable]=True
    

#exp_behavior_end

#goal_representation
 
def is_vegetable(item: item):
    # Check if an item is classified as a vegetable
    return is_food_vegetable(item)

behavior observe_for_vegetables(location: item):
    body:
        observe(location, "Check if there are any vegetables here")

behavior clean_vegetables(vegetable: item, sink: item):
    body:
        achieve inside(vegetable, sink)
        # Ensure the vegetable is placed inside the sink
        
        if has_faucet(sink):
            bind faucet: item where:
                is_faucet(faucet) and close(faucet, sink)
            achieve_once is_on(faucet)
            wash(vegetable) # Wash the vegetable
            achieve_once is_off(faucet)
        else:
            wash(vegetable)
          
def has_faucet(sink: item):
    # Check if a sink has a faucet close enough to use
    symbol has_faucet = exists faucet: item: is_faucet(faucet) and close(faucet, sink)
    return has_faucet

behavior __goal__():
    body:
        if exists vegetable: item : is_vegetable(vegetable) and dirty(vegetable):
            # Check if we have found any unwashed vegetables
            bind vegetable: item where:
                is_vegetable(vegetable) and dirty(vegetable) 
            # Select a dirty vegetable
             
            bind sink: item where:
                is_sink(sink)
            # Select a sink
            clean_vegetables(vegetable, sink)
        else:
            # If no unwashed vegetables are identified so far, inspect potential locations
            foreach location: item:
                if ((is_kitchen_counter(location) or is_cupboard(location) or is_pot(location)) and not visited(location)):
                    observe_for_vegetables(location)

#goal_representation_end

##############################
Inner TransformationError Debug
Error trying to process rule "behavior_definition":

'Function has_faucet not found. Note that recursive function calls are not supported in the current version.'
##############################
Goal representation after debugging in planning.py
#exp_behavior

behavior find_food_carrot_2047_around_kitchen_counter_128(food_carrot:item):
    goal: not unknown(food_carrot)
    body:
        assert is_food_carrot(food_carrot)
        bind kitchen_counter_instance:item where:
            is_kitchen_counter(kitchen_counter_instance) and id[kitchen_counter_instance]==128
        achieve close_char(char,kitchen_counter_instance)
        if can_open(kitchen_counter_instance):
            achieve_once open(kitchen_counter_instance)
            exp(food_carrot,kitchen_counter_instance)
        else:
            exp(food_carrot,kitchen_counter_instance)
    eff:
        unknown[food_carrot]=False
        close[food_carrot,kitchen_counter_instance]=True
        close[kitchen_counter_instance,food_carrot]=True
    

behavior find_food_vegetable_2072_around_kitchen_counter_128(food_vegetable:item):
    goal: not unknown(food_vegetable)
    body:
        assert is_food_vegetable(food_vegetable)
        bind kitchen_counter_instance:item where:
            is_kitchen_counter(kitchen_counter_instance) and id[kitchen_counter_instance]==128
        achieve close_char(char,kitchen_counter_instance)
        if can_open(kitchen_counter_instance):
            achieve_once open(kitchen_counter_instance)
            exp(food_vegetable,kitchen_counter_instance)
        else:
            exp(food_vegetable,kitchen_counter_instance)
    eff:
        unknown[food_vegetable]=False
        close[food_vegetable,kitchen_counter_instance]=True
        close[kitchen_counter_instance,food_vegetable]=True
    

behavior find_food_food_2055_around_microwave_149(food_food:item):
    goal: not unknown(food_food)
    body:
        assert is_food_food(food_food)
        bind microwave_instance:item where:
            is_microwave(microwave_instance) and id[microwave_instance]==149
        achieve close_char(char,microwave_instance)
        if can_open(microwave_instance):
            achieve_once open(microwave_instance)
            exp(food_food,microwave_instance)
        else:
            exp(food_food,microwave_instance)
    eff:
        unknown[food_food]=False
        close[food_food,microwave_instance]=True
        close[microwave_instance,food_food]=True
    

behavior find_food_onion_2026_around_kitchen_counter_128(food_onion:item):
    goal: not unknown(food_onion)
    body:
        assert is_food_onion(food_onion)
        bind kitchen_counter_instance:item where:
            is_kitchen_counter(kitchen_counter_instance) and id[kitchen_counter_instance]==128
        achieve close_char(char,kitchen_counter_instance)
        if can_open(kitchen_counter_instance):
            achieve_once open(kitchen_counter_instance)
            exp(food_onion,kitchen_counter_instance)
        else:
            exp(food_onion,kitchen_counter_instance)
    eff:
        unknown[food_onion]=False
        close[food_onion,kitchen_counter_instance]=True
        close[kitchen_counter_instance,food_onion]=True
    

behavior find_food_potato_2066_around_kitchen_counter_128(food_potato:item):
    goal: not unknown(food_potato)
    body:
        assert is_food_potato(food_potato)
        bind kitchen_counter_instance:item where:
            is_kitchen_counter(kitchen_counter_instance) and id[kitchen_counter_instance]==128
        achieve close_char(char,kitchen_counter_instance)
        if can_open(kitchen_counter_instance):
            achieve_once open(kitchen_counter_instance)
            exp(food_potato,kitchen_counter_instance)
        else:
            exp(food_potato,kitchen_counter_instance)
    eff:
        unknown[food_potato]=False
        close[food_potato,kitchen_counter_instance]=True
        close[kitchen_counter_instance,food_potato]=True
    

#goal_representation
 
def is_vegetable(item: item):
    # Check if an item is classified as a vegetable
    return is_food_vegetable(item)

behavior observe_for_vegetables(location: item):
    body:
        observe(location, "Check if there are any vegetables here")

behavior clean_vegetables(vegetable: item, sink: item):
    body:
        achieve inside(vegetable, sink)
        # Ensure the vegetable is placed inside the sink
        
        if has_faucet(sink):
            bind faucet: item where:
                is_faucet(faucet) and close(faucet, sink)
            achieve_once is_on(faucet)
            wash(vegetable) # Wash the vegetable
            achieve_once is_off(faucet)
        else:
            wash(vegetable)
          
def has_faucet(sink: item):
    # Check if a sink has a faucet close enough to use
    symbol has_faucet = exists faucet: item: is_faucet(faucet) and close(faucet, sink)
    return has_faucet

behavior __goal__():
    body:
        if exists vegetable: item : is_vegetable(vegetable) and dirty(vegetable):
            # Check if we have found any unwashed vegetables
            bind vegetable: item where:
                is_vegetable(vegetable) and dirty(vegetable) 
            # Select a dirty vegetable
             
            bind sink: item where:
                is_sink(sink)
            # Select a sink
            clean_vegetables(vegetable, sink)
        else:
            # If no unwashed vegetables are identified so far, inspect potential locations
            foreach location: item:
                if ((is_kitchen_counter(location) or is_cupboard(location) or is_pot(location)) and not visited(location)):
                    observe_for_vegetables(location)

#goal_representation_end

##############################
Inner TransformationError Debug
Error trying to process rule "behavior_definition":

'Function has_faucet not found. Note that recursive function calls are not supported in the current version.'
##############################
Goal representation after debugging in planning.py
#exp_behavior

behavior find_food_vegetable_2072_around_kitchen_counter_128(food_vegetable:item):
    goal: not unknown(food_vegetable)
    body:
        assert is_food_vegetable(food_vegetable)
        bind kitchen_counter_instance:item where:
            is_kitchen_counter(kitchen_counter_instance) and id[kitchen_counter_instance]==128
        achieve close_char(char,kitchen_counter_instance)
        if can_open(kitchen_counter_instance):
            achieve_once open(kitchen_counter_instance)
            exp(food_vegetable,kitchen_counter_instance)
        else:
            exp(food_vegetable,kitchen_counter_instance)
    eff:
        unknown[food_vegetable]=False
        close[food_vegetable,kitchen_counter_instance]=True
        close[kitchen_counter_instance,food_vegetable]=True
    

behavior find_food_food_2055_around_kitchen_counter_128(food_food:item):
    goal: not unknown(food_food)
    body:
        assert is_food_food(food_food)
        bind kitchen_counter_instance:item where:
            is_kitchen_counter(kitchen_counter_instance) and id[kitchen_counter_instance]==128
        achieve close_char(char,kitchen_counter_instance)
        if can_open(kitchen_counter_instance):
            achieve_once open(kitchen_counter_instance)
            exp(food_food,kitchen_counter_instance)
        else:
            exp(food_food,kitchen_counter_instance)
    eff:
        unknown[food_food]=False
        close[food_food,kitchen_counter_instance]=True
        close[kitchen_counter_instance,food_food]=True
    

behavior find_food_potato_2066_around_kitchen_counter_128(food_potato:item):
    goal: not unknown(food_potato)
    body:
        assert is_food_potato(food_potato)
        bind kitchen_counter_instance:item where:
            is_kitchen_counter(kitchen_counter_instance) and id[kitchen_counter_instance]==128
        achieve close_char(char,kitchen_counter_instance)
        if can_open(kitchen_counter_instance):
            achieve_once open(kitchen_counter_instance)
            exp(food_potato,kitchen_counter_instance)
        else:
            exp(food_potato,kitchen_counter_instance)
    eff:
        unknown[food_potato]=False
        close[food_potato,kitchen_counter_instance]=True
        close[kitchen_counter_instance,food_potato]=True
    

#goal_representation
 
def is_vegetable(item: item):
    # Check if an item is classified as a vegetable
    return is_food_vegetable(item)

behavior observe_for_vegetables(location: item):
    body:
        observe(location, "Check if there are any vegetables here")

behavior clean_vegetables(vegetable: item, sink: item):
    body:
        achieve inside(vegetable, sink)
        # Ensure the vegetable is placed inside the sink
        
        if has_faucet(sink):
            bind faucet: item where:
                is_faucet(faucet) and close(faucet, sink)
            achieve_once is_on(faucet)
            wash(vegetable) # Wash the vegetable
            achieve_once is_off(faucet)
        else:
            wash(vegetable)
          
def has_faucet(sink: item):
    # Check if a sink has a faucet close enough to use
    symbol has_faucet = exists faucet: item: is_faucet(faucet) and close(faucet, sink)
    return has_faucet

behavior __goal__():
    body:
        if exists vegetable: item : is_vegetable(vegetable) and dirty(vegetable):
            # Check if we have found any unwashed vegetables
            bind vegetable: item where:
                is_vegetable(vegetable) and dirty(vegetable) 
            # Select a dirty vegetable
             
            bind sink: item where:
                is_sink(sink)
            # Select a sink
            clean_vegetables(vegetable, sink)
        else:
            # If no unwashed vegetables are identified so far, inspect potential locations
            foreach location: item:
                if ((is_kitchen_counter(location) or is_cupboard(location) or is_pot(location)) and not visited(location)):
                    observe_for_vegetables(location)

#goal_representation_end

##############################
Goal representation from planning.py

#exp_behavior

behavior find_food_dessert_2051_around_microwave_149(food_dessert:item):
    goal: not unknown(food_dessert)
    body:
        assert is_food_dessert(food_dessert)
        bind microwave_instance:item where:
            is_microwave(microwave_instance) and id[microwave_instance]==149
        achieve close_char(char,microwave_instance)
        if can_open(microwave_instance):
            achieve_once open(microwave_instance)
            exp(food_dessert,microwave_instance)
        else:
            exp(food_dessert,microwave_instance)
    eff:
        unknown[food_dessert]=False
        close[food_dessert,microwave_instance]=True
        close[microwave_instance,food_dessert]=True
    

behavior find_food_carrot_2047_around_kitchen_counter_128(food_carrot:item):
    goal: not unknown(food_carrot)
    body:
        assert is_food_carrot(food_carrot)
        bind kitchen_counter_instance:item where:
            is_kitchen_counter(kitchen_counter_instance) and id[kitchen_counter_instance]==128
        achieve close_char(char,kitchen_counter_instance)
        if can_open(kitchen_counter_instance):
            achieve_once open(kitchen_counter_instance)
            exp(food_carrot,kitchen_counter_instance)
        else:
            exp(food_carrot,kitchen_counter_instance)
    eff:
        unknown[food_carrot]=False
        close[food_carrot,kitchen_counter_instance]=True
        close[kitchen_counter_instance,food_carrot]=True
    

behavior find_food_food_2055_around_toaster_144(food_food:item):
    goal: not unknown(food_food)
    body:
        assert is_food_food(food_food)
        bind toaster_instance:item where:
            is_toaster(toaster_instance) and id[toaster_instance]==144
        achieve close_char(char,toaster_instance)
        if can_open(toaster_instance):
            achieve_once open(toaster_instance)
            exp(food_food,toaster_instance)
        else:
            exp(food_food,toaster_instance)
    eff:
        unknown[food_food]=False
        close[food_food,toaster_instance]=True
        close[toaster_instance,food_food]=True
    

behavior find_food_onion_2026_around_kitchen_counter_128(food_onion:item):
    goal: not unknown(food_onion)
    body:
        assert is_food_onion(food_onion)
        bind kitchen_counter_instance:item where:
            is_kitchen_counter(kitchen_counter_instance) and id[kitchen_counter_instance]==128
        achieve close_char(char,kitchen_counter_instance)
        if can_open(kitchen_counter_instance):
            achieve_once open(kitchen_counter_instance)
            exp(food_onion,kitchen_counter_instance)
        else:
            exp(food_onion,kitchen_counter_instance)
    eff:
        unknown[food_onion]=False
        close[food_onion,kitchen_counter_instance]=True
        close[kitchen_counter_instance,food_onion]=True
    

behavior find_food_banana_2045_around_kitchen_counter_128(food_banana:item):
    goal: not unknown(food_banana)
    body:
        assert is_food_banana(food_banana)
        bind kitchen_counter_instance:item where:
            is_kitchen_counter(kitchen_counter_instance) and id[kitchen_counter_instance]==128
        achieve close_char(char,kitchen_counter_instance)
        if can_open(kitchen_counter_instance):
            achieve_once open(kitchen_counter_instance)
            exp(food_banana,kitchen_counter_instance)
        else:
            exp(food_banana,kitchen_counter_instance)
    eff:
        unknown[food_banana]=False
        close[food_banana,kitchen_counter_instance]=True
        close[kitchen_counter_instance,food_banana]=True
    

behavior find_food_potato_2066_around_photoframe_246(food_potato:item):
    goal: not unknown(food_potato)
    body:
        assert is_food_potato(food_potato)
        bind photoframe_instance:item where:
            is_photoframe(photoframe_instance) and id[photoframe_instance]==246
        achieve close_char(char,photoframe_instance)
        if can_open(photoframe_instance):
            achieve_once open(photoframe_instance)
            exp(food_potato,photoframe_instance)
        else:
            exp(food_potato,photoframe_instance)
    eff:
        unknown[food_potato]=False
        close[food_potato,photoframe_instance]=True
        close[photoframe_instance,food_potato]=True
    

#exp_behavior_end

#goal_representation
 
def is_vegetable_found(vegetable: item):
    # Determine if the vegetable has been located or observed
    symbol found=visited(vegetable)
    return found

behavior __goal__():
    body:
        foreach vegetable: item:
            if is_food_vegetable(vegetable) and not is_vegetable_found(vegetable):
                # Check all unvisited items categorized as vegetables
                observe(vegetable, "Locate the vegetable for washing")
                # Observe each vegetable to locate them
        
        foreach vegetable: item:
            if is_food_vegetable(vegetable) and is_vegetable_found(vegetable):
                bind sink: item where:
                    is_sink(sink)
                achieve close_char(char, vegetable)
                clean_food(vegetable, sink)
                # Ensure each found vegetable is washed in the sink

#goal_representation_end

##############################
Inner TransformationError Debug
Error trying to process rule "behavior_definition":

'Function clean_food not found. Note that recursive function calls are not supported in the current version.'
##############################
Goal representation after debugging in planning.py
#exp_behavior

behavior find_food_carrot_2047_around_kitchen_counter_128(food_carrot:item):
    goal: not unknown(food_carrot)
    body:
        assert is_food_carrot(food_carrot)
        bind kitchen_counter_instance:item where:
            is_kitchen_counter(kitchen_counter_instance) and id[kitchen_counter_instance]==128
        achieve close_char(char,kitchen_counter_instance)
        if can_open(kitchen_counter_instance):
            achieve_once open(kitchen_counter_instance)
            exp(food_carrot,kitchen_counter_instance)
        else:
            exp(food_carrot,kitchen_counter_instance)
    eff:
        unknown[food_carrot]=False
        close[food_carrot,kitchen_counter_instance]=True
        close[kitchen_counter_instance,food_carrot]=True
    

behavior find_food_potato_2066_around_kitchen_counter_128(food_potato:item):
    goal: not unknown(food_potato)
    body:
        assert is_food_potato(food_potato)
        bind kitchen_counter_instance:item where:
            is_kitchen_counter(kitchen_counter_instance) and id[kitchen_counter_instance]==128
        achieve close_char(char,kitchen_counter_instance)
        if can_open(kitchen_counter_instance):
            achieve_once open(kitchen_counter_instance)
            exp(food_potato,kitchen_counter_instance)
        else:
            exp(food_potato,kitchen_counter_instance)
    eff:
        unknown[food_potato]=False
        close[food_potato,kitchen_counter_instance]=True
        close[kitchen_counter_instance,food_potato]=True
    

behavior find_food_lemon_2061_around_kitchen_counter_128(food_lemon:item):
    goal: not unknown(food_lemon)
    body:
        assert is_food_lemon(food_lemon)
        bind kitchen_counter_instance:item where:
            is_kitchen_counter(kitchen_counter_instance) and id[kitchen_counter_instance]==128
        achieve close_char(char,kitchen_counter_instance)
        if can_open(kitchen_counter_instance):
            achieve_once open(kitchen_counter_instance)
            exp(food_lemon,kitchen_counter_instance)
        else:
            exp(food_lemon,kitchen_counter_instance)
    eff:
        unknown[food_lemon]=False
        close[food_lemon,kitchen_counter_instance]=True
        close[kitchen_counter_instance,food_lemon]=True
    

behavior find_food_vegetable_2072_around_kitchen_counter_128(food_vegetable:item):
    goal: not unknown(food_vegetable)
    body:
        assert is_food_vegetable(food_vegetable)
        bind kitchen_counter_instance:item where:
            is_kitchen_counter(kitchen_counter_instance) and id[kitchen_counter_instance]==128
        achieve close_char(char,kitchen_counter_instance)
        if can_open(kitchen_counter_instance):
            achieve_once open(kitchen_counter_instance)
            exp(food_vegetable,kitchen_counter_instance)
        else:
            exp(food_vegetable,kitchen_counter_instance)
    eff:
        unknown[food_vegetable]=False
        close[food_vegetable,kitchen_counter_instance]=True
        close[kitchen_counter_instance,food_vegetable]=True
    

behavior find_food_food_2055_around_kitchen_counter_128(food_food:item):
    goal: not unknown(food_food)
    body:
        assert is_food_food(food_food)
        bind kitchen_counter_instance:item where:
            is_kitchen_counter(kitchen_counter_instance) and id[kitchen_counter_instance]==128
        achieve close_char(char,kitchen_counter_instance)
        if can_open(kitchen_counter_instance):
            achieve_once open(kitchen_counter_instance)
            exp(food_food,kitchen_counter_instance)
        else:
            exp(food_food,kitchen_counter_instance)
    eff:
        unknown[food_food]=False
        close[food_food,kitchen_counter_instance]=True
        close[kitchen_counter_instance,food_food]=True
    

behavior find_food_apple_2043_around_kitchen_counter_128(food_apple:item):
    goal: not unknown(food_apple)
    body:
        assert is_food_apple(food_apple)
        bind kitchen_counter_instance:item where:
            is_kitchen_counter(kitchen_counter_instance) and id[kitchen_counter_instance]==128
        achieve close_char(char,kitchen_counter_instance)
        if can_open(kitchen_counter_instance):
            achieve_once open(kitchen_counter_instance)
            exp(food_apple,kitchen_counter_instance)
        else:
            exp(food_apple,kitchen_counter_instance)
    eff:
        unknown[food_apple]=False
        close[food_apple,kitchen_counter_instance]=True
        close[kitchen_counter_instance,food_apple]=True
    

behavior find_food_onion_2026_around_kitchen_counter_128(food_onion:item):
    goal: not unknown(food_onion)
    body:
        assert is_food_onion(food_onion)
        bind kitchen_counter_instance:item where:
            is_kitchen_counter(kitchen_counter_instance) and id[kitchen_counter_instance]==128
        achieve close_char(char,kitchen_counter_instance)
        if can_open(kitchen_counter_instance):
            achieve_once open(kitchen_counter_instance)
            exp(food_onion,kitchen_counter_instance)
        else:
            exp(food_onion,kitchen_counter_instance)
    eff:
        unknown[food_onion]=False
        close[food_onion,kitchen_counter_instance]=True
        close[kitchen_counter_instance,food_onion]=True
    

behavior find_food_orange_2008_around_kitchen_counter_128(food_orange:item):
    goal: not unknown(food_orange)
    body:
        assert is_food_orange(food_orange)
        bind kitchen_counter_instance:item where:
            is_kitchen_counter(kitchen_counter_instance) and id[kitchen_counter_instance]==128
        achieve close_char(char,kitchen_counter_instance)
        if can_open(kitchen_counter_instance):
            achieve_once open(kitchen_counter_instance)
            exp(food_orange,kitchen_counter_instance)
        else:
            exp(food_orange,kitchen_counter_instance)
    eff:
        unknown[food_orange]=False
        close[food_orange,kitchen_counter_instance]=True
        close[kitchen_counter_instance,food_orange]=True
    

behavior find_food_fruit_2056_around_kitchen_counter_128(food_fruit:item):
    goal: not unknown(food_fruit)
    body:
        assert is_food_fruit(food_fruit)
        bind kitchen_counter_instance:item where:
            is_kitchen_counter(kitchen_counter_instance) and id[kitchen_counter_instance]==128
        achieve close_char(char,kitchen_counter_instance)
        if can_open(kitchen_counter_instance):
            achieve_once open(kitchen_counter_instance)
            exp(food_fruit,kitchen_counter_instance)
        else:
            exp(food_fruit,kitchen_counter_instance)
    eff:
        unknown[food_fruit]=False
        close[food_fruit,kitchen_counter_instance]=True
        close[kitchen_counter_instance,food_fruit]=True
    

behavior find_food_banana_2045_around_table_193(food_banana:item):
    goal: not unknown(food_banana)
    body:
        assert is_food_banana(food_banana)
        bind table_instance:item where:
            is_table(table_instance) and id[table_instance]==193
        achieve close_char(char,table_instance)
        if can_open(table_instance):
            achieve_once open(table_instance)
            exp(food_banana,table_instance)
        else:
            exp(food_banana,table_instance)
    eff:
        unknown[food_banana]=False
        close[food_banana,table_instance]=True
        close[table_instance,food_banana]=True
    

#goal_representation
 
def is_vegetable_found(vegetable: item):
    # Determine if the vegetable has been located or observed
    symbol found=visited(vegetable)
    return found

behavior __goal__():
    body:
        foreach vegetable: item:
            if is_food_vegetable(vegetable) and not is_vegetable_found(vegetable):
                # Check all unvisited items categorized as vegetables
                observe(vegetable, "Locate the vegetable for washing")
                # Observe each vegetable to locate them
        
        foreach vegetable: item:
            if is_food_vegetable(vegetable) and is_vegetable_found(vegetable):
                bind sink: item where:
                    is_sink(sink)
                achieve close_char(char, vegetable)
                is_cleaning_solution(vegetable, sink)
                # Ensure each found vegetable is washed in the sink

#goal_representation_end

##############################
Inner TransformationError Debug
Error trying to process rule "behavior_definition":

Number of arguments does not match the number of types: 2 vs 1. Args: (VariableExpression<V::vegetable>, VariableExpression<V::sink>), Types: (ObjectType<item>,)
##############################
