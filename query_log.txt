System: You are an intelligent task planner with expert knowledge in task breakdown, goal evaluation, and human-robot collaboration. Your role is to evaluate whether a given task goal needs to be split into subgoals or if it can be directly pursued. You consider the overall goal of the task, previously completed subgoals, and any human guidance provided. Based on your evaluation, you either generate a set of subgoals that help the task progress more efficiently or output the next most appropriate goal. Your output should always be logically sound, concise, and relevant to the task at hand.
Content: 
## Principle ##
When the task is not very complex, reduce the number of subtasks as much as possible. And avoid setting sub-tasks such as gathering required items. A good task breakdown usually has one and only one clear and specific goal within a single sub-task.

## Notes ##
- It is strictly prohibited to use a single subgoal solely for gathering related items, as this usually leads to ineffective task decomposition. In other words, please avoid designing subtasks like "Gather xxx" or "Collect xxx." or "Combine xxx". If you must gather certain items together, be sure to specify a clear "destination," meaning where exactly they should be collected, or a better approach is to integrate them into other subgoals.
- This task occurs in a complex household environment, where items like tables, drawers, and sinks may have multiple instances. However, not all instances are always relevant to the task. For example, when you want to wash the clothes in a basket, you need to understand that not every basket contains clothes—you need to find the one that does.

## Examples ##
Note: Chain of thought should not be included in the output.
Example 1:
Overall Goal: Clean up the food on the table.
Completed things: No subgoals have been completed yet.
Human Guidance: No human guidance has been provided yet.

Chain of thought: Your Overall Goal is to clean up the food on the table, but there are usually more than one table in the scene, so you need to identify the table with the food. Then, different types of food will have different suitable storage locations, but at this point, you don't know exactly what kinds of food are on the table, so you need to identify the types of food first. Finally, once you've confirmed the types of food on the table, you need to clean them up and store them in the appropriate places

Output:
1. Find a table with food on it.
2. Put the food in the appropriate storage locations.

Output Analysis:
The key to the first step is to find the table with the food on it, not to find a table and then check if there is food on it. If there is no food on the table, the task cannot proceed to the next step.

Example 2:
Overall Goal: Prepare a plate of salad.
Completed things: No subgoals have been completed yet.
Human Guidance: No human guidance has been provided yet.

Chain of thought: To make a salad, you typically need to start by finding and washing the ingredients. Next, you need to prepare these ingredients; for example, if you're adding kiwi, you'll usually need to cut it. Finally, you need to place all the prepared ingredients into a plate.

Output:
1. Wash the ingredients for the salad, and for those that need to be cut, cut them accordingly.
2. Put all the prepared ingredients into a plate.

Example 3:
Overall Goal: Wash the plates and cups in the sink using the dishwasher. Then put them on the table in kitchen.
Completed things: - Find the plates and cups. - Wash the plates and cups.
Human Guidance: There are more than one table in the scene, so please put it on the table in the kitchen.

Chain of thought: It is known that the plates and cups have already been identified and cleaned. Referring to the overall goal, the next step is simply to place the plates and cups on the table in the kitchen. This process is not complicated, and there is no need to further divide the task at this point. Therefore, you can directly proceed with the next step, but be sure to follow the human instructions: the next goal must emphasize placing the items on the kitchen table, not any other table.

Output:
No decomposition: Put the plates and cups on the table in the kitchen.

Example 4:
Overall Goal: Turn on the microwave.
Completed things: No subgoals have been completed yet.
Human Guidance: No human guidance has been provided yet.

Chain of thought: This task is relatively simple. You can directly find the microwave and turn it on.

Output:
No decomposition: Turn on the microwave.

Example 5:
Overall Goal: Make some potato chicken noodle, put it in a bowl, and store it in the fridge.
Completed things: - Clean the potato and the chicken.
Human Guidance: To cook potato chicken noodle, you need to boil noodles, chicken, and potato one by one.

Chain of thought: The overall goal is to make potato chicken noodle, put it in a bowl, and store it in the fridge. And the ingredients have been cleaned. The next step is to cook the potato chicken noodle. The human guidance provides the specific steps to cook the potato chicken noodle, so you can directly proceed with the next step. After cooking, you can put the potato chicken noodle in a bowl and store it in the fridge.

Output:
1. Boil the noodles, chicken, and potato one by one.
2. Put the potato chicken noodle in a bowl.
3. Store the bowl in the fridge.

Example 5:
Overall Goal: Roast Chicken.
Completed things: - Clean the chicken.
Human Guidance: I don't want to add any seasoning. Just put it into a oven to roast.

Chain of thought: The human guidance indicates that the chicken should be roasted without any seasoning. The chicken has been cleaned, so the next step is to put the chicken into the oven to roast. This task is relatively simple and does not require further decomposition.

Output:
No decomposition: Put the chicken into the oven to roast.

## Output Format ##
When you think the next task is simple and doesn't require decomposition, make sure your output starts with the keyword "No decomposition:", followed by the next goal on the same line. When the next goal is complex and requires decomposition, output the following subgoals in separate lines with numbered steps. Try to use the simplest and most direct language. Please do not include any explanations or special symbols in your output.

## Current task informatioin ##
Overall Goal: slice some chicken
Completed things: No subgoals have been completed yet.
Human Guidance: No human guidance has been provided yet.


Response:
No decomposition: Slice the chicken.

Tokens: 1373
################################################################################

System: I have a goal described in natural language, and I need it converted into a structured format.
Content: 
## Task Description: 
I have a long horizon task: slice some chicken To approach this task effectively, I’ve divided it into several sub-tasks. The goal of the current sub-task is: Slice the chicken. The sub-tasks I have already completed include: None, it is the first sub-task. Additionally, I’ve gathered the following information to assist in completing this task: None.

## Instructions: 
Focus on the current sub-task's goal. Please analyze this goal and the additional information provided. Referring to the example I’ve shared, transform my sub-task goal into a formal representation that conforms to the specified syntax. Your output should include multiple behaviors, where each behavior’s body outlines intermediate states, intermediate relationships, final states, and final relationships necessary to achieve the goal. There is no need to define the actions required to reach the sub-task goal. Once you specify the intermediate and final states and relationships, my algorithm will independently plan a feasible sequence of actions.

## Precautions:
- Ensure that the states, relationships, properties, and keywords used do not exceed the scope I provided. (Available states, relationships, properties, and keywords are listed below.)
- If you invoke a function, ensure it’s properly defined, and include any necessary parameters when calling it.
- When using the keyword achieve, it must only be followed by terms defined under ## Available States or ## Available Relationships. It is strictly prohibited to follow achieve with properties, custom symbols, or functions.
- The behavior __goal__(): is required and functions similarly to the main function in Python; it should typically be placed at the end of your output without any parameters.

## Available States:
Please note: The text following each hash symbol (#) is a comment and should not be included in the current sub-task goal representation. 
- is_on(x: item) # The item is turned on.
- is_off(x: item) # The item is turned off.
- plugged(x: item) # The item is plugged in.
- unplugged(x: item) # The item is unplugged.
- open(x: item) # The item is open.
- closed(x: item) # The item is closed.
- dirty(x: item) # The item is dirty.
- clean(x: item) # The item is clean.
- has_water(x: item) # The item has water inside or on it.
- cut(x: item) # The item is cut.
- inhand(x: item) # A item is grasped by a character. Only use it when an item needs to be continuously held in your hand.
- has_a_free_hand(x: character) # The character has a free hand.
- visited(x: item) # The character has observed the item
Important Note: The inhand(x) state is unique. If you intend to use inhand(x), you must implement it using the achieve_once keyword. At the same time, please note that you can take at most two items. Having too many items in hand will result in no solution.

## Available Relationships:
Please note: The text following each hash symbol (#) is a comment and should not be included in the current sub-task goal representation. 
- on(x: item, y: item) # item x is on top of item y
- inside(x: item, y: item) # item x is inside item y, and y should be a room or a container
- inside_char(x: character, y: item) # character is inside item y (Character is you self. Any other animal like cat is an item)
- close(x: item, y: item) # item x is close to item y
- close_char(x: character, y: item) # character is close to item y (Character is you self. Any other animal like cat is an item)
Important Usage Notes: In relationships with the '_char' suffix, the first parameter must always be a char. For example, 'inside' and 'inside_char', 'close' and 'close_char'.

## Available Properties:
Please note: The text following each hash symbol (#) is a comment and should not be included in the current sub-task goal representation.
- surfaces(x: item) #  Indicates that the item has a surface where things can be placed, such as a kitchen countertop or table.
- grabbable(x: item) # Indicates that the item can be grabbed by hand.
- hangable(x: item) # Indicates that the item can be hung on.
- drinkable(x: item) # Indicates that the item can be drunk.
- eatable(x: item) # Indicates that the item can be eaten.
- recipient(x: item) # Indicates that the item can receive something.
- cuttable(x: item) # Indicates that the item can be cut with a knife.
- pourable(x: item) # Indicates that the item can be poured into another container or onto other items.
- can_open(x: item) # Indicates that the item can be opened.
- has_switch(x: item) # Indicates that the item has a switch to turn it on or off.
- readable(x: item) # Indicates that the item can be read.
- lookable(x: item) # Indicates that the item can be looked at.
- containers(x: item) # Indicates that the item is a container.
- has_plug(x: item) # Indicates that the item has a plug.
- movable(x: item) # Indicates that the item can be moved.
- is_clothes(x: item) # Indicates that the item is clothing.
- is_food(x: item) # Indicates that the item is food.
Important Notes: "propertie" cannot be assigned a value nor can it be used after "achieve".; they can only return a boolean value as a predicate. For example, an apple can be grabbed, so grabbable(apple) will return true. Properties are typically used in if conditions.
Common Errors:
achieve can_open(door) # Incorrect. Properties cannot be used after achieve as they cannot have their values modified.
has_plug(lamp) = True # Incorrect. You cannot assign a value to a property, as they are immutable.

# Available Behaviors:
Please note: The text following each hash symbol (#) is a comment and should not be included in the current sub-task goal representation.
The following behaviors can be directly invoked in the current sub-task goal representation, with parameters passed in like function arguments.
- observe(obj:item,question:string) # observe is a special behavior used to inspect an object. You can specify the purpose of your inspection with a string. By calling observe, you can learn about the state of an object as well as its relationship with surrounding objects. After observing an item, it will be marked as visited. Note that the second parameter of observe is a string and must be enclosed in double quotes("").
- wash(obj:item) # Wash an item by hand.
- scrub(obj:item) # Scrub an item.
- wipe(obj:item) # Wipe an item.
- squeeze(obj:item) # Squeeze an item.
- rinse(obj:item) # Rinse an item.
- move(obj:item) # Move an item.
- pull(obj:item) # Pull an item.
- push(obj:item) # Push an item.
- type(obj:item) # Type on an item.
- touch(obj:item) # Touch an item.
- read(obj:item) # Read an item.
Important Note: Ensure that all parameters are properly defined before using them in the behaviors.

## Available Category Determination:
- is_mat(x: item)
- is_drawing(x: item)
- is_food_bread(x: item)
- is_bedroom(x: item)
- is_couch(x: item)
- is_chair(x: item)
- is_stovefan(x: item)
- is_clothes_scarf(x: item)
- is_cpuscreen(x: item)
- is_coffee_filter(x: item)
- is_oven(x: item)
- is_cd_player(x: item)
- is_food_vegetable(x: item)
- is_food_hamburger(x: item)
- is_mouse(x: item)
- is_soap(x: item)
- is_clothes_dress(x: item)
- is_dvd_player(x: item)
- is_food_donut(x: item)
- is_ceilinglamp(x: item)
- is_book(x: item)
- is_cup(x: item)
- is_food_rice(x: item)
- is_cupboard(x: item)
- is_food_kiwi(x: item)
- is_food_cereal(x: item)
- is_food_snack(x: item)
- is_mousepad(x: item)
- is_ironing_board(x: item)
- is_food_pizza(x: item)
- is_fridge(x: item)
- is_faucet(x: item)
- is_clothes_pants(x: item)
- is_towel(x: item)
- is_orchid(x: item)
- is_food_fish(x: item)
- is_nightstand(x: item)
- is_food_steak(x: item)
- is_toaster(x: item)
- is_door(x: item)
- is_dining_room(x: item)
- is_curtain(x: item)
- is_table(x: item)
- is_food_apple(x: item)
- is_bathroom(x: item)
- is_home_office(x: item)
- is_desk(x: item)
- is_tvstand(x: item)
- is_dishwasher(x: item)
- is_food_sugar(x: item)
- is_basket_for_clothes(x: item)
- is_bowl(x: item)
- is_dry_pasta(x: item)
- is_sauce(x: item)
- is_oil(x: item)
- is_kitchen_counter(x: item)
- is_clothes_hat(x: item)
- is_powersocket(x: item)
- is_knife(x: item)
- is_doorjamb(x: item)
- is_food_onion(x: item)
- is_bathtub(x: item)
- is_food_dessert(x: item)
- is_clothes_socks(x: item)
- is_food_chicken(x: item)
- is_clothes_jacket(x: item)
- is_closetdrawer(x: item)
- is_pillow(x: item)
- is_bench(x: item)
- is_bathroom_cabinet(x: item)
- is_food_ice_cream(x: item)
- is_vacuum_cleaner(x: item)
- is_cat(x: item)
- is_trashcan(x: item)
- is_bookshelf(x: item)
- is_shower(x: item)
- is_walllamp(x: item)
- is_spectacles(x: item)
- is_bathroom_counter(x: item)
- is_milk(x: item)
- is_clothes_underwear(x: item)
- is_ceiling(x: item)
- is_towel_rack(x: item)
- is_food_potato(x: item)
- is_toilet(x: item)
- is_clothes_shirt(x: item)
- is_cleaning_solution(x: item)
- is_iron(x: item)
- is_floor(x: item)
- is_food_carrot(x: item)
- is_fryingpan(x: item)
- is_bed(x: item)
- is_hairbrush(x: item)
- is_food_salt(x: item)
- is_clothes_gloves(x: item)
- is_keyboard(x: item)
- is_remote_control(x: item)
- is_microwave(x: item)
- is_dresser(x: item)
- is_food_oatmeal(x: item)
- is_pot(x: item)
- is_food_orange(x: item)
- is_coffee_table(x: item)
- is_food_food(x: item)
- is_fork(x: item)
- is_napkin(x: item)
- is_toilet_paper(x: item)
- is_food_egg(x: item)
- is_light(x: item)
- is_tray(x: item)
- is_sink(x: item)
- is_wall_clock(x: item)
- is_food_peanut_butter(x: item)
- is_photoframe(x: item)
- is_coffe_maker(x: item)
- is_food_jam(x: item)
- is_headset(x: item)
- is_clothes_skirt(x: item)
- is_wall(x: item)
- is_food_turkey(x: item)
- is_food_cheese(x: item)
- is_filing_cabinet(x: item)
- is_washing_machine(x: item)
- is_food_cake(x: item)
- is_window(x: item)
- is_computer(x: item)
- is_plate(x: item)
- is_wallshelf(x: item)
- is_television(x: item)
- is_food_fruit(x: item)
- is_cutting_board(x: item)
- is_detergent(x: item)
- is_phone(x: item)
- is_tablelamp(x: item)
- is_food_banana(x: item)
- is_food_lemon(x: item)
- is_hanger(x: item)
- is_food_bacon(x: item)
- is_stove(x: item)
- is_cd(x: item)
- is_food_noodles(x: item)
- is_pencil(x: item)

For any instance 'x', you can use 'is_y(x)' to determine if 'x' belongs to category 'y'. Categories cannot be operated upon directly; you can only assess the status and relationships of specific instances within a category. If you want to select an item instance that belongs to the category "box", you can use the following syntax:

bind b: item where:
    is_box(b)

Important Notes:
If the category you need is not in the available list, try to find a synonym or a similar category with a closely related function.
Examples:
- food -> is_food_food(): If 'is_food' is not available, but 'is_food_food' is, use the latter as they have similar meanings.
- soapy_water -> is_cleaning_solution(): If 'soapy_water' is not available, but 'cleaning_solution' is, use the latter as they are functionally similar.

## Syntax Rules and Keywords:
"char" is a constant instance representing a character (yourself) and we assume that other animals like cat is an item. The type "character" can only be used when defining an instance. Use "char" consistently when passing parameters, and use "character" when defining a variable and specifying its type.

Below are all the keywords you can use to convert information into a structured format. Please ensure that you do not use any keywords other than those listed here.

Keywords:
# bind
# Usage: Randomly select an item that satisfies the specified conditions and assign it to a variable. If no item meets the condition, the program will fail. Therefore, avoid setting overly strict conditions unless you are certain that a corresponding item exists. The condition is_x will always be satisfied as long as x is specified in Available Category Determination. However, exercise caution when adding additional conditions.To maintain consistency, try to use 'bind' primarily in the '__goal__' behavior and pass the retrieved instances as parameters to invoked behaviors. Avoid using 'bind' in other behaviors whenever possible.
Example:
bind x: item where:
    is_light(x)

Multiple Items Example: Ensure that subsequent items are not the same as those previously bound.
bind apple1: item where:
    is_apple(apple1)
bind apple2: item where:
    is_apple(apple2) and apple1!=apple2
bind apple3: item where:
    is_apple(apple3) and apple1!=apple3 and apple2!=apple3

# achieve
# Usage: Specifies the state or relationship that a behavior consistently aims to maintain from start to finish. Only states and relationships can follow 'achieve', not types, properties, or other immutable content. Do not call functions or behaviors after 'achieve'; instead, call functions directly without keywords. Note that 'achieve' cannot be used with the state 'inhand'. And note that 'achieve' must be followed by a single state or relationship, not a combination of states or relationships.
Examples: 
achieve is_on(light) # it is used to turn on the light.
achieve has_water(cup) # it is used to fill the cup with water.
achieve has_water(pot) # it is used to fill the pot with water.
achieve cut(apple) # it is used to cut the apple.
achieve on(apple, plate) # it is used to place the apple on the plate.
achieve inside(oil, pan) # it is used to add oil into the pan.

# achieve_once
# Usage: Specifies a temporary state or relationship that needs to be achieved only once, without maintaining it until the end of the behavior.
Example: achieve_once inhand(apple) #Please note that 'inhand' must be used with 'achieve_once.'

# foreach
# Usage: Iterates over all objects. Do not use 'where' in a 'foreach' statement. Additionally, do not nest one foreach inside another, as this will cause the program to fail.
Correct example:
foreach o: item:
    if can_open(o) and is_box(o):
        achieve closed(o)

Incorrect example:
foreach o: item where:
    if can_open(o) and is_box(o):
        achieve closed(o)

# behavior
# Usage: Defines a behavior rule. The keyword 'body' must appear in the behavior, and all parameters used in the 'goal' must be included in the behavior's parameters.

# goal
# Usage: Specifies the goal condition for a behavior. If you want to use the goal, please ensure that you include all the parameters used in the 'goal' in the behavior parameters.

# body
# Usage: Contains the sequence of intermediate states and relationships necessary to achieve the behavior’s goal.

# if-else
# Usage: Conditional statement for branching logic. Only simple first-order logic or combinations of first-order logic are allowed after if-else. Note that elif is not supported.
if condition:
    achieve has_water(a)
else:
    achieve clean(b)

# exists
# Usage: Checks if there is at least one object that meets the condition and returns a boolean value.
Template: exists obj_name: objtype : condition()
Example: exists item1: item : holds_lh(char, item1)

# symbol
# Usage: Defines a symbol and binds it to the output of an expression. You can only use the symbol in the following manner:
symbol has_cutting_board=exists item1:item: (is_cutting_board(item1))

# def
# Usage: Defines a function that can be used to check a condition. 

## Background Knowledge:
In general, you only know part of the information in a given scenario. For example, you might know that a certain piece of clothing is in a particular basket, but you might not know what is in a certain basket. Therefore, many times, you need to first perform a goal conversion based on what you already know. When you lack some information, you can observe and obtain the information you want by using obs(target_item, information).
For example, if you want to know if there are clothes in the basket_34, you can use:
bind basket: item where:
    is_basket(basket) and id[basket]==34
observe(basket,"Check is there any clothes in the basket")

If you want to know Is there any trash in the trash can in the dining room, you can use:

bind dining_room: item where:
    is_dining_room(dining_room)

bind trash_can: item where:
    is_trash_can(trash_can) and inside(trasn_can, dining_room) # Since you already know that the trash can is located in the dining room, you can include the condition inside(trash_can, dining_room). However, if the location of the trash can is unknown, this condition must be omitted.
observe(trash_can,"Check is there any trash in the trash can")

## Examples:
# Example-1-1:
Current sub-task goal: 1. Find a table with food.
The completed sub-tasks: None, it is the first sub-task.
Additional information: None.
Long-horizon task: Clean up the food on the table.
Chain of thought: Your current sub-task goal is to find a table with food on it, which is the first step towards completing the long-horizon task. According to the background knowledge, your first step should be to check if there is a known table with food on it. To do this, you need to determine whether there is food on a table. You can create a function called 'has_food_on_table(table:item)', which returns the result of the expression 'exists o: item : is_food(o) and on(o, table)'. This expression checks if there is an item classified as food that is on the table, according to your known information.
Next, you can use the expression 'exists table: item : is_table(table) and has_food_on_table(table)' to verify if there is a table with food on it in the known information. If such a table exists, there is no need to continue searching; you can immediately use 'achieve close_char(char, table)' to have the character approach the table with food.
However, if your known information does not confirm the presence of a table with food on it, you will need to inspect all unvisited items in the scene categorized as tables. To do this, you should call the 'observe' behavior to check each table. The first parameter of the 'observe' behavior should be the table you intend to inspect, and the second parameter should be the purpose of the inspection. Remember, the second parameter must be a string enclosed in double quotes ("").

Output:
def has_food_on_table(table:item):
    # Function to check if there is food on the specified table.
    symbol has_food=exists o: item : (is_food(o) and on(o, table))
    return has_food

behavior __goal__():
    body:
        if exists table: item : is_table(table) and has_food_on_table(table):
            # Check if there is a table with food based on the available information.
            bind table: item where:
                is_table(table) and has_food_on_table(table) # The condition has_food_on_table can only be used when you are certain that there is food on the table. In this case, you can be confident because you have already verified it with an if condition.
            # Select a table that has food on it.
            achieve close_char(char, table) 
            # Move the character closer to the table with food.

        else: 
           # If no table with food is found, initiate exploration to locate one.
            foreach table: item:
                if is_table(table) and not visited(table):
                    # Check all unvisited tables.
                    observe(table,"Check is there any food on the table")
                    # Observe whether each table has any food.
            
# Example-1-2:
Current sub-task goal: 2. Put the food in the appropriate storage locations.
The completed sub-tasks: 1. Find a table with food.
Additional information: 
1. There is no food on table 107. 
2. No food is find on the table 355, please see other tables.
3. food_peanut_butter_2008 and food_kiwi_2012 are on the table_226.
Long-horizon task: Clean up the food on the table.

Chain of thought: You have already find the table with food. Now, your current sub-task goal is to store the food on the table in the appropriate location. According to the additional information, there is no food on table_107 and table_355. However, table_226 has food_peanut_butter and food_kiwi.You can use the 'bind' keyword along with the condition 'is_table(table) and id[table] == 226' to obtain the table with the ID 226. You can also use the 'bind' keyword with the condition 'is_food_peanut_butter(food_peanut_butter)' to obtain the peanut butter. And use 'bind' keyword with the condition 'is_food_kiwi(food_kiwi)' to obtain the kiwi. Since the sub-task goal and additional information do not specify where exactly to store the food, you need to use common sense to make a decision based on the items present in the scene. Based on common sense, both food_peanut_butter and food_kiwi may require refrigeration, and since there is a fridge available in the scene, the goal is to store them in the fridge. Although it is not explicitly stated, it is common sense to ensure that the fridge door is closed after storing food inside. Therefore, you can use achieve closed(fridge) to perform the action of closing the fridge door.

Output:
behavior store_in_fridge(food:item, fridge:item):
    body:
        achieve inside(food, fridge)
        # Place the food item inside the fridge.

behavior close_the_fridge_door(fridge:item):
    body:
        achieve closed(fridge)
        # Close the fridge door.

behavior __goal__():
    body:
        bind table: item where:
            is_table(table) and id[table]==226
        # Select table with ID 226.

        bind food_peanut_butter: item where:
            is_food_peanut_butter(food_peanut_butter)
        # Select peanut butter.

        bind food_kiwi: item where:
            is_food_kiwi(food_kiwi)
        # Select kiwi on the table.
        
        bind fridge: item where:
            is_fridge(fridge)
        store_in_fridge(food_peanut_butter, fridge)
        store_in_fridge(food_kiwi, fridge)
        close_the_fridge_door(fridge)

# Example-1-3:
Current sub-task goal: 2. Put the food in the appropriate storage locations.
The completed sub-tasks: 1. Find a table with food.
Additional information: 
1. There is no food on table 107. 
2. No food is find on the table 355, please see other tables.
3. food_peanut_butter_2008 and food_kiwi_2012 are on the table_226.
4. The peanut butter is expired, so I want to throw it away. I want to cut the kiwi and then store it in the fridge.
Long-horizon task: Clean up the food on the table.

Chain of thought: According to Additional information 4, you need to discard the peanut butter. Observing that there is an "is_trashcan" in the Available Category, you can infer that there is a trashcan in the scene, and the expired peanut butter can be thrown into the trashcan. Additional information 4 also requires that the kiwi be cut, and then stored in the fridge. You need to use "achieve cut(food_kiwi)" to cut the kiwi. After that, you can "achieve inside(food_kiwi, fridge)" to store the kiwi in the fridge. To ensure the completeness of the task, you also need to use "achieve closed(fridge)" to make sure the fridge door is closed at the end by "achieve closed(fridge)".

Output:
behavior throw_in_trash(food:item, trashcan:item): 
# Define the behavior to throw food into the trash can
    body:
        achieve inside(food, trashcan)
        
behavior cut_food(food:item):
    body:
        achieve cut(food)

behavior store_in_fridge(food:item, fridge:item):
    body:
        achieve inside(food, fridge)

behavior close_the_fridge_door(fridge:item):
    body:
        achieve closed(fridge)

behavior __goal__():
    body:
        bind table: item where:
            is_table(table) and id[table]==226
        # Select table with ID 226.
        bind food_peanut_butter: item where:
            is_food_peanut_butter(food_peanut_butter)
        # Select peanut butter on the table.
        bind food_kiwi: item where:
            is_food_kiwi(food_kiwi)
        # Select kiwi on the table.
        bind trashcan: item where:
            is_trashcan(trashcan)
        # Select a trash can.
        bind fridge: item where:
            is_fridge(fridge)
        # Select a fridge.
        throw_in_trash(food_peanut_butter, trashcan)
        cut_food(food_kiwi)
        store_in_fridge(food_kiwi, fridge)
        close_the_fridge_door(fridge)
          
# Example-2-1:
Current sub-task goal: 1. Find the sink with plates and cups.
The completed sub-tasks: None, it is the first sub-task.
Additional information: None.
Long-horizon task: Wash the plates and cups in the sink using the dishwasher. Then put them on the table in kitchen.

Chain of thought: Your current sub-task goal is to find the sink with plates and cups, which is the first step toward completing the long-horizon task: "Wash the plates and cups in the sink using the dishwasher. Then put them on the table in the kitchen."
To achieve this, you first need to determine whether there are plates or cups in the sink. You can design a function called 'has_plate_or_cup_in_sink(sink:item)' that checks for this. The function should return the result of the expression 'exists o: item : (is_plate(o) or is_cup(o)) and inside(o, sink)', which verifies if there is an item that is either a plate or a cup and is located inside the sink in your known information.
Next, you can use 'exists sink: item : is_sink(sink) and has_plate_or_cup_in_sink(sink)' to check if there is a sink with plates or cups in it within the known information. If such a sink is found, there's no need to search further; you can immediately use 'achieve close_char(char, sink)' to have the character approach the sink containing the plates or cups.
However, if your known information does not confirm the presence of a sink with plates or cups, you will need to check all unvisited items categorized as sinks in the scene. For this, you should call the 'observe' behavior to inspect each sink. The first parameter of the 'observe' behavior should be the sink you intend to check, and the second parameter should be the purpose of the inspection. Remember, the second parameter must be a string enclosed in double quotes ("").

Output:
def has_plate_or_cup_in_sink(sink:item):
    # Function to check if there are plates or cups in a specified sink.
    symbol has_plate_or_cup=exists o: item : ((is_plate(o) or is_cup(o)) and inside(o, sink))
    return has_plate_or_cup

behavior __goal__():
    body:
        if exists sink: item : is_sink(sink) and has_plate_or_cup_in_sink(sink):
            # If we have already found the sink with plates or cups, we can directly approach it
            bind sink: item where:
                is_sink(sink) and has_plate_or_cup_in_sink(sink)
            achieve close_char(char, sink)

        else:
            # Check all sinks in the scene that have not been visited
            foreach sink: item:
                if is_sink(sink) and not visited(sink):
                    observe(sink,"Check is there any plate or cup in the sink")

# Example-2-2:
Current sub-task goal: 2. Wash the plates and cups using the dishwasher.
The completed sub-tasks: 1. Find the sink with plates and cups.
Additional information: 
1. sink_42 is in the bathroom, and no plates or cups are found in it.
2. sink_231 is in the kitchen, and there are plates and cups in it.
Long-horizon task: Wash the plates and cups in the sink using the dishwasher. Then put them on the table in kitchen.

Chain of thought:
According to additional information, sink_42 does not contain plates or cups, while sink_231 does contain plates or cups. Now you have found the sink that contains plates or cups. The current sub-task's goal is "Wash the plates and cups using the dishwasher." Although it doesn't explicitly state that the plates and cups in the sink need to be cleaned, considering the objective of the long-horizon task, the actual goal of the current sub-task should be to clean the plates and cups in the sink. To clean the plates and cups in the sink using the dishwasher, you first need to load them into the dishwasher. Since it is unclear how many plates and cups are in the sink, the foreach keyword is used with the condition if is_plate(o) or is_cup(o) and inside(o, sink) to place all items that are plates or cups from the sink into the dishwasher. After that, you can execute achieve closed(dishwasher) and achieve is_on(dishwasher) sequentially to start the dishwasher.

Output:
behavior load_dishwasher(o:item, dishwasher:item):
    body:
        achieve inside(o, dishwasher)
        # Place the item inside the dishwasher.

behavior start_dishwasher(dishwasher:item):
    body:
        achieve closed(dishwasher) # Close the dishwasher door.
        achieve is_on(dishwasher) # Turn on the dishwasher.

behavior __goal__():
    body:
        bind sink: item where:
            is_sink(sink) and id[sink]==231
        # Select sink with ID 231.
        bind dishwasher: item where:
            is_dishwasher(dishwasher)
        # Select a dishwasher.
        foreach o: item:
        # Load all plates and cups from the sink into the dishwasher.
            if is_plate(o) or is_cup(o) and inside(o, sink):
                load_dishwasher(o, dishwasher)
        start_dishwasher(dishwasher) # Start the dishwasher.

# Example-2-3:
Current sub-task goal: 3. Put the plates and cups on the table in the kitchen.
The completed sub-tasks: 1. Find the sink with plates and cups. 2. Wash the plates and cups using the dishwasher.
Additional information: 
1. plate_1000, plate_1001, cup_1002, cup_1003 is cleaned by dishwasher_2000.
Long-horizon task: Wash the plates and cups in the sink using the dishwasher. Then put them on the table in kitchen.

Chain of thought:
According to "The completed sub-tasks" and "Additional information," the plates and cups that need to be placed on the table have already been cleaned in a dishwasher, and they are currently in a dishwasher with an ID of 2000. The current sub-task requires you to place the plates and cups on a table located in the kitchen. There may be more than one table in the scene, so you need to design a function 'in_kitchen(table: item)' that returns the value of the expression 'exists room: item : is_kitchen(room) and inside(table, room)', which checks whether the given table is inside a kitchen. Next, you need to design a 'put_on_table' behavior to place the plates or cups on the table. To determine which table to use, you should apply 'put_on_table' to all the plates or cups that were originally in the dishwasher, placing them on the table. Finally, to ensure the dishwasher is properly reset, you can design a 'close_the_dishwasher' behavior to turn off and close the dishwasher.

Output:
def in_kitchen(table:item):
    # Function to check if a table is in the kitchen.
    symbol in_kitchen=exists room: item : (is_kitchen(room) and inside(table, room))
    return in_kitchen

def has_plates_or_cups_inside(dishwasher:item):
    # Function to check if there are plates or cups inside the dishwasher.
    symbol has_plates_or_cups=exists o: item : ((is_plate(o) or is_cup(o)) and inside(o, dishwasher))
    return has_plates_or_cups

behavior put_on_table(o:item, table:item):
    body:
        achieve on(o, table) # Place the item on the table.

behavior close_the_dishwasher(dishwasher:item):
    body:
        achieve is_off(dishwasher) # Turn off the dishwasher.
        achieve closed(dishwasher) # Close the dishwasher door.

behavior __goal__():
    body:
        bind table: item where:
            is_table(table) and in_kitchen(table)
        # Select a table in the kitchen.
        bind dishwasher: item where:
            is_dishwasher(dishwasher) and id[dishwasher]==2000
        # Select the dishwasher with ID 2000.
        foreach o: item:
        # Place all plates and cups originally in the dishwasher on the table.
            if is_plate(o) or is_cup(o) and inside(o, dishwasher):
                put_on_table(o, table)
        close_the_dishwasher(dishwasher) # Reset the dishwasher.

#Guidance-1:
A common mistake is ignoring the duration of "achieve." The duration of "achieve" persists until the current action is completed. If you specify two mutually exclusive states in a behavior using "achieve," it will result in a program error.

Here is some typical errors:
- error example:
behavior put_apple_on_table(apple:item,table:item):
    body:
        achieve inhand(apple)
        achieve on(apple,table)

Error Analysis: In this example, if you use achieve inhand(apple), then the apple must be keep inhand until the end of this behavior. Then you use achieve on(apple,table), which means you put the apple on the table. Now the apple should be both remain in hand and be placed on the table, which is impossible to achieve. The solution to this problem is to remove the unnecessary step of achieving inhand(apple), as the program will automatically determine how to achieve on(apple,table). In fact, unless you need to hold an item to complete a specific task (such as cutting vegetables with a knife or wiping a window with a cloth), please avoid using the "inhand" state in other situations.

A correct output for this example is:
behavior put_apple_on_table(apple:item,table:item):
    body:
        achieve on(apple,table)

# Guidance-2:
The following example demonstrates the difference between using foreach and bind.

Please note that bind requires the use of the "where keyword", while foreach must not use the "where" keyword under any circumstances.  
eg:
foreach c: item:
    if is_clothes(c) and inside(c,basket):
        achieve inside(c, washing_machine)

bind basket: item where:
    is_basket_for_clothes(basket)

You can see that the foreach statement is used without "where", while the bind statement needs to include "where".

# Guidance-3:
In some cases, there may be multiple instances of the same object type within a scene. Simply using 'is_category()' to constrain the object type might be insufficient for selecting a specific instance. To retrieve the desired object more precisely, there are generally two methods. 
1. Using the ID: If you know the instance's unique ID, you can directly reference it, for example:

bind dishwasher: item where:
    is_dishwasher(dishwasher) and id[dishwasher] == 2000.

2. Adding positional relationships: You can specify spatial relationships between instances, for example: 

bind table: item where:
    is_table(table) and inside(table, kitchen).

In more complex scenarios, you can follow the approach in Example 2-3 by designing a function that adds constraints to the bind operation, allowing you to accurately retrieve the target instance.
Example:
def in_kitchen(table:item):
    symbol in_kitchen=exists room: item : (is_kitchen(room) and inside(table, room))
    return in_kitchen
    ......
bind table: item where:
    is_table(table) and in_kitchen(table)

You can also use attributes, states, and other information to further refine your constraints for the bind operation. However, it is crucial to ensure that an object satisfying all conditions exists. If you add more conditions to the bind statement but no object meets all of them, the operation will fail. Therefore, be mindful of how constraints interact to avoid retrieval errors.

# Guidance-4:
The observe(obj:item, question:string) is a powerful but resource-intensive behavior. It allows you to examine an object based on observation, during which you need to specify what information you wish to obtain from the object. Due to the high cost of using observe, the quality of your questions is crucial for improving execution efficiency. Generally speaking, information such as the type of object or its state can be obtained by referring to the methods provided in 'Available Category Determination' and 'Available States', so you usually don't need to invoke the observe behavior for these details. Some situations where observe behavior is necessary include when you want to check what items are inside or on the item you observe. For example, if you want to see what's inside the oven, you can use 'observe(oven, "What's inside the oven?")', or if you want to check what's on the table, you can use 'observe(table, "check items on the table")'. Also, feel free to ask more questions in the observe behavior to get more detailed information. For example, If you want to check what's inside the oven and whether it's on the kitchen counter, you can use 'observe(oven, "What's inside the oven? Is it on the kitchen counter?")'.

# Guidance-5:
Try to avoid using the 'inhand(x:item)' state. In most cases, the program will automatically manage the 'inhand' operations. If you define 'inhand' manually, it can easily lead to a situation where the agent is holding too many items, causing the program to crash. There is generally only one situation where you need to declare the 'inhand' operation: when you have to hold certain items all the time to complete a specific task. For example, when cleaning a mirror with a towel, you need to use 'achieve_once inhand(towel)'. Other than this, please avoid defining the 'inhand' state. In some cases, the task information may not clearly specify where certain items should be placed, such as in "gathering the food." In these cases, use your common sense to place the food in an appropriate location, like achieve 'on(food, kitchen_counter)', to avoid the issue of holding too many items. If possible, ensure that the agent's hands are empty after each sub-task is completed.

# Guidance-6:
You can assume that all actions you execute are successful. Additionally, you do not need to worry about object size, as a properly sized object will always be found automatically.



## Output Requirements:
You need to think step by step to give resonable output. However, you can only output content similar to the 'Output' in the 'Example'. Do not include any explanation or any other symbols.


Response:
```python
behavior __goal__():
    body:
        bind chicken: item where:
            is_food_chicken(chicken)
        # Select the chicken item.
        
        bind knife: item where:
            is_knife(knife)
        # Select the knife.

        symbol has_cutting_board=exists board: item : (is_cutting_board(board))
        if not has_cutting_board:
            # If there is no cutting board, check all unvisited items to find one.
            foreach board: item:
                if is_cutting_board(board) and not visited(board):
                    achieve close_char(char, board)
                    break

        if has_cutting_board:
            bind board: item where:
                is_cutting_board(board)
            # Select the cutting board.
            achieve on(chicken, board)
            # Place the chicken on the cutting board.
            achieve close_char(char, board)
            # Move close to the cutting board.
        
        achieve_once inhand(knife)
        # Take the knife in hand for cutting.
        
        achieve cut(chicken)
        # Cut the chicken.
```


Tokens: 9298
################################################################################

System: You are an assistant robot with excellent common sense. Now, I need your help to select the items to search for based on the current task and output a list of item serial numbers.
Content: 
The goal is: Slice the chicken..
The additional information is: None
My goal representation is:  
behavior __goal__():
    body:
        bind chicken: item where:
            is_food_chicken(chicken)
        # Select the chicken item
        
        bind knife: item where:
            is_knife(knife)
        # Select the knife

        symbol has_cutting_board=exists board: item : (is_cutting_board(board))
        if not has_cutting_board:
            # If there is no cutting board, check all unvisited items to find one
            foreach board: item:
                if is_cutting_board(board) and not visited(board):
                    achieve close_char(char, board)
                    break

        if has_cutting_board:
            bind board: item where:
                is_cutting_board(board)
            # Select the cutting board
            achieve on(chicken, board)
            # Place the chicken on the cutting board
            achieve close_char(char, board)
            # Move close to the cutting board
        
        achieve_once inhand(knife)
        # Take the knife in hand for cutting
        
        achieve cut(chicken)
        # Cut the chicken



The unknown categories are: 
0.clothes_pants
1.food_steak
2.clothes_jacket
3.mat
4.knife
5.book
6.cd_player
7.food_ice_cream
8.dvd_player
9.cleaning_solution
10.food_fish
11.vacuum_cleaner
12.plate
13.food_oatmeal
14.hanger
15.pillow
16.mouse
17.food_onion
18.food_cereal
19.napkin
20.food_vegetable
21.tray
22.chair
23.food_pizza
24.food_rice
25.detergent
26.soap
27.sauce
28.clothes_gloves
29.cd
30.food_jam
31.food_carrot
32.food_orange
33.clothes_shirt
34.food_food
35.towel
36.bowl
37.food_apple
38.food_dessert
39.food_bacon
40.cat
41.wall_clock
42.food_kiwi
43.clothes_underwear
44.food_fruit
45.food_sugar
46.clothes_socks
47.food_hamburger
48.keyboard
49.headset
50.fork
51.towel_rack
52.remote_control
53.clothes_hat
54.dry_pasta
55.food_noodles
56.food_salt
57.food_chicken
58.cup
59.food_banana
60.coffee_filter
61.toilet_paper
62.spectacles
63.food_cake
64.food_peanut_butter
65.clothes_scarf
66.food_donut
67.pencil
68.food_lemon
69.food_potato
70.oil
71.hairbrush
72.food_snack
73.pot
74.drawing
75.food_egg
76.milk
77.clothes_skirt
78.clothes_dress
79.fryingpan
80.phone
81.food_turkey
82.food_cheese
83.food_bread
84.iron

## Task Instructions:
I have a goal that needs to be accomplished, and I have provided some additional information to support this goal. To achieve the goal, I have proposed a goal representation. By parsing this goal representation, I can obtain the sequence of actions needed to complete the goal. Currently, there are some objects in the environment whose locations are unknown to me. I need you to use common sense, based on my goal, to help me determine which of these objects might be relevant to my task, and then help me select these objects and return the corresponding object numbers.

## Output Format:
You only need to output a list of item numbers in the form of: [a,b,c,...]. Please do not provide any explanations or descriptions.

## Example:
when the goal is: Cut a tomato and put it in the bowl.
The additional information is: The tomato is in the fridge.
The goal representation is:
behavior find_tomato(fridge:item, tomat:item):
    body:
        achieve_once open(fridge)
        achieve inhand(tomato)
        achieve_once closed(fridge)

behavior cut_tomato(tomato:item):
    body:
        achieve cut(tomato)

behavior put_tomato_in_bowl(tomato:item, bowl:item):
    body:
        achieve inside(tomato, bowl)
    
behavior __goal__():
    body:
        bind tomato:item where:
            is_tomato(tomato)
        bind fridge:item where:
            is_fridge(fridge)
        bind bowl:item where:
            is_bowl(bowl)
        find_tomato(fridge, tomato)
        cut_tomato(tomato)
        put_tomato_in_bowl(tomato, bowl)
        
The unknown categories are:
0. bread
1. onion
2. bacon
3. faucet
4. chair
5. stove
6. knife
7. spatula
8. sugar
9. countertop
10. water
11. oil
12. salt
13. pepper
14. curtain
15. book
16. tomato
17. egg
18. pan
19. bowl

Your output should be: [6,16,19]

Example Analysis:
In the goal, additional information, and goal representation, the three items tomato, bowl, and fridge are mentioned. However, note that in the unknown categories, only tomato and bowl appear, which means fridge is a known item and therefore does not need to be selected. But pay special attention to the fact that the list of case outputs includes 6, which is a knife. Although this item is not explicitly mentioned in the goal, additional information, and goal representation, based on your common sense, you can infer that if you want to cut a tomato, you need a tool to cut the tomato, and a knife is a very likely tool. So, based on common sense, you also need to select this item. Additionally, please note that the output should only contain a list with numbers, and no extra information is needed. If you think no items need to be output, just output "None". But please boldly guess items that might be useful.


Response:
[4, 57]

Tokens: 1351
################################################################################

System: You are an assistant robot with excellent common sense. Now, I need your to tell me the most likely place that I can find the knife_2050.
Content: I will provide you with my task objectives and some additional information. Most of this information might be useless, but it could include some location data that may help you find my target item. So please refer to this information and make your own judgment. But remember, your output should only be an integer, and do not analyze or explain the content.
Your Goal is:Slice the chicken.
Additional Information:No additional information.
# Find knife_2050:
The possible locations are:
0. stove_2065
1. ceilinglamp_224
2. bed_105
3. bathroom_counter_41
4. closetdrawer_158
5. closetdrawer_154
6. trashcan_99
7. closetdrawer_380
8. light_169
9. wallshelf_35
10. tablelamp_98
11. curtain_180
12. closetdrawer_118
13. washing_machine_2007
14. orchid_178
15. bench_227
16. basket_for_clothes_2006
17. shower_36
18. desk_104
19. bookshelf_233
20. curtain_181
21. closetdrawer_119
22. tablelamp_97
23. curtain_408
24. cupboard_229
25. powersocket_246
26. kitchen_counter_230
27. photoframe_185
28. wallshelf_235
29. toilet_37
30. computer_170
31. table_355
32. home_office_319
33. faucet_43
34. filing_cabinet_399
35. closetdrawer_148
36. closetdrawer_122
37. window_86
38. cutting_board_2051
39. orchid_244
40. stovefan_288
41. dresser_108
42. curtain_407
43. oven_295
44. couch_352
45. coffee_table_2068
46. window_348
47. walllamp_27
48. bathroom_cabinet_40
49. bench_228
50. closetdrawer_143
51. doorjamb_165
52. photoframe_285
53. walllamp_28
54. wallshelf_234
55. faucet_232
56. light_245
57. tvstand_225
58. curtain_179
59. bookshelf_101
60. curtain_25
61. doorjamb_347
62. dresser_123
63. shower_38
64. desk_357
65. closetdrawer_160
66. sink_42
67. cpuscreen_416
68. fridge_289
69. curtain_39
70. curtain_23
71. closetdrawer_382
72. light_64
73. nightstand_102
74. closetdrawer_377
75. closetdrawer_116
76. dresser_358
77. ironing_board_2074
78. bookshelf_354
79. closetdrawer_394
80. mousepad_414
81. closetdrawer_121
82. door_44
83. closetdrawer_120
84. computer_417
85. microwave_297
86. sink_231
87. cpuscreen_171
88. dishwasher_1001
89. light_411
90. closetdrawer_384
91. closetdrawer_117
92. ceilinglamp_223
93. doorjamb_346
94. doorjamb_45
95. photoframe_430
96. closetdrawer_392
97. closetdrawer_150
98. toaster_292
99. closetdrawer_146
100. curtain_24
101. door_222
102. coffe_maker_290
103. curtain_409
104. mousepad_167
105. television_248
106. bathtub_30
107. nightstand_100
108. ceilinglamp_349
109. walllamp_350
110. walllamp_29
111. tvstand_353
112. walllamp_351
113. table_107
114. ceilinglamp_96
115. window_63
116. television_410
117. ceilinglamp_26
118. table_226
119. closetdrawer_388
120. powersocket_412
Please only output the number of the most likely position you choose. Do not provide any explanations or comments, just output an integer.

Response:
26

Tokens: 972
################################################################################

System: You are an assistant robot with excellent common sense. Now, I need your to tell me the most likely place that I can find the food_chicken_2017.
Content: I will provide you with my task objectives and some additional information. Most of this information might be useless, but it could include some location data that may help you find my target item. So please refer to this information and make your own judgment. But remember, your output should only be an integer, and do not analyze or explain the content.
Your Goal is:Slice the chicken.
Additional Information:No additional information.
# Find food_chicken_2017:
The possible locations are:
0. stove_2065
1. ceilinglamp_224
2. bed_105
3. bathroom_counter_41
4. closetdrawer_158
5. closetdrawer_154
6. trashcan_99
7. closetdrawer_380
8. light_169
9. wallshelf_35
10. tablelamp_98
11. curtain_180
12. closetdrawer_118
13. washing_machine_2007
14. orchid_178
15. bench_227
16. basket_for_clothes_2006
17. shower_36
18. desk_104
19. bookshelf_233
20. curtain_181
21. closetdrawer_119
22. tablelamp_97
23. curtain_408
24. cupboard_229
25. powersocket_246
26. kitchen_counter_230
27. photoframe_185
28. wallshelf_235
29. toilet_37
30. computer_170
31. table_355
32. home_office_319
33. faucet_43
34. filing_cabinet_399
35. closetdrawer_148
36. closetdrawer_122
37. window_86
38. cutting_board_2051
39. orchid_244
40. stovefan_288
41. dresser_108
42. curtain_407
43. oven_295
44. couch_352
45. coffee_table_2068
46. window_348
47. walllamp_27
48. bathroom_cabinet_40
49. bench_228
50. closetdrawer_143
51. doorjamb_165
52. photoframe_285
53. walllamp_28
54. wallshelf_234
55. faucet_232
56. light_245
57. tvstand_225
58. curtain_179
59. bookshelf_101
60. curtain_25
61. doorjamb_347
62. dresser_123
63. shower_38
64. desk_357
65. closetdrawer_160
66. sink_42
67. cpuscreen_416
68. fridge_289
69. curtain_39
70. curtain_23
71. closetdrawer_382
72. light_64
73. nightstand_102
74. closetdrawer_377
75. closetdrawer_116
76. dresser_358
77. ironing_board_2074
78. bookshelf_354
79. closetdrawer_394
80. mousepad_414
81. closetdrawer_121
82. door_44
83. closetdrawer_120
84. computer_417
85. microwave_297
86. sink_231
87. cpuscreen_171
88. dishwasher_1001
89. light_411
90. closetdrawer_384
91. closetdrawer_117
92. ceilinglamp_223
93. doorjamb_346
94. doorjamb_45
95. photoframe_430
96. closetdrawer_392
97. closetdrawer_150
98. toaster_292
99. closetdrawer_146
100. curtain_24
101. door_222
102. coffe_maker_290
103. curtain_409
104. mousepad_167
105. television_248
106. bathtub_30
107. nightstand_100
108. ceilinglamp_349
109. walllamp_350
110. walllamp_29
111. tvstand_353
112. walllamp_351
113. table_107
114. ceilinglamp_96
115. window_63
116. television_410
117. ceilinglamp_26
118. table_226
119. closetdrawer_388
120. powersocket_412
Please only output the number of the most likely position you choose. Do not provide any explanations or comments, just output an integer.

Response:
68

Tokens: 976
################################################################################

System: I encountered this error while running the program. Please try to correct my mistake based on the error information and syntax rules I provided.
Content: 
## Task Description: 
I have a long horizon task: slice some chicken To approach this task effectively, I’ve divided it into several sub-tasks. The goal of the current sub-task is: Slice the chicken. The sub-tasks I have already completed include: None, it is the first sub-task. Additionally, I’ve gathered the following information to assist in completing this task: None.

## Current Goal Representation With Error:
 
behavior __goal__():
    body:
        bind chicken: item where:
            is_food_chicken(chicken)
        # Select the chicken item
        
        bind knife: item where:
            is_knife(knife)
        # Select the knife

        symbol has_cutting_board=exists board: item : (is_cutting_board(board))
        if not has_cutting_board:
            # If there is no cutting board, check all unvisited items to find one
            foreach board: item:
                if is_cutting_board(board) and not visited(board):
                    achieve close_char(char, board)
                    break

        if has_cutting_board:
            bind board: item where:
                is_cutting_board(board)
            # Select the cutting board
            achieve on(chicken, board)
            # Place the chicken on the cutting board
            achieve close_char(char, board)
            # Move close to the cutting board
        
        achieve_once inhand(knife)
        # Take the knife in hand for cutting
        
        achieve cut(chicken)
        # Cut the chicken



## Error Information:
Current Goal Representation uses variable 'break' before it is declared.
Please refer to the method used in the examples below to modify the goal representation I provided in this round, supplementing the missing definitions and declarations. Each example below will provide both wrong and correct versions, so you can learn how I make the modifications.

- Wrong Version(light in make_dinner is not defined):
behavior make_dinner():
    body:
        achieve is_on(light)

-> corrected version:
behavior make_dinner(light:item):
    body:
        achieve is_on(light)
    
In this example, the original version of the behavior definition contains an undefined variable light in behavior "make_dinner". To correct this, I added the parameter light:item to the behavior definition.

- Wrong Version(obj1 and obj2 in obj_inside_or_on are not defined before use):
def obj_inside_or_on():
  return inside(obj1, obj2) or on(obj2, obj1)

-> corrected version:
def obj_inside_or_on(obj1: item, obj2: item):
  return inside(obj1, obj2) or on(obj2, obj1)

In this example, the original version of the function contains two undefined variables obj1 and obj2 in function obj_inside_or_on. To correct this, I added the parameters obj1: item and obj2: item to the function definition.

- Wrong Version(inhand_obj and obj in "goal" of put_close are not defined):
behavior put_close():
  goal: close(inhand_obj, obj)
  body:
    put(inhand_obj, obj)

-> corrected version:
behavior put_close(inhand_obj: item, obj: item):
  goal: close(inhand_obj, obj)
  body:
    put(inhand_obj, obj)

In this example, the original version of the goal definition contains two undefined variables inhand_obj and obj. To correct this, I added the parameters inhand_obj: item and obj: item in the behavior defination.

- Wrong Version("location" in "body" of drop is not defined):
behavior drop_to_somewhere(inhand_obj:item):
  goal: not inhand(inhand_obj)
  body:
    put(inhand_obj, location)

-> corrected version:
behavior drop(inhand_obj:item,location:item):
  goal: not inhand(inhand_obj)
  body:
    put(inhand_obj, location)

In this example, the original version of the behavior definition contains an undefined variable location in the body of the behavior "drop". To correct this, I added the bind statement to define the variable location.   

- Wrong Version(use "self" instead of "char"):
behavior view_neighborhood_from_bathroom_window():
    body:
        bind bathroom: item where:
            is_bathroom(bathroom)
        bind window: item where:
            is_window(window) and inside(window, bathroom)
        achieve close_char(self, bathroom)

-> corrected version:
behavior view_neighborhood_from_bathroom_window():
    body:
        bind bathroom: item where:
            is_bathroom(bathroom)
        bind window: item where:
            is_window(window) and inside(window, bathroom)
        achieve close_char(char, bathroom)

In this example, the original version of the behavior definition contains an undefined variable self in the body of the behavior "view_neighborhood_from_bathroom_window". Use "char" directly to represent itself.

Please note that, you can not provide any parameters to __goal__().
At the same time, please note that when you modify the parameters of a function or behavior, don't forget to also modify the function or behavior call statements to add any missing parameters.


## Precautions:
- Ensure that the states, relationships, properties, and keywords used do not exceed the scope I provided. (Available states, relationships, properties, and keywords are listed below.)
- If you invoke a function, ensure it’s properly defined, and include any necessary parameters when calling it.
- When using the keyword achieve, it must only be followed by terms defined under ## Available States or ## Available Relationships. It is strictly prohibited to follow achieve with properties, custom symbols, or functions.
- The behavior __goal__(): is required and functions similarly to the main function in Python; it should typically be placed at the end of your output without any parameters.

## Available States:
Please note: The text following each hash symbol (#) is a comment and should not be included in the current sub-task goal representation. 
- is_on(x: item) # The item is turned on.
- is_off(x: item) # The item is turned off.
- plugged(x: item) # The item is plugged in.
- unplugged(x: item) # The item is unplugged.
- open(x: item) # The item is open.
- closed(x: item) # The item is closed.
- dirty(x: item) # The item is dirty.
- clean(x: item) # The item is clean.
- has_water(x: item) # The item has water inside or on it.
- cut(x: item) # The item is cut.
- inhand(x: item) # A item is grasped by a character. Only use it when an item needs to be continuously held in your hand.
- has_a_free_hand(x: character) # The character has a free hand.
- visited(x: item) # The character has observed the item
Important Note: The inhand(x) state is unique. If you intend to use inhand(x), you must implement it using the achieve_once keyword. At the same time, please note that you can take at most two items. Having too many items in hand will result in no solution.

## Available Relationships:
Please note: The text following each hash symbol (#) is a comment and should not be included in the current sub-task goal representation. 
- on(x: item, y: item) # item x is on top of item y
- inside(x: item, y: item) # item x is inside item y, and y should be a room or a container
- inside_char(x: character, y: item) # character is inside item y (Character is you self. Any other animal like cat is an item)
- close(x: item, y: item) # item x is close to item y
- close_char(x: character, y: item) # character is close to item y (Character is you self. Any other animal like cat is an item)
Important Usage Notes: In relationships with the '_char' suffix, the first parameter must always be a char. For example, 'inside' and 'inside_char', 'close' and 'close_char'.

## Available Properties:
Please note: The text following each hash symbol (#) is a comment and should not be included in the current sub-task goal representation.
- surfaces(x: item) #  Indicates that the item has a surface where things can be placed, such as a kitchen countertop or table.
- grabbable(x: item) # Indicates that the item can be grabbed by hand.
- hangable(x: item) # Indicates that the item can be hung on.
- drinkable(x: item) # Indicates that the item can be drunk.
- eatable(x: item) # Indicates that the item can be eaten.
- recipient(x: item) # Indicates that the item can receive something.
- cuttable(x: item) # Indicates that the item can be cut with a knife.
- pourable(x: item) # Indicates that the item can be poured into another container or onto other items.
- can_open(x: item) # Indicates that the item can be opened.
- has_switch(x: item) # Indicates that the item has a switch to turn it on or off.
- readable(x: item) # Indicates that the item can be read.
- lookable(x: item) # Indicates that the item can be looked at.
- containers(x: item) # Indicates that the item is a container.
- has_plug(x: item) # Indicates that the item has a plug.
- movable(x: item) # Indicates that the item can be moved.
- is_clothes(x: item) # Indicates that the item is clothing.
- is_food(x: item) # Indicates that the item is food.
Important Notes: "propertie" cannot be assigned a value nor can it be used after "achieve".; they can only return a boolean value as a predicate. For example, an apple can be grabbed, so grabbable(apple) will return true. Properties are typically used in if conditions.
Common Errors:
achieve can_open(door) # Incorrect. Properties cannot be used after achieve as they cannot have their values modified.
has_plug(lamp) = True # Incorrect. You cannot assign a value to a property, as they are immutable.

# Available Behaviors:
Please note: The text following each hash symbol (#) is a comment and should not be included in the current sub-task goal representation.
The following behaviors can be directly invoked in the current sub-task goal representation, with parameters passed in like function arguments.
- observe(obj:item,question:string) # observe is a special behavior used to inspect an object. You can specify the purpose of your inspection with a string. By calling observe, you can learn about the state of an object as well as its relationship with surrounding objects. After observing an item, it will be marked as visited. Note that the second parameter of observe is a string and must be enclosed in double quotes("").
- wash(obj:item) # Wash an item by hand.
- scrub(obj:item) # Scrub an item.
- wipe(obj:item) # Wipe an item.
- squeeze(obj:item) # Squeeze an item.
- rinse(obj:item) # Rinse an item.
- move(obj:item) # Move an item.
- pull(obj:item) # Pull an item.
- push(obj:item) # Push an item.
- type(obj:item) # Type on an item.
- touch(obj:item) # Touch an item.
- read(obj:item) # Read an item.
Important Note: Ensure that all parameters are properly defined before using them in the behaviors.

## Available Category Determination:
- is_mat(x: item)
- is_drawing(x: item)
- is_food_bread(x: item)
- is_bedroom(x: item)
- is_couch(x: item)
- is_chair(x: item)
- is_stovefan(x: item)
- is_clothes_scarf(x: item)
- is_cpuscreen(x: item)
- is_coffee_filter(x: item)
- is_oven(x: item)
- is_cd_player(x: item)
- is_food_vegetable(x: item)
- is_food_hamburger(x: item)
- is_mouse(x: item)
- is_soap(x: item)
- is_clothes_dress(x: item)
- is_dvd_player(x: item)
- is_food_donut(x: item)
- is_ceilinglamp(x: item)
- is_book(x: item)
- is_cup(x: item)
- is_food_rice(x: item)
- is_cupboard(x: item)
- is_food_kiwi(x: item)
- is_food_cereal(x: item)
- is_food_snack(x: item)
- is_mousepad(x: item)
- is_ironing_board(x: item)
- is_food_pizza(x: item)
- is_fridge(x: item)
- is_faucet(x: item)
- is_clothes_pants(x: item)
- is_towel(x: item)
- is_orchid(x: item)
- is_food_fish(x: item)
- is_nightstand(x: item)
- is_food_steak(x: item)
- is_toaster(x: item)
- is_door(x: item)
- is_dining_room(x: item)
- is_curtain(x: item)
- is_table(x: item)
- is_food_apple(x: item)
- is_bathroom(x: item)
- is_home_office(x: item)
- is_desk(x: item)
- is_tvstand(x: item)
- is_dishwasher(x: item)
- is_food_sugar(x: item)
- is_basket_for_clothes(x: item)
- is_bowl(x: item)
- is_dry_pasta(x: item)
- is_sauce(x: item)
- is_oil(x: item)
- is_kitchen_counter(x: item)
- is_clothes_hat(x: item)
- is_powersocket(x: item)
- is_knife(x: item)
- is_doorjamb(x: item)
- is_food_onion(x: item)
- is_bathtub(x: item)
- is_food_dessert(x: item)
- is_clothes_socks(x: item)
- is_food_chicken(x: item)
- is_clothes_jacket(x: item)
- is_closetdrawer(x: item)
- is_pillow(x: item)
- is_bench(x: item)
- is_bathroom_cabinet(x: item)
- is_food_ice_cream(x: item)
- is_vacuum_cleaner(x: item)
- is_cat(x: item)
- is_trashcan(x: item)
- is_bookshelf(x: item)
- is_shower(x: item)
- is_walllamp(x: item)
- is_spectacles(x: item)
- is_bathroom_counter(x: item)
- is_milk(x: item)
- is_clothes_underwear(x: item)
- is_ceiling(x: item)
- is_towel_rack(x: item)
- is_food_potato(x: item)
- is_toilet(x: item)
- is_clothes_shirt(x: item)
- is_cleaning_solution(x: item)
- is_iron(x: item)
- is_floor(x: item)
- is_food_carrot(x: item)
- is_fryingpan(x: item)
- is_bed(x: item)
- is_hairbrush(x: item)
- is_food_salt(x: item)
- is_clothes_gloves(x: item)
- is_keyboard(x: item)
- is_remote_control(x: item)
- is_microwave(x: item)
- is_dresser(x: item)
- is_food_oatmeal(x: item)
- is_pot(x: item)
- is_food_orange(x: item)
- is_coffee_table(x: item)
- is_food_food(x: item)
- is_fork(x: item)
- is_napkin(x: item)
- is_toilet_paper(x: item)
- is_food_egg(x: item)
- is_light(x: item)
- is_tray(x: item)
- is_sink(x: item)
- is_wall_clock(x: item)
- is_food_peanut_butter(x: item)
- is_photoframe(x: item)
- is_coffe_maker(x: item)
- is_food_jam(x: item)
- is_headset(x: item)
- is_clothes_skirt(x: item)
- is_wall(x: item)
- is_food_turkey(x: item)
- is_food_cheese(x: item)
- is_filing_cabinet(x: item)
- is_washing_machine(x: item)
- is_food_cake(x: item)
- is_window(x: item)
- is_computer(x: item)
- is_plate(x: item)
- is_wallshelf(x: item)
- is_television(x: item)
- is_food_fruit(x: item)
- is_cutting_board(x: item)
- is_detergent(x: item)
- is_phone(x: item)
- is_tablelamp(x: item)
- is_food_banana(x: item)
- is_food_lemon(x: item)
- is_hanger(x: item)
- is_food_bacon(x: item)
- is_stove(x: item)
- is_cd(x: item)
- is_food_noodles(x: item)
- is_pencil(x: item)

For any instance 'x', you can use 'is_y(x)' to determine if 'x' belongs to category 'y'. Categories cannot be operated upon directly; you can only assess the status and relationships of specific instances within a category. If you want to select an item instance that belongs to the category "box", you can use the following syntax:

bind b: item where:
    is_box(b)

Important Notes:
If the category you need is not in the available list, try to find a synonym or a similar category with a closely related function.
Examples:
- food -> is_food_food(): If 'is_food' is not available, but 'is_food_food' is, use the latter as they have similar meanings.
- soapy_water -> is_cleaning_solution(): If 'soapy_water' is not available, but 'cleaning_solution' is, use the latter as they are functionally similar.

## Syntax Rules and Keywords:
"char" is a constant instance representing a character (yourself) and we assume that other animals like cat is an item. The type "character" can only be used when defining an instance. Use "char" consistently when passing parameters, and use "character" when defining a variable and specifying its type.

Below are all the keywords you can use to convert information into a structured format. Please ensure that you do not use any keywords other than those listed here.

Keywords:
# bind
# Usage: Randomly select an item that satisfies the specified conditions and assign it to a variable. If no item meets the condition, the program will fail. Therefore, avoid setting overly strict conditions unless you are certain that a corresponding item exists. The condition is_x will always be satisfied as long as x is specified in Available Category Determination. However, exercise caution when adding additional conditions.To maintain consistency, try to use 'bind' primarily in the '__goal__' behavior and pass the retrieved instances as parameters to invoked behaviors. Avoid using 'bind' in other behaviors whenever possible.
Example:
bind x: item where:
    is_light(x)

Multiple Items Example: Ensure that subsequent items are not the same as those previously bound.
bind apple1: item where:
    is_apple(apple1)
bind apple2: item where:
    is_apple(apple2) and apple1!=apple2
bind apple3: item where:
    is_apple(apple3) and apple1!=apple3 and apple2!=apple3

# achieve
# Usage: Specifies the state or relationship that a behavior consistently aims to maintain from start to finish. Only states and relationships can follow 'achieve', not types, properties, or other immutable content. Do not call functions or behaviors after 'achieve'; instead, call functions directly without keywords. Note that 'achieve' cannot be used with the state 'inhand'. And note that 'achieve' must be followed by a single state or relationship, not a combination of states or relationships.
Examples:
achieve is_on(light) # it is used to turn on the light.
achieve has_water(cup) # it is used to fill the cup with water.
achieve has_water(pot) # it is used to fill the pot with water.
achieve cut(apple) # it is used to cut the apple.
achieve on(apple, plate) # it is used to place the apple on the plate.
achieve inside(oil, pan) # it is used to add oil into the pan.

# achieve_once
# Usage: Specifies a temporary state or relationship that needs to be achieved only once, without maintaining it until the end of the behavior.
Example: achieve_once inhand(apple) #Please note that 'inhand' must be used with 'achieve_once.'

# foreach
# Usage: Iterates over all objects. Do not use 'where' in a 'foreach' statement. Additionally, do not nest one foreach inside another, as this will cause the program to fail.
Correct example:
foreach o: item:
    if can_open(o) and is_box(o):
        achieve closed(o)

Incorrect example:
foreach o: item where:
    if can_open(o) and is_box(o):
        achieve closed(o)

# behavior
# Usage: Defines a behavior rule. The keyword 'body' must appear in the behavior, and all parameters used in the 'goal' must be included in the behavior's parameters.

# goal
# Usage: Specifies the goal condition for a behavior. If you want to use the goal, please ensure that you include all the parameters used in the 'goal' in the behavior parameters.

# body
# Usage: Contains the sequence of intermediate states and relationships necessary to achieve the behavior’s goal.

# if-else
# Usage: Conditional statement for branching logic. Only simple first-order logic or combinations of first-order logic are allowed after if-else. Note that elif is not supported.
if condition:
    achieve has_water(a)
else:
    achieve clean(b)

# exists
# Usage: Checks if there is at least one object that meets the condition and returns a boolean value.
Template: exists obj_name: objtype : condition()
Example: exists item1: item : holds_lh(char, item1)

# symbol
# Usage: Defines a symbol and binds it to the output of an expression. You can only use the symbol in the following manner:
symbol has_cutting_board=exists item1:item: (is_cutting_board(item1))

# def
# Usage: Defines a function that can be used to check a condition. 

## Background Knowledge:
In general, you only know part of the information in a given scenario. For example, you might know that a certain piece of clothing is in a particular basket, but you might not know what is in a certain basket. Therefore, many times, you need to first perform a goal conversion based on what you already know. When you lack some information, you can observe and obtain the information you want by using obs(target_item, information).
For example, if you want to know if there are clothes in the basket_34, you can use:
bind basket: item where:
    is_basket(basket) and id[basket]==34
observe(basket,"Check is there any clothes in the basket")

If you want to know Is there any trash in the trash can in the dining room, you can use:

bind dining_room: item where:
    is_dining_room(dining_room)

bind trash_can: item where:
    is_trash_can(trash_can) and inside(trasn_can, dining_room) # Since you already know that the trash can is located in the dining room, you can include the condition inside(trash_can, dining_room). However, if the location of the trash can is unknown, this condition must be omitted.
observe(trash_can,"Check is there any trash in the trash can")

## Examples:
# Example-1-1:
Current sub-task goal: 1. Find a table with food.
The completed sub-tasks: None, it is the first sub-task.
Additional information: None.
Long-horizon task: Clean up the food on the table.
Chain of thought: Your current sub-task goal is to find a table with food on it, which is the first step towards completing the long-horizon task. According to the background knowledge, your first step should be to check if there is a known table with food on it. To do this, you need to determine whether there is food on a table. You can create a function called 'has_food_on_table(table:item)', which returns the result of the expression 'exists o: item : is_food(o) and on(o, table)'. This expression checks if there is an item classified as food that is on the table, according to your known information.
Next, you can use the expression 'exists table: item : is_table(table) and has_food_on_table(table)' to verify if there is a table with food on it in the known information. If such a table exists, there is no need to continue searching; you can immediately use 'achieve close_char(char, table)' to have the character approach the table with food.
However, if your known information does not confirm the presence of a table with food on it, you will need to inspect all unvisited items in the scene categorized as tables. To do this, you should call the 'observe' behavior to check each table. The first parameter of the 'observe' behavior should be the table you intend to inspect, and the second parameter should be the purpose of the inspection. Remember, the second parameter must be a string enclosed in double quotes ("").

Output:
def has_food_on_table(table:item):
    # Function to check if there is food on the specified table.
    symbol has_food=exists o: item : (is_food(o) and on(o, table))
    return has_food

behavior __goal__():
    body:
        if exists table: item : is_table(table) and has_food_on_table(table):
            # Check if there is a table with food based on the available information.
            bind table: item where:
                is_table(table) and has_food_on_table(table) # The condition has_food_on_table can only be used when you are certain that there is food on the table. In this case, you can be confident because you have already verified it with an if condition.
            # Select a table that has food on it.
            achieve close_char(char, table) 
            # Move the character closer to the table with food.

        else: 
           # If no table with food is found, initiate exploration to locate one.
            foreach table: item:
                if is_table(table) and not visited(table):
                    # Check all unvisited tables.
                    observe(table,"Check is there any food on the table")
                    # Observe whether each table has any food.
            
# Example-1-2:
Current sub-task goal: 2. Put the food in the appropriate storage locations.
The completed sub-tasks: 1. Find a table with food.
Additional information: 
1. There is no food on table 107. 
2. No food is find on the table 355, please see other tables.
3. food_peanut_butter_2008 and food_kiwi_2012 are on the table_226.
Long-horizon task: Clean up the food on the table.

Chain of thought: You have already find the table with food. Now, your current sub-task goal is to store the food on the table in the appropriate location. According to the additional information, there is no food on table_107 and table_355. However, table_226 has food_peanut_butter and food_kiwi.You can use the 'bind' keyword along with the condition 'is_table(table) and id[table] == 226' to obtain the table with the ID 226. You can also use the 'bind' keyword with the condition 'is_food_peanut_butter(food_peanut_butter)' to obtain the peanut butter. And use 'bind' keyword with the condition 'is_food_kiwi(food_kiwi)' to obtain the kiwi. Since the sub-task goal and additional information do not specify where exactly to store the food, you need to use common sense to make a decision based on the items present in the scene. Based on common sense, both food_peanut_butter and food_kiwi may require refrigeration, and since there is a fridge available in the scene, the goal is to store them in the fridge. Although it is not explicitly stated, it is common sense to ensure that the fridge door is closed after storing food inside. Therefore, you can use achieve closed(fridge) to perform the action of closing the fridge door.

Output:
behavior store_in_fridge(food:item, fridge:item):
    body:
        achieve inside(food, fridge)
        # Place the food item inside the fridge.

behavior close_the_fridge_door(fridge:item):
    body:
        achieve closed(fridge)
        # Close the fridge door.

behavior __goal__():
    body:
        bind table: item where:
            is_table(table) and id[table]==226
        # Select table with ID 226.

        bind food_peanut_butter: item where:
            is_food_peanut_butter(food_peanut_butter)
        # Select peanut butter.

        bind food_kiwi: item where:
            is_food_kiwi(food_kiwi)
        # Select kiwi on the table.
        
        bind fridge: item where:
            is_fridge(fridge)
        store_in_fridge(food_peanut_butter, fridge)
        store_in_fridge(food_kiwi, fridge)
        close_the_fridge_door(fridge)

# Example-1-3:
Current sub-task goal: 2. Put the food in the appropriate storage locations.
The completed sub-tasks: 1. Find a table with food.
Additional information: 
1. There is no food on table 107. 
2. No food is find on the table 355, please see other tables.
3. food_peanut_butter_2008 and food_kiwi_2012 are on the table_226.
4. The peanut butter is expired, so I want to throw it away. I want to cut the kiwi and then store it in the fridge.
Long-horizon task: Clean up the food on the table.

Chain of thought: According to Additional information 4, you need to discard the peanut butter. Observing that there is an "is_trashcan" in the Available Category, you can infer that there is a trashcan in the scene, and the expired peanut butter can be thrown into the trashcan. Additional information 4 also requires that the kiwi be cut, and then stored in the fridge. You need to use "achieve cut(food_kiwi)" to cut the kiwi. After that, you can "achieve inside(food_kiwi, fridge)" to store the kiwi in the fridge. To ensure the completeness of the task, you also need to use "achieve closed(fridge)" to make sure the fridge door is closed at the end by "achieve closed(fridge)".

Output:
behavior throw_in_trash(food:item, trashcan:item): 
# Define the behavior to throw food into the trash can
    body:
        achieve inside(food, trashcan)
        
behavior cut_food(food:item):
    body:
        achieve cut(food)

behavior store_in_fridge(food:item, fridge:item):
    body:
        achieve inside(food, fridge)

behavior close_the_fridge_door(fridge:item):
    body:
        achieve closed(fridge)

behavior __goal__():
    body:
        bind table: item where:
            is_table(table) and id[table]==226
        # Select table with ID 226.
        bind food_peanut_butter: item where:
            is_food_peanut_butter(food_peanut_butter)
        # Select peanut butter on the table.
        bind food_kiwi: item where:
            is_food_kiwi(food_kiwi)
        # Select kiwi on the table.
        bind trashcan: item where:
            is_trashcan(trashcan)
        # Select a trash can.
        bind fridge: item where:
            is_fridge(fridge)
        # Select a fridge.
        throw_in_trash(food_peanut_butter, trashcan)
        cut_food(food_kiwi)
        store_in_fridge(food_kiwi, fridge)
        close_the_fridge_door(fridge)
          
# Example-2-1:
Current sub-task goal: 1. Find the sink with plates and cups.
The completed sub-tasks: None, it is the first sub-task.
Additional information: None.
Long-horizon task: Wash the plates and cups in the sink using the dishwasher. Then put them on the table in kitchen.

Chain of thought: Your current sub-task goal is to find the sink with plates and cups, which is the first step toward completing the long-horizon task: "Wash the plates and cups in the sink using the dishwasher. Then put them on the table in the kitchen."
To achieve this, you first need to determine whether there are plates or cups in the sink. You can design a function called 'has_plate_or_cup_in_sink(sink:item)' that checks for this. The function should return the result of the expression 'exists o: item : (is_plate(o) or is_cup(o)) and inside(o, sink)', which verifies if there is an item that is either a plate or a cup and is located inside the sink in your known information.
Next, you can use 'exists sink: item : is_sink(sink) and has_plate_or_cup_in_sink(sink)' to check if there is a sink with plates or cups in it within the known information. If such a sink is found, there's no need to search further; you can immediately use 'achieve close_char(char, sink)' to have the character approach the sink containing the plates or cups.
However, if your known information does not confirm the presence of a sink with plates or cups, you will need to check all unvisited items categorized as sinks in the scene. For this, you should call the 'observe' behavior to inspect each sink. The first parameter of the 'observe' behavior should be the sink you intend to check, and the second parameter should be the purpose of the inspection. Remember, the second parameter must be a string enclosed in double quotes ("").

Output:
def has_plate_or_cup_in_sink(sink:item):
    # Function to check if there are plates or cups in a specified sink.
    symbol has_plate_or_cup=exists o: item : ((is_plate(o) or is_cup(o)) and inside(o, sink))
    return has_plate_or_cup

behavior __goal__():
    body:
        if exists sink: item : is_sink(sink) and has_plate_or_cup_in_sink(sink):
            # If we have already found the sink with plates or cups, we can directly approach it
            bind sink: item where:
                is_sink(sink) and has_plate_or_cup_in_sink(sink)
            achieve close_char(char, sink)

        else:
            # Check all sinks in the scene that have not been visited
            foreach sink: item:
                if is_sink(sink) and not visited(sink):
                    observe(sink,"Check is there any plate or cup in the sink")

# Example-2-2:
Current sub-task goal: 2. Wash the plates and cups using the dishwasher.
The completed sub-tasks: 1. Find the sink with plates and cups.
Additional information: 
1. sink_42 is in the bathroom, and no plates or cups are found in it.
2. sink_231 is in the kitchen, and there are plates and cups in it.
Long-horizon task: Wash the plates and cups in the sink using the dishwasher. Then put them on the table in kitchen.

Chain of thought:
According to additional information, sink_42 does not contain plates or cups, while sink_231 does contain plates or cups. Now you have found the sink that contains plates or cups. The current sub-task's goal is "Wash the plates and cups using the dishwasher." Although it doesn't explicitly state that the plates and cups in the sink need to be cleaned, considering the objective of the long-horizon task, the actual goal of the current sub-task should be to clean the plates and cups in the sink. To clean the plates and cups in the sink using the dishwasher, you first need to load them into the dishwasher. Since it is unclear how many plates and cups are in the sink, the foreach keyword is used with the condition if is_plate(o) or is_cup(o) and inside(o, sink) to place all items that are plates or cups from the sink into the dishwasher. After that, you can execute achieve closed(dishwasher) and achieve is_on(dishwasher) sequentially to start the dishwasher.

Output:
behavior load_dishwasher(o:item, dishwasher:item):
    body:
        achieve inside(o, dishwasher)
        # Place the item inside the dishwasher.

behavior start_dishwasher(dishwasher:item):
    body:
        achieve closed(dishwasher) # Close the dishwasher door.
        achieve is_on(dishwasher) # Turn on the dishwasher.

behavior __goal__():
    body:
        bind sink: item where:
            is_sink(sink) and id[sink]==231
        # Select sink with ID 231.
        bind dishwasher: item where:
            is_dishwasher(dishwasher)
        # Select a dishwasher.
        foreach o: item:
        # Load all plates and cups from the sink into the dishwasher.
            if is_plate(o) or is_cup(o) and inside(o, sink):
                load_dishwasher(o, dishwasher)
        start_dishwasher(dishwasher) # Start the dishwasher.

# Example-2-3:
Current sub-task goal: 3. Put the plates and cups on the table in the kitchen.
The completed sub-tasks: 1. Find the sink with plates and cups. 2. Wash the plates and cups using the dishwasher.
Additional information: 
1. plate_1000, plate_1001, cup_1002, cup_1003 is cleaned by dishwasher_2000.
Long-horizon task: Wash the plates and cups in the sink using the dishwasher. Then put them on the table in kitchen.

Chain of thought:
According to "The completed sub-tasks" and "Additional information," the plates and cups that need to be placed on the table have already been cleaned in a dishwasher, and they are currently in a dishwasher with an ID of 2000. The current sub-task requires you to place the plates and cups on a table located in the kitchen. There may be more than one table in the scene, so you need to design a function 'in_kitchen(table: item)' that returns the value of the expression 'exists room: item : is_kitchen(room) and inside(table, room)', which checks whether the given table is inside a kitchen. Next, you need to design a 'put_on_table' behavior to place the plates or cups on the table. To determine which table to use, you should apply 'put_on_table' to all the plates or cups that were originally in the dishwasher, placing them on the table. Finally, to ensure the dishwasher is properly reset, you can design a 'close_the_dishwasher' behavior to turn off and close the dishwasher.

Output:
def in_kitchen(table:item):
    # Function to check if a table is in the kitchen.
    symbol in_kitchen=exists room: item : (is_kitchen(room) and inside(table, room))
    return in_kitchen

def has_plates_or_cups_inside(dishwasher:item):
    # Function to check if there are plates or cups inside the dishwasher.
    symbol has_plates_or_cups=exists o: item : ((is_plate(o) or is_cup(o)) and inside(o, dishwasher))
    return has_plates_or_cups

behavior put_on_table(o:item, table:item):
    body:
        achieve on(o, table) # Place the item on the table.

behavior close_the_dishwasher(dishwasher:item):
    body:
        achieve is_off(dishwasher) # Turn off the dishwasher.
        achieve closed(dishwasher) # Close the dishwasher door.

behavior __goal__():
    body:
        bind table: item where:
            is_table(table) and in_kitchen(table)
        # Select a table in the kitchen.
        bind dishwasher: item where:
            is_dishwasher(dishwasher) and id[dishwasher]==2000
        # Select the dishwasher with ID 2000.
        foreach o: item:
        # Place all plates and cups originally in the dishwasher on the table.
            if is_plate(o) or is_cup(o) and inside(o, dishwasher):
                put_on_table(o, table)
        close_the_dishwasher(dishwasher) # Reset the dishwasher.

# Example-3:

#Guidance-1:
A common mistake is ignoring the duration of "achieve." The duration of "achieve" persists until the current action is completed. If you specify two mutually exclusive states in a behavior using "achieve," it will result in a program error.

Here is some typical errors:
- error example:
behavior put_apple_on_table(apple:item,table:item):
    body:
        achieve inhand(apple)
        achieve on(apple,table)

Error Analysis: In this example, if you use achieve inhand(apple), then the apple must be keep inhand until the end of this behavior. Then you use achieve on(apple,table), which means you put the apple on the table. Now the apple should be both remain in hand and be placed on the table, which is impossible to achieve. The solution to this problem is to remove the unnecessary step of achieving inhand(apple), as the program will automatically determine how to achieve on(apple,table). In fact, unless you need to hold an item to complete a specific task (such as cutting vegetables with a knife or wiping a window with a cloth), please avoid using the "inhand" state in other situations.

A correct output for this example is:
behavior put_apple_on_table(apple:item,table:item):
    body:
        achieve on(apple,table)

# Guidance-2:
The following example demonstrates the difference between using foreach and bind.

Please note that bind requires the use of the "where keyword", while foreach must not use the "where" keyword under any circumstances.  
eg:
foreach c: item:
    if is_clothes(c) and inside(c,basket):
        achieve inside(c, washing_machine)

bind basket: item where:
    is_basket_for_clothes(basket)

You can see that the foreach statement is used without "where", while the bind statement needs to include "where".

# Guidance-3:
In some cases, there may be multiple instances of the same object type within a scene. Simply using 'is_category()' to constrain the object type might be insufficient for selecting a specific instance. To retrieve the desired object more precisely, there are generally two methods. 
1. Using the ID: If you know the instance's unique ID, you can directly reference it, for example:

bind dishwasher: item where:
    is_dishwasher(dishwasher) and id[dishwasher] == 2000.

2. Adding positional relationships: You can specify spatial relationships between instances, for example: 

bind table: item where:
    is_table(table) and inside(table, kitchen).

In more complex scenarios, you can follow the approach in Example 2-3 by designing a function that adds constraints to the bind operation, allowing you to accurately retrieve the target instance.
Example:
def in_kitchen(table:item):
    symbol in_kitchen=exists room: item : (is_kitchen(room) and inside(table, room))
    return in_kitchen
    ......
bind table: item where:
    is_table(table) and in_kitchen(table)

You can also use attributes, states, and other information to further refine your constraints for the bind operation. However, it is crucial to ensure that an object satisfying all conditions exists. If you add more conditions to the bind statement but no object meets all of them, the operation will fail. Therefore, be mindful of how constraints interact to avoid retrieval errors.

# Guidance-4:
The observe(obj:item, question:string) is a powerful but resource-intensive behavior. It allows you to examine an object based on observation, during which you need to specify what information you wish to obtain from the object. Due to the high cost of using observe, the quality of your questions is crucial for improving execution efficiency. Generally speaking, information such as the type of object or its state can be obtained by referring to the methods provided in 'Available Category Determination' and 'Available States', so you usually don't need to invoke the observe behavior for these details. Some situations where observe behavior is necessary include when you want to check what items are inside or on the item you observe. For example, if you want to see what's inside the oven, you can use 'observe(oven, "What's inside the oven?")', or if you want to check what's on the table, you can use 'observe(table, "check items on the table")'. Also, feel free to ask more questions in the observe behavior to get more detailed information. For example, If you want to check what's inside the oven and whether it's on the kitchen counter, you can use 'observe(oven, "What's inside the oven? Is it on the kitchen counter?")'.

# Guidance-5:
Try to avoid using the 'inhand(x:item)' state. In most cases, the program will automatically manage the 'inhand' operations. If you define 'inhand' manually, it can easily lead to a situation where the agent is holding too many items, causing the program to crash. There is generally only one situation where you need to declare the 'inhand' operation: when you have to hold certain items all the time to complete a specific task. For example, when cleaning a mirror with a towel, you need to use 'achieve_once inhand(towel)'. Other than this, please avoid defining the 'inhand' state. In some cases, the task information may not clearly specify where certain items should be placed, such as in "gathering the food." In these cases, use your common sense to place the food in an appropriate location, like achieve 'on(food, kitchen_counter)', to avoid the issue of holding too many items. If possible, ensure that the agent's hands are empty after each sub-task is completed.



## Output Requirements:
You need to think step by step to give resonable output. Directly output the corrected goal representation. Do not include any explanation or additional symbols.


Response:
```python
behavior __goal__():
    body:
        bind chicken: item where:
            is_food_chicken(chicken)
        # Select the chicken item
        
        bind knife: item where:
            is_knife(knife)
        # Select the knife

        symbol has_cutting_board=exists board: item : (is_cutting_board(board))
        if not has_cutting_board:
            # If there is no cutting board, check all unvisited items to find one
            foreach board: item:
                if is_cutting_board(board) and not visited(board):
                    achieve close_char(char, board)

        if has_cutting_board:
            bind board: item where:
                is_cutting_board(board)
            # Select the cutting board
            achieve on(chicken, board)
            # Place the chicken on the cutting board
            achieve close_char(char, board)
            # Move close to the cutting board
        
        achieve_once inhand(knife)
        # Take the knife in hand for cutting
        
        achieve cut(chicken)
        # Cut the chicken
```

Tokens: 10106
################################################################################

System: You are an assistant robot with excellent common sense. Now, I need your help to select the items to search for based on the current task and output a list of item serial numbers.
Content: 
The goal is: Slice the chicken..
The additional information is: None
My goal representation is:  
behavior __goal__():
    body:
        bind chicken: item where:
            is_food_chicken(chicken)
        # Select the chicken item
        
        bind knife: item where:
            is_knife(knife)
        # Select the knife

        symbol has_cutting_board=exists board: item : (is_cutting_board(board))
        if not has_cutting_board:
            # If there is no cutting board, check all unvisited items to find one
            foreach board: item:
                if is_cutting_board(board) and not visited(board):
                    achieve close_char(char, board)
                    break

        if has_cutting_board:
            bind board: item where:
                is_cutting_board(board)
            # Select the cutting board
            achieve on(chicken, board)
            # Place the chicken on the cutting board
            achieve close_char(char, board)
            # Move close to the cutting board
        
        achieve_once inhand(knife)
        # Take the knife in hand for cutting
        
        achieve cut(chicken)
        # Cut the chicken



The unknown categories are: 
0.clothes_pants
1.food_steak
2.clothes_jacket
3.mat
4.knife
5.book
6.cd_player
7.food_ice_cream
8.dvd_player
9.cleaning_solution
10.food_fish
11.vacuum_cleaner
12.plate
13.food_oatmeal
14.hanger
15.pillow
16.mouse
17.food_onion
18.food_cereal
19.napkin
20.food_vegetable
21.tray
22.chair
23.food_pizza
24.food_rice
25.detergent
26.soap
27.sauce
28.clothes_gloves
29.cd
30.food_jam
31.food_carrot
32.food_orange
33.clothes_shirt
34.food_food
35.towel
36.bowl
37.food_apple
38.food_dessert
39.food_bacon
40.cat
41.wall_clock
42.food_kiwi
43.clothes_underwear
44.food_fruit
45.food_sugar
46.clothes_socks
47.food_hamburger
48.keyboard
49.headset
50.fork
51.towel_rack
52.remote_control
53.clothes_hat
54.dry_pasta
55.food_noodles
56.food_salt
57.food_chicken
58.cup
59.food_banana
60.coffee_filter
61.toilet_paper
62.spectacles
63.food_cake
64.food_peanut_butter
65.clothes_scarf
66.food_donut
67.pencil
68.food_lemon
69.food_potato
70.oil
71.hairbrush
72.food_snack
73.pot
74.drawing
75.food_egg
76.milk
77.clothes_skirt
78.clothes_dress
79.fryingpan
80.phone
81.food_turkey
82.food_cheese
83.food_bread
84.iron

## Task Instructions:
I have a goal that needs to be accomplished, and I have provided some additional information to support this goal. To achieve the goal, I have proposed a goal representation. By parsing this goal representation, I can obtain the sequence of actions needed to complete the goal. Currently, there are some objects in the environment whose locations are unknown to me. I need you to use common sense, based on my goal, to help me determine which of these objects might be relevant to my task, and then help me select these objects and return the corresponding object numbers.

## Output Format:
You only need to output a list of item numbers in the form of: [a,b,c,...]. Please do not provide any explanations or descriptions.

## Example:
when the goal is: Cut a tomato and put it in the bowl.
The additional information is: The tomato is in the fridge.
The goal representation is:
behavior find_tomato(fridge:item, tomat:item):
    body:
        achieve_once open(fridge)
        achieve inhand(tomato)
        achieve_once closed(fridge)

behavior cut_tomato(tomato:item):
    body:
        achieve cut(tomato)

behavior put_tomato_in_bowl(tomato:item, bowl:item):
    body:
        achieve inside(tomato, bowl)
    
behavior __goal__():
    body:
        bind tomato:item where:
            is_tomato(tomato)
        bind fridge:item where:
            is_fridge(fridge)
        bind bowl:item where:
            is_bowl(bowl)
        find_tomato(fridge, tomato)
        cut_tomato(tomato)
        put_tomato_in_bowl(tomato, bowl)
        
The unknown categories are:
0. bread
1. onion
2. bacon
3. faucet
4. chair
5. stove
6. knife
7. spatula
8. sugar
9. countertop
10. water
11. oil
12. salt
13. pepper
14. curtain
15. book
16. tomato
17. egg
18. pan
19. bowl

Your output should be: [6,16,19]

Example Analysis:
In the goal, additional information, and goal representation, the three items tomato, bowl, and fridge are mentioned. However, note that in the unknown categories, only tomato and bowl appear, which means fridge is a known item and therefore does not need to be selected. But pay special attention to the fact that the list of case outputs includes 6, which is a knife. Although this item is not explicitly mentioned in the goal, additional information, and goal representation, based on your common sense, you can infer that if you want to cut a tomato, you need a tool to cut the tomato, and a knife is a very likely tool. So, based on common sense, you also need to select this item. Additionally, please note that the output should only contain a list with numbers, and no extra information is needed. If you think no items need to be output, just output "None". But please boldly guess items that might be useful.


Response:
[4, 57]

Tokens: 1351
################################################################################

System: You are an assistant robot with excellent common sense. Now, I need your to tell me the most likely place that I can find the knife_2050.
Content: I will provide you with my task objectives and some additional information. Most of this information might be useless, but it could include some location data that may help you find my target item. So please refer to this information and make your own judgment. But remember, your output should only be an integer, and do not analyze or explain the content.
Your Goal is:Slice the chicken.
Additional Information:No additional information.
# Find knife_2050:
The possible locations are:
0. stove_2065
1. ceilinglamp_224
2. bed_105
3. bathroom_counter_41
4. closetdrawer_158
5. closetdrawer_154
6. trashcan_99
7. closetdrawer_380
8. light_169
9. wallshelf_35
10. tablelamp_98
11. curtain_180
12. closetdrawer_118
13. washing_machine_2007
14. orchid_178
15. bench_227
16. basket_for_clothes_2006
17. shower_36
18. desk_104
19. bookshelf_233
20. curtain_181
21. closetdrawer_119
22. tablelamp_97
23. curtain_408
24. cupboard_229
25. powersocket_246
26. kitchen_counter_230
27. photoframe_185
28. wallshelf_235
29. toilet_37
30. computer_170
31. table_355
32. home_office_319
33. faucet_43
34. filing_cabinet_399
35. closetdrawer_148
36. closetdrawer_122
37. window_86
38. cutting_board_2051
39. orchid_244
40. stovefan_288
41. dresser_108
42. curtain_407
43. oven_295
44. couch_352
45. coffee_table_2068
46. window_348
47. walllamp_27
48. bathroom_cabinet_40
49. bench_228
50. closetdrawer_143
51. doorjamb_165
52. photoframe_285
53. walllamp_28
54. wallshelf_234
55. faucet_232
56. light_245
57. tvstand_225
58. curtain_179
59. bookshelf_101
60. curtain_25
61. doorjamb_347
62. dresser_123
63. shower_38
64. desk_357
65. closetdrawer_160
66. sink_42
67. cpuscreen_416
68. fridge_289
69. curtain_39
70. curtain_23
71. closetdrawer_382
72. light_64
73. nightstand_102
74. closetdrawer_377
75. closetdrawer_116
76. dresser_358
77. ironing_board_2074
78. bookshelf_354
79. closetdrawer_394
80. mousepad_414
81. closetdrawer_121
82. door_44
83. closetdrawer_120
84. computer_417
85. microwave_297
86. sink_231
87. cpuscreen_171
88. dishwasher_1001
89. light_411
90. closetdrawer_384
91. closetdrawer_117
92. ceilinglamp_223
93. doorjamb_346
94. doorjamb_45
95. photoframe_430
96. closetdrawer_392
97. closetdrawer_150
98. toaster_292
99. closetdrawer_146
100. curtain_24
101. door_222
102. coffe_maker_290
103. curtain_409
104. mousepad_167
105. television_248
106. bathtub_30
107. nightstand_100
108. ceilinglamp_349
109. walllamp_350
110. walllamp_29
111. tvstand_353
112. walllamp_351
113. table_107
114. ceilinglamp_96
115. window_63
116. television_410
117. ceilinglamp_26
118. table_226
119. closetdrawer_388
120. powersocket_412
Please only output the number of the most likely position you choose. Do not provide any explanations or comments, just output an integer.

Response:
26

Tokens: 972
################################################################################

System: You are an assistant robot with excellent common sense. Now, I need your to tell me the most likely place that I can find the food_chicken_2017.
Content: I will provide you with my task objectives and some additional information. Most of this information might be useless, but it could include some location data that may help you find my target item. So please refer to this information and make your own judgment. But remember, your output should only be an integer, and do not analyze or explain the content.
Your Goal is:Slice the chicken.
Additional Information:No additional information.
# Find food_chicken_2017:
The possible locations are:
0. stove_2065
1. ceilinglamp_224
2. bed_105
3. bathroom_counter_41
4. closetdrawer_158
5. closetdrawer_154
6. trashcan_99
7. closetdrawer_380
8. light_169
9. wallshelf_35
10. tablelamp_98
11. curtain_180
12. closetdrawer_118
13. washing_machine_2007
14. orchid_178
15. bench_227
16. basket_for_clothes_2006
17. shower_36
18. desk_104
19. bookshelf_233
20. curtain_181
21. closetdrawer_119
22. tablelamp_97
23. curtain_408
24. cupboard_229
25. powersocket_246
26. kitchen_counter_230
27. photoframe_185
28. wallshelf_235
29. toilet_37
30. computer_170
31. table_355
32. home_office_319
33. faucet_43
34. filing_cabinet_399
35. closetdrawer_148
36. closetdrawer_122
37. window_86
38. cutting_board_2051
39. orchid_244
40. stovefan_288
41. dresser_108
42. curtain_407
43. oven_295
44. couch_352
45. coffee_table_2068
46. window_348
47. walllamp_27
48. bathroom_cabinet_40
49. bench_228
50. closetdrawer_143
51. doorjamb_165
52. photoframe_285
53. walllamp_28
54. wallshelf_234
55. faucet_232
56. light_245
57. tvstand_225
58. curtain_179
59. bookshelf_101
60. curtain_25
61. doorjamb_347
62. dresser_123
63. shower_38
64. desk_357
65. closetdrawer_160
66. sink_42
67. cpuscreen_416
68. fridge_289
69. curtain_39
70. curtain_23
71. closetdrawer_382
72. light_64
73. nightstand_102
74. closetdrawer_377
75. closetdrawer_116
76. dresser_358
77. ironing_board_2074
78. bookshelf_354
79. closetdrawer_394
80. mousepad_414
81. closetdrawer_121
82. door_44
83. closetdrawer_120
84. computer_417
85. microwave_297
86. sink_231
87. cpuscreen_171
88. dishwasher_1001
89. light_411
90. closetdrawer_384
91. closetdrawer_117
92. ceilinglamp_223
93. doorjamb_346
94. doorjamb_45
95. photoframe_430
96. closetdrawer_392
97. closetdrawer_150
98. toaster_292
99. closetdrawer_146
100. curtain_24
101. door_222
102. coffe_maker_290
103. curtain_409
104. mousepad_167
105. television_248
106. bathtub_30
107. nightstand_100
108. ceilinglamp_349
109. walllamp_350
110. walllamp_29
111. tvstand_353
112. walllamp_351
113. table_107
114. ceilinglamp_96
115. window_63
116. television_410
117. ceilinglamp_26
118. table_226
119. closetdrawer_388
120. powersocket_412
Please only output the number of the most likely position you choose. Do not provide any explanations or comments, just output an integer.

Response:
68

Tokens: 976
################################################################################

System: I have a goal described in natural language, and I need it converted into a structured format.
Content: 
## Task Description: 
I have a long horizon task: slice some chicken To approach this task effectively, I’ve divided it into several sub-tasks. The goal of the current sub-task is: Slice the chicken. The sub-tasks I have already completed include: None, it is the first sub-task. Additionally, I’ve gathered the following information to assist in completing this task: None.

## Instructions: 
Focus on the current sub-task's goal. Please analyze this goal and the additional information provided. Referring to the example I’ve shared, transform my sub-task goal into a formal representation that conforms to the specified syntax. Your output should include multiple behaviors, where each behavior’s body outlines intermediate states, intermediate relationships, final states, and final relationships necessary to achieve the goal. There is no need to define the actions required to reach the sub-task goal. Once you specify the intermediate and final states and relationships, my algorithm will independently plan a feasible sequence of actions.

## Precautions:
- Ensure that the states, relationships, properties, and keywords used do not exceed the scope I provided. (Available states, relationships, properties, and keywords are listed below.)
- If you invoke a function, ensure it’s properly defined, and include any necessary parameters when calling it.
- When using the keyword achieve, it must only be followed by terms defined under ## Available States or ## Available Relationships. It is strictly prohibited to follow achieve with properties, custom symbols, or functions.
- The behavior __goal__(): is required and functions similarly to the main function in Python; it should typically be placed at the end of your output without any parameters.

## Available States:
Please note: The text following each hash symbol (#) is a comment and should not be included in the current sub-task goal representation. 
- is_on(x: item) # The item is turned on.
- is_off(x: item) # The item is turned off.
- plugged(x: item) # The item is plugged in.
- unplugged(x: item) # The item is unplugged.
- open(x: item) # The item is open.
- closed(x: item) # The item is closed.
- dirty(x: item) # The item is dirty.
- clean(x: item) # The item is clean.
- has_water(x: item) # The item has water inside or on it.
- cut(x: item) # The item is cut.
- inhand(x: item) # A item is grasped by a character. Only use it when an item needs to be continuously held in your hand.
- has_a_free_hand(x: character) # The character has a free hand.
- visited(x: item) # The character has observed the item
Important Note: The inhand(x) state is unique. If you intend to use inhand(x), you must implement it using the achieve_once keyword. At the same time, please note that you can take at most two items. Having too many items in hand will result in no solution.

## Available Relationships:
Please note: The text following each hash symbol (#) is a comment and should not be included in the current sub-task goal representation. 
- on(x: item, y: item) # item x is on top of item y
- inside(x: item, y: item) # item x is inside item y, and y should be a room or a container
- inside_char(x: character, y: item) # character is inside item y (Character is you self. Any other animal like cat is an item)
- close(x: item, y: item) # item x is close to item y
- close_char(x: character, y: item) # character is close to item y (Character is you self. Any other animal like cat is an item)
Important Usage Notes: In relationships with the '_char' suffix, the first parameter must always be a char. For example, 'inside' and 'inside_char', 'close' and 'close_char'.

## Available Properties:
Please note: The text following each hash symbol (#) is a comment and should not be included in the current sub-task goal representation.
- surfaces(x: item) #  Indicates that the item has a surface where things can be placed, such as a kitchen countertop or table.
- grabbable(x: item) # Indicates that the item can be grabbed by hand.
- hangable(x: item) # Indicates that the item can be hung on.
- drinkable(x: item) # Indicates that the item can be drunk.
- eatable(x: item) # Indicates that the item can be eaten.
- recipient(x: item) # Indicates that the item can receive something.
- cuttable(x: item) # Indicates that the item can be cut with a knife.
- pourable(x: item) # Indicates that the item can be poured into another container or onto other items.
- can_open(x: item) # Indicates that the item can be opened.
- has_switch(x: item) # Indicates that the item has a switch to turn it on or off.
- readable(x: item) # Indicates that the item can be read.
- lookable(x: item) # Indicates that the item can be looked at.
- containers(x: item) # Indicates that the item is a container.
- has_plug(x: item) # Indicates that the item has a plug.
- movable(x: item) # Indicates that the item can be moved.
- is_clothes(x: item) # Indicates that the item is clothing.
- is_food(x: item) # Indicates that the item is food.
Important Notes: "propertie" cannot be assigned a value nor can it be used after "achieve".; they can only return a boolean value as a predicate. For example, an apple can be grabbed, so grabbable(apple) will return true. Properties are typically used in if conditions.
Common Errors:
achieve can_open(door) # Incorrect. Properties cannot be used after achieve as they cannot have their values modified.
has_plug(lamp) = True # Incorrect. You cannot assign a value to a property, as they are immutable.

# Available Behaviors:
Please note: The text following each hash symbol (#) is a comment and should not be included in the current sub-task goal representation.
The following behaviors can be directly invoked in the current sub-task goal representation, with parameters passed in like function arguments.
- observe(obj:item,question:string) # observe is a special behavior used to inspect an object. You can specify the purpose of your inspection with a string. By calling observe, you can learn about the state of an object as well as its relationship with surrounding objects. After observing an item, it will be marked as visited. Note that the second parameter of observe is a string and must be enclosed in double quotes("").
- wash(obj:item) # Wash an item by hand.
- scrub(obj:item) # Scrub an item.
- wipe(obj:item) # Wipe an item.
- squeeze(obj:item) # Squeeze an item.
- rinse(obj:item) # Rinse an item.
- move(obj:item) # Move an item.
- pull(obj:item) # Pull an item.
- push(obj:item) # Push an item.
- type(obj:item) # Type on an item.
- touch(obj:item) # Touch an item.
- read(obj:item) # Read an item.
Important Note: Ensure that all parameters are properly defined before using them in the behaviors.

## Available Category Determination:
- is_mat(x: item)
- is_drawing(x: item)
- is_food_bread(x: item)
- is_bedroom(x: item)
- is_couch(x: item)
- is_chair(x: item)
- is_stovefan(x: item)
- is_clothes_scarf(x: item)
- is_cpuscreen(x: item)
- is_coffee_filter(x: item)
- is_oven(x: item)
- is_cd_player(x: item)
- is_food_vegetable(x: item)
- is_food_hamburger(x: item)
- is_mouse(x: item)
- is_soap(x: item)
- is_clothes_dress(x: item)
- is_dvd_player(x: item)
- is_food_donut(x: item)
- is_ceilinglamp(x: item)
- is_book(x: item)
- is_cup(x: item)
- is_food_rice(x: item)
- is_cupboard(x: item)
- is_food_kiwi(x: item)
- is_food_cereal(x: item)
- is_food_snack(x: item)
- is_mousepad(x: item)
- is_ironing_board(x: item)
- is_food_pizza(x: item)
- is_fridge(x: item)
- is_faucet(x: item)
- is_clothes_pants(x: item)
- is_towel(x: item)
- is_orchid(x: item)
- is_food_fish(x: item)
- is_nightstand(x: item)
- is_food_steak(x: item)
- is_toaster(x: item)
- is_door(x: item)
- is_dining_room(x: item)
- is_curtain(x: item)
- is_table(x: item)
- is_food_apple(x: item)
- is_bathroom(x: item)
- is_home_office(x: item)
- is_desk(x: item)
- is_tvstand(x: item)
- is_dishwasher(x: item)
- is_food_sugar(x: item)
- is_basket_for_clothes(x: item)
- is_bowl(x: item)
- is_dry_pasta(x: item)
- is_sauce(x: item)
- is_oil(x: item)
- is_kitchen_counter(x: item)
- is_clothes_hat(x: item)
- is_powersocket(x: item)
- is_knife(x: item)
- is_doorjamb(x: item)
- is_food_onion(x: item)
- is_bathtub(x: item)
- is_food_dessert(x: item)
- is_clothes_socks(x: item)
- is_food_chicken(x: item)
- is_clothes_jacket(x: item)
- is_closetdrawer(x: item)
- is_pillow(x: item)
- is_bench(x: item)
- is_bathroom_cabinet(x: item)
- is_food_ice_cream(x: item)
- is_vacuum_cleaner(x: item)
- is_cat(x: item)
- is_trashcan(x: item)
- is_bookshelf(x: item)
- is_shower(x: item)
- is_walllamp(x: item)
- is_spectacles(x: item)
- is_bathroom_counter(x: item)
- is_milk(x: item)
- is_clothes_underwear(x: item)
- is_ceiling(x: item)
- is_towel_rack(x: item)
- is_food_potato(x: item)
- is_toilet(x: item)
- is_clothes_shirt(x: item)
- is_cleaning_solution(x: item)
- is_iron(x: item)
- is_floor(x: item)
- is_food_carrot(x: item)
- is_fryingpan(x: item)
- is_bed(x: item)
- is_hairbrush(x: item)
- is_food_salt(x: item)
- is_clothes_gloves(x: item)
- is_keyboard(x: item)
- is_remote_control(x: item)
- is_microwave(x: item)
- is_dresser(x: item)
- is_food_oatmeal(x: item)
- is_pot(x: item)
- is_food_orange(x: item)
- is_coffee_table(x: item)
- is_food_food(x: item)
- is_fork(x: item)
- is_napkin(x: item)
- is_toilet_paper(x: item)
- is_food_egg(x: item)
- is_light(x: item)
- is_tray(x: item)
- is_sink(x: item)
- is_wall_clock(x: item)
- is_food_peanut_butter(x: item)
- is_photoframe(x: item)
- is_coffe_maker(x: item)
- is_food_jam(x: item)
- is_headset(x: item)
- is_clothes_skirt(x: item)
- is_wall(x: item)
- is_food_turkey(x: item)
- is_food_cheese(x: item)
- is_filing_cabinet(x: item)
- is_washing_machine(x: item)
- is_food_cake(x: item)
- is_window(x: item)
- is_computer(x: item)
- is_plate(x: item)
- is_wallshelf(x: item)
- is_television(x: item)
- is_food_fruit(x: item)
- is_cutting_board(x: item)
- is_detergent(x: item)
- is_phone(x: item)
- is_tablelamp(x: item)
- is_food_banana(x: item)
- is_food_lemon(x: item)
- is_hanger(x: item)
- is_food_bacon(x: item)
- is_stove(x: item)
- is_cd(x: item)
- is_food_noodles(x: item)
- is_pencil(x: item)

For any instance 'x', you can use 'is_y(x)' to determine if 'x' belongs to category 'y'. Categories cannot be operated upon directly; you can only assess the status and relationships of specific instances within a category. If you want to select an item instance that belongs to the category "box", you can use the following syntax:

bind b: item where:
    is_box(b)

Important Notes:
If the category you need is not in the available list, try to find a synonym or a similar category with a closely related function.
Examples:
- food -> is_food_food(): If 'is_food' is not available, but 'is_food_food' is, use the latter as they have similar meanings.
- soapy_water -> is_cleaning_solution(): If 'soapy_water' is not available, but 'cleaning_solution' is, use the latter as they are functionally similar.

## Syntax Rules and Keywords:
"char" is a constant instance representing a character (yourself) and we assume that other animals like cat is an item. The type "character" can only be used when defining an instance. Use "char" consistently when passing parameters, and use "character" when defining a variable and specifying its type.

Below are all the keywords you can use to convert information into a structured format. Please ensure that you do not use any keywords other than those listed here.

Keywords:
# bind
# Usage: Randomly select an item that satisfies the specified conditions and assign it to a variable. If no item meets the condition, the program will fail. Therefore, avoid setting overly strict conditions unless you are certain that a corresponding item exists. The condition is_x will always be satisfied as long as x is specified in Available Category Determination. However, exercise caution when adding additional conditions.To maintain consistency, try to use 'bind' primarily in the '__goal__' behavior and pass the retrieved instances as parameters to invoked behaviors. Avoid using 'bind' in other behaviors whenever possible.
Example:
bind x: item where:
    is_light(x)

Multiple Items Example: Ensure that subsequent items are not the same as those previously bound.
bind apple1: item where:
    is_apple(apple1)
bind apple2: item where:
    is_apple(apple2) and apple1!=apple2
bind apple3: item where:
    is_apple(apple3) and apple1!=apple3 and apple2!=apple3

# achieve
# Usage: Specifies the state or relationship that a behavior consistently aims to maintain from start to finish. Only states and relationships can follow 'achieve', not types, properties, or other immutable content. Do not call functions or behaviors after 'achieve'; instead, call functions directly without keywords. Note that 'achieve' cannot be used with the state 'inhand'. And note that 'achieve' must be followed by a single state or relationship, not a combination of states or relationships.
Examples: 
achieve is_on(light) # it is used to turn on the light.
achieve has_water(cup) # it is used to fill the cup with water.
achieve has_water(pot) # it is used to fill the pot with water.
achieve cut(apple) # it is used to cut the apple.
achieve on(apple, plate) # it is used to place the apple on the plate.
achieve inside(oil, pan) # it is used to add oil into the pan.

# achieve_once
# Usage: Specifies a temporary state or relationship that needs to be achieved only once, without maintaining it until the end of the behavior.
Example: achieve_once inhand(apple) #Please note that 'inhand' must be used with 'achieve_once.'

# foreach
# Usage: Iterates over all objects. Do not use 'where' in a 'foreach' statement. Additionally, do not nest one foreach inside another, as this will cause the program to fail.
Correct example:
foreach o: item:
    if can_open(o) and is_box(o):
        achieve closed(o)

Incorrect example:
foreach o: item where:
    if can_open(o) and is_box(o):
        achieve closed(o)

# behavior
# Usage: Defines a behavior rule. The keyword 'body' must appear in the behavior, and all parameters used in the 'goal' must be included in the behavior's parameters.

# goal
# Usage: Specifies the goal condition for a behavior. If you want to use the goal, please ensure that you include all the parameters used in the 'goal' in the behavior parameters.

# body
# Usage: Contains the sequence of intermediate states and relationships necessary to achieve the behavior’s goal.

# if-else
# Usage: Conditional statement for branching logic. Only simple first-order logic or combinations of first-order logic are allowed after if-else. Note that elif is not supported.
if condition:
    achieve has_water(a)
else:
    achieve clean(b)

# exists
# Usage: Checks if there is at least one object that meets the condition and returns a boolean value.
Template: exists obj_name: objtype : condition()
Example: exists item1: item : holds_lh(char, item1)

# symbol
# Usage: Defines a symbol and binds it to the output of an expression. You can only use the symbol in the following manner:
symbol has_cutting_board=exists item1:item: (is_cutting_board(item1))

# def
# Usage: Defines a function that can be used to check a condition. 

## Background Knowledge:
In general, you only know part of the information in a given scenario. For example, you might know that a certain piece of clothing is in a particular basket, but you might not know what is in a certain basket. Therefore, many times, you need to first perform a goal conversion based on what you already know. When you lack some information, you can observe and obtain the information you want by using obs(target_item, information).
For example, if you want to know if there are clothes in the basket_34, you can use:
bind basket: item where:
    is_basket(basket) and id[basket]==34
observe(basket,"Check is there any clothes in the basket")

If you want to know Is there any trash in the trash can in the dining room, you can use:

bind dining_room: item where:
    is_dining_room(dining_room)

bind trash_can: item where:
    is_trash_can(trash_can) and inside(trasn_can, dining_room) # Since you already know that the trash can is located in the dining room, you can include the condition inside(trash_can, dining_room). However, if the location of the trash can is unknown, this condition must be omitted.
observe(trash_can,"Check is there any trash in the trash can")

## Examples:
# Example-1-1:
Current sub-task goal: 1. Find a table with food.
The completed sub-tasks: None, it is the first sub-task.
Additional information: None.
Long-horizon task: Clean up the food on the table.
Chain of thought: Your current sub-task goal is to find a table with food on it, which is the first step towards completing the long-horizon task. According to the background knowledge, your first step should be to check if there is a known table with food on it. To do this, you need to determine whether there is food on a table. You can create a function called 'has_food_on_table(table:item)', which returns the result of the expression 'exists o: item : is_food(o) and on(o, table)'. This expression checks if there is an item classified as food that is on the table, according to your known information.
Next, you can use the expression 'exists table: item : is_table(table) and has_food_on_table(table)' to verify if there is a table with food on it in the known information. If such a table exists, there is no need to continue searching; you can immediately use 'achieve close_char(char, table)' to have the character approach the table with food.
However, if your known information does not confirm the presence of a table with food on it, you will need to inspect all unvisited items in the scene categorized as tables. To do this, you should call the 'observe' behavior to check each table. The first parameter of the 'observe' behavior should be the table you intend to inspect, and the second parameter should be the purpose of the inspection. Remember, the second parameter must be a string enclosed in double quotes ("").

Output:
def has_food_on_table(table:item):
    # Function to check if there is food on the specified table.
    symbol has_food=exists o: item : (is_food(o) and on(o, table))
    return has_food

behavior __goal__():
    body:
        if exists table: item : is_table(table) and has_food_on_table(table):
            # Check if there is a table with food based on the available information.
            bind table: item where:
                is_table(table) and has_food_on_table(table) # The condition has_food_on_table can only be used when you are certain that there is food on the table. In this case, you can be confident because you have already verified it with an if condition.
            # Select a table that has food on it.
            achieve close_char(char, table) 
            # Move the character closer to the table with food.

        else: 
           # If no table with food is found, initiate exploration to locate one.
            foreach table: item:
                if is_table(table) and not visited(table):
                    # Check all unvisited tables.
                    observe(table,"Check is there any food on the table")
                    # Observe whether each table has any food.
            
# Example-1-2:
Current sub-task goal: 2. Put the food in the appropriate storage locations.
The completed sub-tasks: 1. Find a table with food.
Additional information: 
1. There is no food on table 107. 
2. No food is find on the table 355, please see other tables.
3. food_peanut_butter_2008 and food_kiwi_2012 are on the table_226.
Long-horizon task: Clean up the food on the table.

Chain of thought: You have already find the table with food. Now, your current sub-task goal is to store the food on the table in the appropriate location. According to the additional information, there is no food on table_107 and table_355. However, table_226 has food_peanut_butter and food_kiwi.You can use the 'bind' keyword along with the condition 'is_table(table) and id[table] == 226' to obtain the table with the ID 226. You can also use the 'bind' keyword with the condition 'is_food_peanut_butter(food_peanut_butter)' to obtain the peanut butter. And use 'bind' keyword with the condition 'is_food_kiwi(food_kiwi)' to obtain the kiwi. Since the sub-task goal and additional information do not specify where exactly to store the food, you need to use common sense to make a decision based on the items present in the scene. Based on common sense, both food_peanut_butter and food_kiwi may require refrigeration, and since there is a fridge available in the scene, the goal is to store them in the fridge. Although it is not explicitly stated, it is common sense to ensure that the fridge door is closed after storing food inside. Therefore, you can use achieve closed(fridge) to perform the action of closing the fridge door.

Output:
behavior store_in_fridge(food:item, fridge:item):
    body:
        achieve inside(food, fridge)
        # Place the food item inside the fridge.

behavior close_the_fridge_door(fridge:item):
    body:
        achieve closed(fridge)
        # Close the fridge door.

behavior __goal__():
    body:
        bind table: item where:
            is_table(table) and id[table]==226
        # Select table with ID 226.

        bind food_peanut_butter: item where:
            is_food_peanut_butter(food_peanut_butter)
        # Select peanut butter.

        bind food_kiwi: item where:
            is_food_kiwi(food_kiwi)
        # Select kiwi on the table.
        
        bind fridge: item where:
            is_fridge(fridge)
        store_in_fridge(food_peanut_butter, fridge)
        store_in_fridge(food_kiwi, fridge)
        close_the_fridge_door(fridge)

# Example-1-3:
Current sub-task goal: 2. Put the food in the appropriate storage locations.
The completed sub-tasks: 1. Find a table with food.
Additional information: 
1. There is no food on table 107. 
2. No food is find on the table 355, please see other tables.
3. food_peanut_butter_2008 and food_kiwi_2012 are on the table_226.
4. The peanut butter is expired, so I want to throw it away. I want to cut the kiwi and then store it in the fridge.
Long-horizon task: Clean up the food on the table.

Chain of thought: According to Additional information 4, you need to discard the peanut butter. Observing that there is an "is_trashcan" in the Available Category, you can infer that there is a trashcan in the scene, and the expired peanut butter can be thrown into the trashcan. Additional information 4 also requires that the kiwi be cut, and then stored in the fridge. You need to use "achieve cut(food_kiwi)" to cut the kiwi. After that, you can "achieve inside(food_kiwi, fridge)" to store the kiwi in the fridge. To ensure the completeness of the task, you also need to use "achieve closed(fridge)" to make sure the fridge door is closed at the end by "achieve closed(fridge)".

Output:
behavior throw_in_trash(food:item, trashcan:item): 
# Define the behavior to throw food into the trash can
    body:
        achieve inside(food, trashcan)
        
behavior cut_food(food:item):
    body:
        achieve cut(food)

behavior store_in_fridge(food:item, fridge:item):
    body:
        achieve inside(food, fridge)

behavior close_the_fridge_door(fridge:item):
    body:
        achieve closed(fridge)

behavior __goal__():
    body:
        bind table: item where:
            is_table(table) and id[table]==226
        # Select table with ID 226.
        bind food_peanut_butter: item where:
            is_food_peanut_butter(food_peanut_butter)
        # Select peanut butter on the table.
        bind food_kiwi: item where:
            is_food_kiwi(food_kiwi)
        # Select kiwi on the table.
        bind trashcan: item where:
            is_trashcan(trashcan)
        # Select a trash can.
        bind fridge: item where:
            is_fridge(fridge)
        # Select a fridge.
        throw_in_trash(food_peanut_butter, trashcan)
        cut_food(food_kiwi)
        store_in_fridge(food_kiwi, fridge)
        close_the_fridge_door(fridge)
          
# Example-2-1:
Current sub-task goal: 1. Find the sink with plates and cups.
The completed sub-tasks: None, it is the first sub-task.
Additional information: None.
Long-horizon task: Wash the plates and cups in the sink using the dishwasher. Then put them on the table in kitchen.

Chain of thought: Your current sub-task goal is to find the sink with plates and cups, which is the first step toward completing the long-horizon task: "Wash the plates and cups in the sink using the dishwasher. Then put them on the table in the kitchen."
To achieve this, you first need to determine whether there are plates or cups in the sink. You can design a function called 'has_plate_or_cup_in_sink(sink:item)' that checks for this. The function should return the result of the expression 'exists o: item : (is_plate(o) or is_cup(o)) and inside(o, sink)', which verifies if there is an item that is either a plate or a cup and is located inside the sink in your known information.
Next, you can use 'exists sink: item : is_sink(sink) and has_plate_or_cup_in_sink(sink)' to check if there is a sink with plates or cups in it within the known information. If such a sink is found, there's no need to search further; you can immediately use 'achieve close_char(char, sink)' to have the character approach the sink containing the plates or cups.
However, if your known information does not confirm the presence of a sink with plates or cups, you will need to check all unvisited items categorized as sinks in the scene. For this, you should call the 'observe' behavior to inspect each sink. The first parameter of the 'observe' behavior should be the sink you intend to check, and the second parameter should be the purpose of the inspection. Remember, the second parameter must be a string enclosed in double quotes ("").

Output:
def has_plate_or_cup_in_sink(sink:item):
    # Function to check if there are plates or cups in a specified sink.
    symbol has_plate_or_cup=exists o: item : ((is_plate(o) or is_cup(o)) and inside(o, sink))
    return has_plate_or_cup

behavior __goal__():
    body:
        if exists sink: item : is_sink(sink) and has_plate_or_cup_in_sink(sink):
            # If we have already found the sink with plates or cups, we can directly approach it
            bind sink: item where:
                is_sink(sink) and has_plate_or_cup_in_sink(sink)
            achieve close_char(char, sink)

        else:
            # Check all sinks in the scene that have not been visited
            foreach sink: item:
                if is_sink(sink) and not visited(sink):
                    observe(sink,"Check is there any plate or cup in the sink")

# Example-2-2:
Current sub-task goal: 2. Wash the plates and cups using the dishwasher.
The completed sub-tasks: 1. Find the sink with plates and cups.
Additional information: 
1. sink_42 is in the bathroom, and no plates or cups are found in it.
2. sink_231 is in the kitchen, and there are plates and cups in it.
Long-horizon task: Wash the plates and cups in the sink using the dishwasher. Then put them on the table in kitchen.

Chain of thought:
According to additional information, sink_42 does not contain plates or cups, while sink_231 does contain plates or cups. Now you have found the sink that contains plates or cups. The current sub-task's goal is "Wash the plates and cups using the dishwasher." Although it doesn't explicitly state that the plates and cups in the sink need to be cleaned, considering the objective of the long-horizon task, the actual goal of the current sub-task should be to clean the plates and cups in the sink. To clean the plates and cups in the sink using the dishwasher, you first need to load them into the dishwasher. Since it is unclear how many plates and cups are in the sink, the foreach keyword is used with the condition if is_plate(o) or is_cup(o) and inside(o, sink) to place all items that are plates or cups from the sink into the dishwasher. After that, you can execute achieve closed(dishwasher) and achieve is_on(dishwasher) sequentially to start the dishwasher.

Output:
behavior load_dishwasher(o:item, dishwasher:item):
    body:
        achieve inside(o, dishwasher)
        # Place the item inside the dishwasher.

behavior start_dishwasher(dishwasher:item):
    body:
        achieve closed(dishwasher) # Close the dishwasher door.
        achieve is_on(dishwasher) # Turn on the dishwasher.

behavior __goal__():
    body:
        bind sink: item where:
            is_sink(sink) and id[sink]==231
        # Select sink with ID 231.
        bind dishwasher: item where:
            is_dishwasher(dishwasher)
        # Select a dishwasher.
        foreach o: item:
        # Load all plates and cups from the sink into the dishwasher.
            if is_plate(o) or is_cup(o) and inside(o, sink):
                load_dishwasher(o, dishwasher)
        start_dishwasher(dishwasher) # Start the dishwasher.

# Example-2-3:
Current sub-task goal: 3. Put the plates and cups on the table in the kitchen.
The completed sub-tasks: 1. Find the sink with plates and cups. 2. Wash the plates and cups using the dishwasher.
Additional information: 
1. plate_1000, plate_1001, cup_1002, cup_1003 is cleaned by dishwasher_2000.
Long-horizon task: Wash the plates and cups in the sink using the dishwasher. Then put them on the table in kitchen.

Chain of thought:
According to "The completed sub-tasks" and "Additional information," the plates and cups that need to be placed on the table have already been cleaned in a dishwasher, and they are currently in a dishwasher with an ID of 2000. The current sub-task requires you to place the plates and cups on a table located in the kitchen. There may be more than one table in the scene, so you need to design a function 'in_kitchen(table: item)' that returns the value of the expression 'exists room: item : is_kitchen(room) and inside(table, room)', which checks whether the given table is inside a kitchen. Next, you need to design a 'put_on_table' behavior to place the plates or cups on the table. To determine which table to use, you should apply 'put_on_table' to all the plates or cups that were originally in the dishwasher, placing them on the table. Finally, to ensure the dishwasher is properly reset, you can design a 'close_the_dishwasher' behavior to turn off and close the dishwasher.

Output:
def in_kitchen(table:item):
    # Function to check if a table is in the kitchen.
    symbol in_kitchen=exists room: item : (is_kitchen(room) and inside(table, room))
    return in_kitchen

def has_plates_or_cups_inside(dishwasher:item):
    # Function to check if there are plates or cups inside the dishwasher.
    symbol has_plates_or_cups=exists o: item : ((is_plate(o) or is_cup(o)) and inside(o, dishwasher))
    return has_plates_or_cups

behavior put_on_table(o:item, table:item):
    body:
        achieve on(o, table) # Place the item on the table.

behavior close_the_dishwasher(dishwasher:item):
    body:
        achieve is_off(dishwasher) # Turn off the dishwasher.
        achieve closed(dishwasher) # Close the dishwasher door.

behavior __goal__():
    body:
        bind table: item where:
            is_table(table) and in_kitchen(table)
        # Select a table in the kitchen.
        bind dishwasher: item where:
            is_dishwasher(dishwasher) and id[dishwasher]==2000
        # Select the dishwasher with ID 2000.
        foreach o: item:
        # Place all plates and cups originally in the dishwasher on the table.
            if is_plate(o) or is_cup(o) and inside(o, dishwasher):
                put_on_table(o, table)
        close_the_dishwasher(dishwasher) # Reset the dishwasher.

#Guidance-1:
A common mistake is ignoring the duration of "achieve." The duration of "achieve" persists until the current action is completed. If you specify two mutually exclusive states in a behavior using "achieve," it will result in a program error.

Here is some typical errors:
- error example:
behavior put_apple_on_table(apple:item,table:item):
    body:
        achieve inhand(apple)
        achieve on(apple,table)

Error Analysis: In this example, if you use achieve inhand(apple), then the apple must be keep inhand until the end of this behavior. Then you use achieve on(apple,table), which means you put the apple on the table. Now the apple should be both remain in hand and be placed on the table, which is impossible to achieve. The solution to this problem is to remove the unnecessary step of achieving inhand(apple), as the program will automatically determine how to achieve on(apple,table). In fact, unless you need to hold an item to complete a specific task (such as cutting vegetables with a knife or wiping a window with a cloth), please avoid using the "inhand" state in other situations.

A correct output for this example is:
behavior put_apple_on_table(apple:item,table:item):
    body:
        achieve on(apple,table)

# Guidance-2:
The following example demonstrates the difference between using foreach and bind.

Please note that bind requires the use of the "where keyword", while foreach must not use the "where" keyword under any circumstances.  
eg:
foreach c: item:
    if is_clothes(c) and inside(c,basket):
        achieve inside(c, washing_machine)

bind basket: item where:
    is_basket_for_clothes(basket)

You can see that the foreach statement is used without "where", while the bind statement needs to include "where".

# Guidance-3:
In some cases, there may be multiple instances of the same object type within a scene. Simply using 'is_category()' to constrain the object type might be insufficient for selecting a specific instance. To retrieve the desired object more precisely, there are generally two methods. 
1. Using the ID: If you know the instance's unique ID, you can directly reference it, for example:

bind dishwasher: item where:
    is_dishwasher(dishwasher) and id[dishwasher] == 2000.

2. Adding positional relationships: You can specify spatial relationships between instances, for example: 

bind table: item where:
    is_table(table) and inside(table, kitchen).

In more complex scenarios, you can follow the approach in Example 2-3 by designing a function that adds constraints to the bind operation, allowing you to accurately retrieve the target instance.
Example:
def in_kitchen(table:item):
    symbol in_kitchen=exists room: item : (is_kitchen(room) and inside(table, room))
    return in_kitchen
    ......
bind table: item where:
    is_table(table) and in_kitchen(table)

You can also use attributes, states, and other information to further refine your constraints for the bind operation. However, it is crucial to ensure that an object satisfying all conditions exists. If you add more conditions to the bind statement but no object meets all of them, the operation will fail. Therefore, be mindful of how constraints interact to avoid retrieval errors.

# Guidance-4:
The observe(obj:item, question:string) is a powerful but resource-intensive behavior. It allows you to examine an object based on observation, during which you need to specify what information you wish to obtain from the object. Due to the high cost of using observe, the quality of your questions is crucial for improving execution efficiency. Generally speaking, information such as the type of object or its state can be obtained by referring to the methods provided in 'Available Category Determination' and 'Available States', so you usually don't need to invoke the observe behavior for these details. Some situations where observe behavior is necessary include when you want to check what items are inside or on the item you observe. For example, if you want to see what's inside the oven, you can use 'observe(oven, "What's inside the oven?")', or if you want to check what's on the table, you can use 'observe(table, "check items on the table")'. Also, feel free to ask more questions in the observe behavior to get more detailed information. For example, If you want to check what's inside the oven and whether it's on the kitchen counter, you can use 'observe(oven, "What's inside the oven? Is it on the kitchen counter?")'.

# Guidance-5:
Try to avoid using the 'inhand(x:item)' state. In most cases, the program will automatically manage the 'inhand' operations. If you define 'inhand' manually, it can easily lead to a situation where the agent is holding too many items, causing the program to crash. There is generally only one situation where you need to declare the 'inhand' operation: when you have to hold certain items all the time to complete a specific task. For example, when cleaning a mirror with a towel, you need to use 'achieve_once inhand(towel)'. Other than this, please avoid defining the 'inhand' state. In some cases, the task information may not clearly specify where certain items should be placed, such as in "gathering the food." In these cases, use your common sense to place the food in an appropriate location, like achieve 'on(food, kitchen_counter)', to avoid the issue of holding too many items. If possible, ensure that the agent's hands are empty after each sub-task is completed.

# Guidance-6:
You can assume that all actions you execute are successful. Additionally, you do not need to worry about object size, as a properly sized object will always be found automatically.



## Output Requirements:
You need to think step by step to give resonable output. However, you can only output content similar to the 'Output' in the 'Example'. Do not include any explanation or any other symbols.


Response:
```plaintext
behavior slice_chicken(chicken:item, surface:item, knife:item):
    body:
        achieve on(chicken, surface) # Place the chicken on a suitable surface for slicing.
        achieve_once inhand(knife) # Hold the knife.
        achieve cut(chicken) # Slice the chicken using the knife.

behavior __goal__():
    body:
        bind chicken: item where:
            is_food_chicken(chicken) # Select the chicken to be sliced.
        
        bind surface: item where:
            surfaces(surface) # Select a suitable surface for slicing the chicken.
        
        bind knife: item where:
            is_knife(knife) # Select a knife for slicing the chicken.
        
        slice_chicken(chicken, surface, knife) # Execute the slicing operation.
```

Tokens: 9234
################################################################################

