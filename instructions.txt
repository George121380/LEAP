
## Task Description: 
I have a long horizon task: Make chicken pasta, put it in a plate. To approach this task effectively, I’ve divided it into several sub-tasks. The goal of the current sub-task is: 1. Cook the chicken and pasta separately. The sub-tasks I have already completed include: None, it is the first sub-task. Additionally, I’ve gathered the following information to assist in completing this task: None.

## Instructions: 
Focus on the current sub-task's goal. Please analyze this goal and the additional information provided. Referring to the example I’ve shared, transform my sub-task goal into a formal representation that conforms to the specified syntax. Your output should include multiple behaviors, where each behavior’s body outlines intermediate states, intermediate relationships, final states, and final relationships necessary to achieve the goal. There is no need to define the actions required to reach the sub-task goal. Once you specify the intermediate and final states and relationships, my algorithm will independently plan a feasible sequence of actions.

## Precautions:
- Ensure that the states, relationships, properties, and keywords used do not exceed the scope I provided. (Available states, relationships, properties, and keywords are listed below.)
- If you invoke a function, ensure it’s properly defined, and include any necessary parameters when calling it.
- When using the keyword achieve, it must only be followed by terms defined under ## Available States or ## Available Relationships. It is strictly prohibited to follow achieve with properties, custom symbols, or functions.
- The behavior __goal__(): is required and functions similarly to the main function in Python; it should typically be placed at the end of your output without any parameters.

## Available States:
Please note: The text following each hash symbol (#) is a comment and should not be included in the current sub-task goal representation. 
- is_on(x: item) # The item is turned on.
- is_off(x: item) # The item is turned off.
- plugged(x: item) # The item is plugged in.
- unplugged(x: item) # The item is unplugged.
- open(x: item) # The item is open.
- closed(x: item) # The item is closed.
- dirty(x: item) # The item is dirty.
- clean(x: item) # The item is clean.
- has_water(x: item) # The item has water inside or on it.
- cut(x: item) # The item is cut.
- inhand(x: item) # A item is grasped by a character. Only use it when an item needs to be continuously held in your hand.
- has_a_free_hand(x: character) # The character has a free hand.
- visited(x: item) # The character has observed the item
Important Note: The inhand(x) state is unique. If you intend to use inhand(x), you must implement it using the achieve_once keyword. At the same time, please note that you can take at most two items. Having too many items in hand will result in no solution.

## Available Relationships:
Please note: The text following each hash symbol (#) is a comment and should not be included in the current sub-task goal representation. 
- on(x: item, y: item) # item x is on top of item y
- on_char(x: character, y: item) # character is on item y (Character is you self. Any other animal like cat is an item)
- inside(x: item, y: item) # item x is inside item y, and y should be a room or a container
- inside_char(x: character, y: item) # character is inside item y (Character is you self. Any other animal like cat is an item)
- close(x: item, y: item) # item x is close to item y
- close_char(x: character, y: item) # character is close to item y (Character is you self. Any other animal like cat is an item)
Important Usage Notes: In relationships with the '_char' suffix, the first parameter must always be a char. For example, 'on' and 'on_char', 'inside' and 'inside_char', 'close' and 'close_char'.

## Available Properties:
Please note: The text following each hash symbol (#) is a comment and should not be included in the current sub-task goal representation.
- surfaces(x: item) #  Indicates that the item has a surface where things can be placed, such as a kitchen countertop or table.
- grabbable(x: item) # Indicates that the item can be grabbed by hand.
- sittable(x: item) # Indicates that the item can be sat on.
- lieable(x: item) # Indicates that the item can be lied on.
- hangable(x: item) # Indicates that the item can be hung on.
- drinkable(x: item) # Indicates that the item can be drunk.
- eatable(x: item) # Indicates that the item can be eaten.
- recipient(x: item) # Indicates that the item can receive something.
- cuttable(x: item) # Indicates that the item can be cut with a knife.
- pourable(x: item) # Indicates that the item can be poured into another container or onto other items.
- can_open(x: item) # Indicates that the item can be opened.
- has_switch(x: item) # Indicates that the item has a switch to turn it on or off.
- readable(x: item) # Indicates that the item can be read.
- lookable(x: item) # Indicates that the item can be looked at.
- containers(x: item) # Indicates that the item is a container.
- person(x: item) # Indicates that the item is a person.
- body_part(x: item) # Indicates that the item is a body part.
- cover_object(x: item)
- has_plug(x: item) # Indicates that the item has a plug.
- has_paper(x: item) # Indicates that the item contains paper.
- movable(x: item) # Indicates that the item can be moved.
- cream(x: item) # Indicates that the item is a cream.
- is_clothes(x: item) # Indicates that the item is clothing.
- is_food(x: item) # Indicates that the item is food.
Important Notes: "propertie" cannot be assigned a value nor can it be used after "achieve".; they can only return a boolean value as a predicate. For example, an apple can be grabbed, so grabbable(apple) will return true. Properties are typically used in if conditions or assert statements.
Common Errors:
achieve can_open(door) # Incorrect. Properties cannot be used after achieve as they cannot have their values modified.
has_plug(lamp) = True # Incorrect. You cannot assign a value to a property, as they are immutable.

# Available Behaviors:
Please note: The text following each hash symbol (#) is a comment and should not be included in the current sub-task goal representation.
The following behaviors can be directly invoked in the current sub-task goal representation, with parameters passed in like function arguments.
- observe(obj:item,question:string) # observe is a special behavior used to inspect an object. You can specify the purpose of your inspection with a string. By calling observe, you can learn about the state of an object as well as its relationship with surrounding objects. After observing an item, it will be marked as visited. Note that the second parameter of observe is a string and must be enclosed in double quotes("").
- wash(obj:item) # Wash an item by hand.
- scrub(obj:item) # Scrub an item.
- wipe(obj:item) # Wipe an item.
- squeeze(obj:item) # Squeeze an item.
- rinse(obj:item) # Rinse an item.
- move(obj:item) # Move an item.
- pull(obj:item) # Pull an item.
- push(obj:item) # Push an item.
- type(obj:item) # Type on an item.
- touch(obj:item) # Touch an item.
- read(obj:item) # Read an item.
- sit_somewhere(location:item) # Sit at a specific location.
- lie_somewhere(location:item) # Lie at a specific location.
Important Note: Ensure that all parameters are properly defined before using them in the behaviors.

## Available Category Determination:
- is_trashcan(x: item)
- is_ceilinglamp(x: item)
- is_mouse(x: item)
- is_food_cake(x: item)
- is_food_kiwi(x: item)
- is_napkin(x: item)
- is_milk(x: item)
- is_orchid(x: item)
- is_food_rice(x: item)
- is_laptop(x: item)
- is_food_steak(x: item)
- is_pot(x: item)
- is_towel_rack(x: item)
- is_cupboard(x: item)
- is_after_shave(x: item)
- is_doorjamb(x: item)
- is_headset(x: item)
- is_coffe_maker(x: item)
- is_dry_pasta(x: item)
- is_novel(x: item)
- is_homework(x: item)
- is_food_bread(x: item)
- is_drawing(x: item)
- is_clothes_pants(x: item)
- is_bookshelf(x: item)
- is_microwave(x: item)
- is_bills(x: item)
- is_sink(x: item)
- is_food_chicken(x: item)
- is_cat(x: item)
- is_fridge(x: item)
- is_clothes_skirt(x: item)
- is_photoframe(x: item)
- is_book(x: item)
- is_blender(x: item)
- is_food_apple(x: item)
- is_fryingpan(x: item)
- is_clothes_hat(x: item)
- is_curtain(x: item)
- is_food_hamburger(x: item)
- is_coffee_filter(x: item)
- is_mousepad(x: item)
- is_food_noodles(x: item)
- is_nightstand(x: item)
- is_bowl(x: item)
- is_dough(x: item)
- is_dining_room(x: item)
- is_food_vegetable(x: item)
- is_bathroom_counter(x: item)
- is_vacuum_cleaner(x: item)
- is_food_fruit(x: item)
- is_clothes_gloves(x: item)
- is_clothes_socks(x: item)
- is_food_cheese(x: item)
- is_food_oatmeal(x: item)
- is_plate(x: item)
- is_floor(x: item)
- is_toilet(x: item)
- is_food_butter(x: item)
- is_remote_control(x: item)
- is_food_peanut_butter(x: item)
- is_ceiling(x: item)
- is_box(x: item)
- is_washing_machine(x: item)
- is_tray(x: item)
- is_food_banana(x: item)
- is_oil(x: item)
- is_food_lemon(x: item)
- is_bed(x: item)
- is_window(x: item)
- is_bathtub(x: item)
- is_iron(x: item)
- is_dvd_player(x: item)
- is_cup(x: item)
- is_cd(x: item)
- is_cd_player(x: item)
- is_food_egg(x: item)
- is_clothes_scarf(x: item)
- is_food_cereal(x: item)
- is_check(x: item)
- is_glue(x: item)
- is_faucet(x: item)
- is_basket_for_clothes(x: item)
- is_powersocket(x: item)
- is_cleaning_solution(x: item)
- is_food_donut(x: item)
- is_dresser(x: item)
- is_console(x: item)
- is_knifeblock(x: item)
- is_keyboard(x: item)
- is_cpuscreen(x: item)
- is_food_carrot(x: item)
- is_detergent(x: item)
- is_food_pizza(x: item)
- is_soap(x: item)
- is_phone(x: item)
- is_coin(x: item)
- is_juice(x: item)
- is_food_snack(x: item)
- is_food_dessert(x: item)
- is_food_turkey(x: item)
- is_sauce(x: item)
- is_door(x: item)
- is_shower(x: item)
- is_laser_pointer(x: item)
- is_food_food(x: item)
- is_food_jam(x: item)
- is_bathroom(x: item)
- is_food_sugar(x: item)
- is_food_potato(x: item)
- is_toaster(x: item)
- is_walllamp(x: item)
- is_crayon(x: item)
- is_clothes_dress(x: item)
- is_knife(x: item)
- is_food_bacon(x: item)
- is_light(x: item)
- is_pillow(x: item)
- is_wall(x: item)
- is_bedroom(x: item)
- is_couch(x: item)
- is_needle(x: item)
- is_towel(x: item)
- is_clothes_shirt(x: item)
- is_dishwasher(x: item)
- is_television(x: item)
- is_clothes_underwear(x: item)
- is_alcohol(x: item)
- is_bathroom_cabinet(x: item)
- is_pajamas(x: item)
- is_oven(x: item)
- is_filing_cabinet(x: item)
- is_food_fish(x: item)
- is_kitchen_counter(x: item)
- is_chair(x: item)
- is_home_office(x: item)
- is_ironing_board(x: item)
- is_stove(x: item)
- is_table(x: item)
- is_mat(x: item)
- is_video_game_controller(x: item)
- is_spectacles(x: item)
- is_stereo(x: item)
- is_stamp(x: item)
- is_shoes(x: item)
- is_wallshelf(x: item)
- is_cutting_board(x: item)
- is_fork(x: item)
- is_food_ice_cream(x: item)
- is_clothes_jacket(x: item)
- is_tea_bag(x: item)
- is_stovefan(x: item)
- is_food_salt(x: item)
- is_tape(x: item)
- is_computer(x: item)
- is_tablelamp(x: item)
- is_bench(x: item)
- is_desk(x: item)
- is_tvstand(x: item)
- is_food_orange(x: item)
- is_food_onion(x: item)

For any instance 'x', you can use 'is_y(x)' to determine if 'x' belongs to category 'y'. Categories cannot be operated upon directly; you can only assess the status and relationships of specific instances within a category. If you want to select an item instance that belongs to the category "box", you can use the following syntax:

bind b: item where:
    is_box(b)

Important Notes:
If the category you need is not in the available list, try to find a synonym or a similar category with a closely related function.
Examples:
- food -> is_food_food(): If 'is_food' is not available, but 'is_food_food' is, use the latter as they have similar meanings.
- soapy_water -> is_cleaning_solution(): If 'soapy_water' is not available, but 'cleaning_solution' is, use the latter as they are functionally similar.

## Syntax Rules and Keywords:
"char" is a constant instance representing a character (yourself) and we assume that other animals like cat is an item. The type "character" can only be used when defining an instance. Use "char" consistently when passing parameters, and use "character" when defining a variable and specifying its type.

Below are all the keywords you can use to convert information into a structured format. Please ensure that you do not use any keywords other than those listed here.

Keywords:
# bind
# Usage: Select an item that meets the specified conditions and assign it to a variable. To maintain consistency, try to use 'bind' primarily in the '__goal__' behavior and pass the retrieved instances as parameters to invoked behaviors. Avoid using 'bind' in other behaviors whenever possible.
Example:
bind x: item where:
    is_light(x)

Multiple Items Example: Ensure that subsequent items are not the same as those previously bound.
bind apple1: item where:
    is_apple(apple1)
bind apple2: item where:
    is_apple(apple2) and apple1!=apple2
bind apple3: item where:
    is_apple(apple3) and apple1!=apple3 and apple2!=apple3

# achieve
# Usage: Specifies the state or relationship that a behavior consistently aims to maintain from start to finish. Only states and relationships can follow 'achieve', not types, properties, or other immutable content. Do not call functions or behaviors after 'achieve'; instead, call functions directly without keywords. Note that 'achieve' cannot be used with the state 'inhand'. And note that 'achieve' must be followed by a single state or relationship, not a combination of states or relationships.
Example: achieve is_on(light)

# achieve_once
# Usage: Specifies a temporary state or relationship that needs to be achieved only once, without maintaining it until the end of the behavior.
Example: achieve_once inhand(apple) #Please note that 'inhand' must be used with 'achieve_once.'

# foreach
# Usage: Iterates over all objects. Do not use 'where' in a 'foreach' statement.
Correct example:
foreach o: item:
    if can_open(o) and is_box(o):
        achieve closed(o)

Incorrect example:
foreach o: item where:
    achieve closed(o)

# behavior
# Usage: Defines a behavior rule. The keyword 'body' must appear in the behavior, and all parameters used in the 'goal' must be included in the behavior's parameters.

# goal
# Usage: Specifies the goal condition for a behavior. If you want to use the goal, please ensure that you include all the parameters used in the 'goal' in the behavior parameters.

# body
# Usage: Contains the sequence of intermediate states and relationships necessary to achieve the behavior’s goal.

# assert
# Usage: Asserts a condition that must be true for the behavior to succeed.
Example: assert is_on(light)

# assert_hold
# Usage: Maintains a long-term constraint until the end of the containing behavior.
Example: assert_hold closed(freezer)
ensures that the freezer remains closed until all behaviors are completed.

# if-else
# Usage: Conditional statement for branching logic. Only simple first-order logic or combinations of first-order logic are allowed after if-else. Note that elif is not supported.
if condition:
    achieve closed(a)
else:
    achieve clean(b)

# exists
# Usage: Checks if there is at least one object that meets the condition and returns a boolean value.
Template: exists obj_name: objtype : condition()
Example: exists item1: item : holds_lh(char, item1)

# symbol
# Usage: Defines a symbol and binds it to the output of an expression. You can only use the symbol in the following manner:
symbol has_cutting_board=exists item1:item: is_cutting_board(item1)

# def
# Usage: Defines a function that can be used to check a condition. 

## Background Knowledge:
In general, you only know part of the information in a given scenario. For example, you might know that a certain piece of clothing is in a particular basket, but you might not know what is in a certain basket. Therefore, many times, you need to first perform a goal conversion based on what you already know. When you lack some information, you can observe and obtain the information you want by using obs(target_item, information).
For example, if you want to know if there are clothes in the basket_34, you can use:
bind basket: item where:
    is_basket(basket) and id[basket]==34
observe(basket,"Check is there any clothes in the basket")

If you want to know Is there any trash in the trash can in the dining room, you can use:

bind dining_room: item where:
    is_dining_room(dining_room)

bind trash_can: item where:
    is_trash_can(trash_can) and inside(trasn_can, dining_room)
observe(trash_can,"Check is there any trash in the trash can")

## Examples:
# Example-1-1:
Current sub-task goal: 1. Find a table with food.
The completed sub-tasks: None, it is the first sub-task.
Additional information: None.
Long-horizon task: Clean up the food on the table.
Chain of thought: Your current sub-task goal is to find a table with food on it, which is the first step towards completing the long-horizon task. According to the background knowledge, your first step should be to check if there is a known table with food on it. To do this, you need to determine whether there is food on a table. You can create a function called 'has_food_on_table(table:item)', which returns the result of the expression 'exists o: item : is_food(o) and on(o, table)'. This expression checks if there is an item classified as food that is on the table, according to your known information.
Next, you can use the expression 'exists table: item : is_table(table) and has_food_on_table(table)' to verify if there is a table with food on it in the known information. If such a table exists, there is no need to continue searching; you can immediately use 'achieve close_char(char, table)' to have the character approach the table with food.
However, if your known information does not confirm the presence of a table with food on it, you will need to inspect all unvisited items in the scene categorized as tables. To do this, you should call the 'observe' behavior to check each table. The first parameter of the 'observe' behavior should be the table you intend to inspect, and the second parameter should be the purpose of the inspection. Remember, the second parameter must be a string enclosed in double quotes ("").

Output:
def has_food_on_table(table:item):
    # Function to check if there is food on a specified table.
    symbol has_food=exists o: item : is_food(o) and on(o, table)
    return has_food

behavior __goal__():
    body:
        if exists table: item : is_table(table) and has_food_on_table(table):
            # Check if there is a table with food based on the available information.
            bind table: item where:
                is_table(table) and has_food_on_table(table) 
            # Select a table that has food on it.
            achieve close_char(char, table) 
            # Move the character closer to the table with food.

        else: 
           # If no table with food is found, initiate exploration to locate one.
            foreach table: item:
                if is_table(table) and not visited(table):
                    # Check all unvisited tables.
                    observe(table,"Check is there any food on the table")
                    # Observe whether each table has any food.
            
# Example-1-2:
Current sub-task goal: 2. Put the food in the appropriate storage locations.
The completed sub-tasks: 1. Find a table with food.
Additional information: 
1. There is no food on table 107. 
2. No food is find on the table 355, please see other tables.
3. food_peanut_butter_2008 and food_kiwi_2012 are on the table_226.
Long-horizon task: Clean up the food on the table.

Chain of thought: You have already find the table with food. Now, your current sub-task goal is to store the food on the table in the appropriate location. According to the additional information, there is no food on table_107 and table_355. However, table_226 has food_peanut_butter and food_kiwi.You can use the 'bind' keyword along with the condition 'is_table(table) and id[table] == 226' to obtain the table with the ID 226. You can also use the 'bind' keyword with the condition 'is_food_peanut_butter(food_peanut_butter) and on(food_peanut_butter, table)' to obtain the peanut butter that is on the table 226. And use 'bind' keyword with the condition 'is_food_kiwi(food_kiwi) and on(food_kiwi, table)' to obtain the kiwi on the table 226. Since the sub-task goal and additional information do not specify where exactly to store the food, you need to use common sense to make a decision based on the items present in the scene. Based on common sense, both food_peanut_butter and food_kiwi may require refrigeration, and since there is a freezer available in the scene, the goal is to store them in the freezer. Although it is not explicitly stated, it is common sense to ensure that the refrigerator door is closed after storing food inside. Therefore, you can use achieve closed(freezer) to perform the action of closing the refrigerator door.

Output:
behavior store_in_freezer(food:item, freezer:item):
    body:
        achieve inside(food, freezer)
        # Place the food item inside the freezer.

behavior close_the_freezer_door(freezer:item):
    body:
        achieve closed(freezer)
        # Close the freezer door.

behavior __goal__():
    body:
        bind table: item where:
            is_table(table) and id[table]==226
        # Select table with ID 226.

        bind food_peanut_butter: item where:
            is_food_peanut_butter(food_peanut_butter) and on(food_peanut_butter, table)
        # Select peanut butter on the table.

        bind food_kiwi: item where:
            is_food_kiwi(food_kiwi) and on(food_kiwi, table)
        # Select kiwi on the table.
        
        bind freezer: item where:
            is_freezer(freezer)
        store_in_freezer(food_peanut_butter, freezer)
        store_in_freezer(food_kiwi, freezer)
        close_the_freezer_door(freezer)

# Example-1-3:
Current sub-task goal: 2. Put the food in the appropriate storage locations.
The completed sub-tasks: 1. Find a table with food.
Additional information: 
1. There is no food on table 107. 
2. No food is find on the table 355, please see other tables.
3. food_peanut_butter_2008 and food_kiwi_2012 are on the table_226.
4. The peanut butter is expired, so I want to throw it away. I want to cut the kiwi and then store it in the freezer.
Long-horizon task: Clean up the food on the table.

Chain of thought: According to Additional information 4, you need to discard the peanut butter. Observing that there is an "is_trashcan" in the Available Category, you can infer that there is a trashcan in the scene, and the expired peanut butter can be thrown into the trashcan. Additional information 4 also requires that the kiwi be washed, cut, and then stored in the refrigerator. Based on common sense, the kiwi can be washed in the sink, and then you need to use "achieve cut(food_kiwi)" to cut the kiwi. After that, you can "achieve inside(food_kiwi, freezer)" to store the kiwi in the freezer. To ensure the completeness of the task, you also need to use "achieve closed(freezer)" to make sure the refrigerator door is closed at the end by "achieve closed(freezer)".

Output:
def has_faucet(sink:item):
# Determine whether this pool has a faucet.
    symbol has_faucet=exists faucet:item: is_faucet(faucet) and close(faucet,sink)
    return has_faucet

behavior throw_in_trash(food:item, trashcan:item): 
# Define the behavior to throw food into the trash can
    body:
        achieve inside(food, trashcan)

behavior clean_food(food:item, sink:item):
# Define the behavior to clean food in the sink
    body:
        achieve_once inside(food, sink)
        # Ensure the food is placed inside the sink

        if has_faucet(sink):
            bind faucet: item where:
                is_faucet(faucet) and close(faucet,sink)
            achieve_once is_on(faucet)
            # If the pool has a faucet, turn it on to clean.

        wash(food) # This is the key step of the behavior, used for cleaning food.
        
        if has_faucet(sink):
            bind faucet: item where:
                is_faucet(faucet) and close(faucet,sink)
            achieve_once is_off(faucet)
            # If the pool has a faucet, turn it off after cleaning.
        
behavior cut_food(food:item):
    body:
        achieve cut(food)

behavior store_in_freezer(food:item, freezer:item):
    body:
        achieve inside(food, freezer)

behavior close_the_freezer_door(freezer:item):
    body:
        achieve closed(freezer)

behavior __goal__():
    body:
        bind table: item where:
            is_table(table) and id[table]==226
        # Select table with ID 226.
        bind food_peanut_butter: item where:
            is_food_peanut_butter(food_peanut_butter) and on(food_peanut_butter, table)
        # Select peanut butter on the table.
        bind food_kiwi: item where:
            is_food_kiwi(food_kiwi) and on(food_kiwi, table)
        # Select kiwi on the table.
        bind trashcan: item where:
            is_trashcan(trashcan)
        # Select a trash can.
        bind sink: item where:
            is_sink(sink)
        # Select a sink.
        bind freezer: item where:
            is_freezer(freezer)
        # Select a freezer.
        throw_in_trash(food_peanut_butter, trashcan)
        clean_food(food_kiwi, sink)
        cut_food(food_kiwi)
        store_in_freezer(food_peanut_butter, freezer)
        close_the_freezer_door(freezer)
          
# Example-2-1:
Current sub-task goal: 1. Find the sink with plates and cups.
The completed sub-tasks: None, it is the first sub-task.
Additional information: None.
Long-horizon task: Wash the plates and cups in the sink using the dishwasher. Then put them on the table in kitchen.

Chain of thought: Your current sub-task goal is to find the sink with plates and cups, which is the first step toward completing the long-horizon task: "Wash the plates and cups in the sink using the dishwasher. Then put them on the table in the kitchen."
To achieve this, you first need to determine whether there are plates or cups in the sink. You can design a function called 'has_plate_or_cup_in_sink(sink:item)' that checks for this. The function should return the result of the expression 'exists o: item : (is_plate(o) or is_cup(o)) and inside(o, sink)', which verifies if there is an item that is either a plate or a cup and is located inside the sink in your known information.
Next, you can use 'exists sink: item : is_sink(sink) and has_plate_or_cup_in_sink(sink)' to check if there is a sink with plates or cups in it within the known information. If such a sink is found, there's no need to search further; you can immediately use 'achieve close_char(char, sink)' to have the character approach the sink containing the plates or cups.
However, if your known information does not confirm the presence of a sink with plates or cups, you will need to check all unvisited items categorized as sinks in the scene. For this, you should call the 'observe' behavior to inspect each sink. The first parameter of the 'observe' behavior should be the sink you intend to check, and the second parameter should be the purpose of the inspection. Remember, the second parameter must be a string enclosed in double quotes ("").

Output:
def has_plate_or_cup_in_sink(sink:item):
    # Function to check if there are plates or cups in a specified sink.
    symbol has_plate_or_cup=exists o: item : (is_plate(o) or is_cup(o)) and inside(o, sink)
    return has_plate_or_cup

behavior __goal__():
    body:
        if exists sink: item : is_sink(sink) and has_plate_or_cup_in_sink(sink):
            # If we have already found the sink with plates or cups, we can directly approach it
            bind sink: item where:
                is_sink(sink) and has_plate_or_cup_in_sink(sink)
            achieve close_char(char, sink)

        else:
            # Check all sinks in the scene that have not been visited
            foreach sink: item:
                if is_sink(sink) and not visited(sink):
                    observe(sink,"Check is there any plate or cup in the sink")

# Example-2-2:
Current sub-task goal: 2. Wash the plates and cups using the dishwasher.
The completed sub-tasks: 1. Find the sink with plates and cups.
Additional information: 
1. sink_42 is in the bathroom, and no plates or cups are found in it.
2. sink_231 is in the kitchen, and there are plates and cups in it.
Long-horizon task: Wash the plates and cups in the sink using the dishwasher. Then put them on the table in kitchen.

Chain of thought:
According to additional information, sink_42 does not contain plates or cups, while sink_231 does contain plates or cups. Now you have found the sink that contains plates or cups. The current sub-task's goal is "Wash the plates and cups using the dishwasher." Although it doesn't explicitly state that the plates and cups in the sink need to be cleaned, considering the objective of the long-horizon task, the actual goal of the current sub-task should be to clean the plates and cups in the sink. To clean the plates and cups in the sink using the dishwasher, you first need to load them into the dishwasher. Since it is unclear how many plates and cups are in the sink, the foreach keyword is used with the condition if is_plate(o) or is_cup(o) and inside(o, sink) to place all items that are plates or cups from the sink into the dishwasher. After that, you can execute achieve closed(dishwasher) and achieve is_on(dishwasher) sequentially to start the dishwasher.

Output:
behavior load_dishwasher(o:item, dishwasher:item):
    body:
        achieve inside(o, dishwasher)
        # Place the item inside the dishwasher.

behavior start_dishwasher(dishwasher:item):
    body:
        achieve closed(dishwasher) # Close the dishwasher door.
        achieve is_on(dishwasher) # Turn on the dishwasher.

behavior __goal__():
    body:
        bind sink: item where:
            is_sink(sink) and id[sink]==231
        # Select sink with ID 231.
        bind dishwasher: item where:
            is_dishwasher(dishwasher)
        # Select a dishwasher.
        foreach o: item:
        # Load all plates and cups from the sink into the dishwasher.
            if is_plate(o) or is_cup(o) and inside(o, sink):
                load_dishwasher(o, dishwasher)
        start_dishwasher(dishwasher) # Start the dishwasher.

# Example-2-3:
Current sub-task goal: 3. Put the plates and cups on the table in the kitchen.
The completed sub-tasks: 1. Find the sink with plates and cups. 2. Wash the plates and cups using the dishwasher.
Additional information: 
1. plate_1000, plate_1001, cup_1002, cup_1003 is cleaned by dishwasher_2000.
Long-horizon task: Wash the plates and cups in the sink using the dishwasher. Then put them on the table in kitchen.

Chain of thought:
According to "The completed sub-tasks" and "Additional information," the plates and cups that need to be placed on the table have already been cleaned in a dishwasher, and they are currently in a dishwasher with an ID of 2000. The current sub-task requires you to place the plates and cups on a table located in the kitchen. There may be more than one table in the scene, so you need to design a function 'in_kitchen(table: item)' that returns the value of the expression 'exists room: item : is_kitchen(room) and inside(table, room)', which checks whether the given table is inside a kitchen. Next, you need to design a 'put_on_table' behavior to place the plates or cups on the table. To determine which table to use, you should apply 'put_on_table' to all the plates or cups that were originally in the dishwasher, placing them on the table. Finally, to ensure the dishwasher is properly reset, you can design a 'close_the_dishwasher' behavior to turn off and close the dishwasher.

Output:
def in_kitchen(table:item):
    # Function to check if a table is in the kitchen.
    symbol in_kitchen=exists room: item : is_kitchen(room) and inside(table, room)
    return in_kitchen

def has_plates_or_cups_inside(dishwasher:item):
    # Function to check if there are plates or cups inside the dishwasher.
    symbol has_plates_or_cups=exists o: item : (is_plate(o) or is_cup(o)) and inside(o, dishwasher)
    return has_plates_or_cups

behavior put_on_table(o:item, table:item):
    body:
        achieve on(o, table) # Place the item on the table.

behavior close_the_dishwasher(dishwasher:item):
    body:
        achieve is_off(dishwasher) # Turn off the dishwasher.
        achieve closed(dishwasher) # Close the dishwasher door.

behavior __goal__():
    body:
        bind table: item where:
            is_table(table) and in_kitchen(table)
        # Select a table in the kitchen.
        bind dishwasher: item where:
            is_dishwasher(dishwasher) and id[dishwasher]==2000
        # Select the dishwasher with ID 2000.
        foreach o: item:
        # Place all plates and cups originally in the dishwasher on the table.
            if is_plate(o) or is_cup(o) and inside(o, dishwasher):
                put_on_table(o, table)
        close_the_dishwasher(dishwasher) # Reset the dishwasher.

#Guidance-1:
A common mistake is ignoring the duration of "achieve." The duration of "achieve" persists until the current action is completed. If you specify two mutually exclusive states in a behavior using "achieve," it will result in a program error.

Here is some typical errors:
- error example-1:
behavior put_apple_on_table(apple:item,table:item):
    body:
        achieve inhand(apple)
        achieve on(apple,table)

Error Analysis: In this example, if you use achieve inhand(apple), then the apple must be keep inhand until the end of this behavior. Then you use achieve on(apple,table), which means you put the apple on the table. Now the apple should be both remain in hand and be placed on the table, which is impossible to achieve. The solution to this problem is to remove the unnecessary step of achieving inhand(apple), as the program will automatically determine how to achieve on(apple,table). In fact, unless you need to hold an item to complete a specific task (such as cutting vegetables with a knife or wiping a window with a cloth), please avoid using the "inhand" state in other situations.

A correct output for example-1 is:
behavior put_apple_on_table(apple:item,table:item):
    body:
        achieve on(apple,table)

- error example-2:
behavior clean_a_vegetable_in_sink(vegetable:item,sink:item):
    body:
        achieve inside(vegetable,sink)
        if exists faucet:item: is_faucet(faucet) and close(faucet,sink):
            achieve is_on(faucet)
            wash(vegetable)
            achieve is_off(faucet)
        else:
            wash(vegetable)

Error Analysis: The problem with this example is that it uses both achieve is_on(faucet) and is_off(faucet) sequentially. These states are mutually exclusive, as the faucet should not be both on and off at the same time. To resolve this issue, you can use achieve_once to prevent achieve from persisting until the current behavior ends.

A correct output for example-2 is:
behavior clean_a_vegetable_in_sink(vegetable:item,sink:item):
    body:
        achieve inside(vegetable,sink)
        if exists faucet:item: is_faucet(faucet) and close(faucet,sink):
            achieve_once is_on(faucet)
            wash(vegetable)
            achieve_once is_off(faucet)
        else:
            wash(vegetable)

# Guidance-2:
The following example demonstrates the difference between using foreach and bind.

Please note that bind requires the use of the "where keyword", while foreach must not use the "where" keyword under any circumstances.  
eg:
foreach c: item:
    if is_clothes(c) and inside(c,basket):
        achieve inside(c, washing_machine)

foreach obj2:item:
    if inside(obj,obj2):
    if not is_room(obj2):
        assert can_open(obj2) or recipient(obj2) or eatable(obj2)
        if can_open(obj2):
        achieve open(obj2)

bind basket: item where:
    is_basket_for_clothes(basket)

bind washing_machine: item where:
    is_washing_machine(washing_machine)

You can see that all the foreach statements are used without "where", while all the bind statements need to include "where".

# Guidance-3:
Since there are usually more than one instance of the same type of object in a scene, simply using 'is_category()' to constrain the type of the object is often insufficient when selecting a specific instance. To more accurately retrieve the desired object, there are generally two methods. One is to directly use the id if you know the target instance's number, for example:"is_dishwasher(dishwasher) and id[dishwasher]==2000". The other is to add a positional relationship with other objects, such as selecting the faucet next to the sink. In more complex situations, you can follow the approach in Example-2-3 and design a function specifically for adding constraints to the bind operation, allowing you to accurately obtain the desired instance.
Example:
def in_kitchen(table:item):
    symbol in_kitchen=exists room: item : is_kitchen(room) and inside(table, room)
    return in_kitchen
    ......
bind table: item where:
    is_table(table) and in_kitchen(table)
Of course, you can also use attributes, states, and other information to more flexibly constrain the instances retrieved by the bind operation.

# Guidance-4:
The observe(obj:item, question:string) is a powerful but resource-intensive behavior. It allows you to examine an object based on observation, during which you need to specify what information you wish to obtain from the object. Due to the high cost of using observe, the quality of your questions is crucial for improving execution efficiency. Generally speaking, information such as the type of object or its state can be obtained by referring to the methods provided in 'Available Category Determination' and 'Available States', so you usually don't need to invoke the observe behavior for these details. Some situations where observe behavior is necessary include when you want to check what items are inside or on the item you observe. For example, if you want to see what's inside the oven, you can use 'observe(oven, "What's inside the oven?")', or if you want to check what's on the table, you can use 'observe(table, "check items on the table")'. Also, feel free to ask more questions in the observe behavior to get more detailed information. For example, If you want to check what's inside the oven and whether it's on the kitchen counter, you can use 'observe(oven, "What's inside the oven? Is it on the kitchen counter?")'.

# Guidance-5:
Try to avoid using the 'inhand(x:item)' state. In most cases, the program will automatically manage the 'inhand' operations. If you define 'inhand' manually, it can easily lead to a situation where the agent is holding too many items, causing the program to crash. There is generally only one situation where you need to declare the 'inhand' operation: when you need to hold certain items to complete a specific task. For example, when cleaning a mirror with a towel, you need to use 'achieve_once inhand(towel)'. Other than this, please avoid defining the 'inhand' state. In some cases, the task information may not clearly specify where certain items should be placed, such as in "gathering the food." In these cases, use your common sense to place the food in an appropriate location, like achieve 'on(food, kitchen_counter)', to avoid the issue of holding too many items. If possible, ensure that the agent's hands are empty after each sub-task is completed.

## Previous cases
Here are some success cases for your reference and learning.
# Case 1:
When the sub-task is: Open the windows in the bathroom.
A successful representation:
 
behavior __goal__():
    body:
        bind bathroom: item where:
            is_bathroom(bathroom)
        # Select the bathroom

        foreach window: item:
            if is_window(window) and inside(window, bathroom):
                # Check all windows inside the bathroom
                achieve open(window)
                # Open each window in the bathroom

# Case 2:
When the sub-task is: 1. Hand wash the jacket thoroughly.
A successful representation:
 
behavior __goal__():
    body:
        bind jacket: item where:
            is_clothes_jacket(jacket)
        # Select the jacket for hand washing
        
        wash(jacket)
        # Perform hand washing on the jacket

# Case 3:
When the sub-task is: 2. Place the jacket in the washing machine and wash it.
A successful representation:
 
behavior place_jacket_in_washing_machine(jacket:item, washing_machine:item):
    body:
        achieve inside(jacket, washing_machine)
        # Place the jacket inside the washing machine
        
behavior start_wash_cycle(washing_machine:item):
    body:
        achieve closed(washing_machine)
        # Ensure the washing machine door is closed
        achieve is_on(washing_machine)
        # Start the washing cycle

behavior __goal__():
    body:
        bind jacket: item where:
            is_clothes_jacket(jacket) and clean(jacket)
        # Select the clean jacket

        bind washing_machine: item where:
            is_washing_machine(washing_machine)
        # Select the washing machine

        place_jacket_in_washing_machine(jacket, washing_machine)
        start_wash_cycle(washing_machine)

# Case 4:
When the sub-task is: 1. Find the milk, turkey, egg, fish, and chicken.
A successful representation:
 
def has_food_inside(room: item):
    # Function to check if the dining room contains specific food items
    symbol has_milk=exists o: item : is_milk(o) and inside(o, room)
    symbol has_turkey=exists o: item : is_food_turkey(o) and inside(o, room)
    symbol has_egg=exists o: item : is_food_egg(o) and inside(o, room)
    symbol has_fish=exists o: item : is_food_fish(o) and inside(o, room)
    symbol has_chicken=exists o: item : is_food_chicken(o) and inside(o, room)
    return has_milk or has_turkey or has_egg or has_fish or has_chicken

behavior __goal__():
    body:
        if exists room: item : is_dining_room(room) and has_food_inside(room):
            # Using known information to approach the dining room containing the required food items
            bind room: item where:
                is_dining_room(room) and has_food_inside(room)
            achieve close_char(char, room)
        
        else:
            # If no food items found, inspect the dining room for unvisited items
            foreach room: item:
                if is_dining_room(room) and not visited(room):
                    observe(room, "Check for milk, turkey, egg, fish, and chicken in the dining room")

# Case 5:
When the sub-task is: 2. Bring the milk, turkey, egg, fish, and chicken to the table in the dining room.
A successful representation:
 
behavior place_item_on_table(item:item, table:item):
    body:
        achieve on(item, table) # Place the item on the table

behavior __goal__():
    body:
        bind dining_room: item where:
            is_dining_room(dining_room)
        # Select the dining room

        bind table: item where:
            is_table(table) and inside(table, dining_room)
        # Select a table inside the dining room

        bind milk: item where:
            is_milk(milk)
        # Select the milk item

        bind turkey: item where:
            is_food_turkey(turkey)
        # Select the turkey item

        bind egg: item where:
            is_food_egg(egg)
        # Select the egg item

        bind fish: item where:
            is_food_fish(fish)
        # Select the fish item

        bind chicken: item where:
            is_food_chicken(chicken)
        # Select the chicken item

        place_item_on_table(milk, table)
        place_item_on_table(turkey, table)
        place_item_on_table(egg, table)
        place_item_on_table(fish, table)
        place_item_on_table(chicken, table)

# Case 6:
When the sub-task is: 1. Locate the cat.  
A successful representation:
 
def is_cat_found(cat: item):
    # Determine if the cat has been observed or is known to be in a specific location
    symbol found=visited(cat)
    return found

behavior find_cat(cat:item):
    body:
        if is_cat_found(cat):
            # If the cat is already found, ensure the character is close to it
            achieve close_char(char, cat)
        else:
            # If the cat is not found, observe all unvisited cats to locate it
            foreach item: item:
                if is_cat(item) and not visited(item):
                    observe(item, "Locate the cat")

behavior __goal__():
    body:
        bind cat: item where:
            is_cat(cat)
        find_cat(cat)

# Case 7:
When the sub-task is: 2. Gently touch the cat.
A successful representation:
 
behavior gently_touch_cat(cat:item):
    body:
        achieve close_char(char, cat)
        # Move close to the cat to ensure a gentle interaction
        achieve facing_char(char, cat)
        # Face the cat for clear visibility and interaction
        touch(cat)
        # Gently touch the cat

behavior __goal__():
    body:
        bind cat: item where:
            is_cat(cat) and id[cat] == 2069
        # Select the cat with ID 2069
        gently_touch_cat(cat)

# Case 8:
When the sub-task is: Turn on the lights in the bathroom.
A successful representation:
 
behavior __goal__():
    body:
        bind bathroom: item where:
            is_bathroom(bathroom)
        # Select the bathroom

        bind light: item where:
            is_light(light) and inside(light, bathroom)
        # Select the light inside the bathroom

        achieve is_on(light)
        # Turn on the light in the bathroom

# Case 9:
When the sub-task is: 1. Put the pan on the stove.
A successful representation:
 
behavior observe_frying_pan_cleanliness(fryingpan:item):
    body:
        observe(fryingpan, "Ensure it is clean and suitable for scrambling eggs")

behavior place_pan_on_stove(fryingpan:item, stove:item):
    body:
        achieve on(fryingpan, stove)
        # Place the pan on the stove

behavior __goal__():
    body:
        bind fryingpan: item where:
            is_fryingpan(fryingpan)
        # Select the frying pan
        bind stove: item where:
            is_stove(stove)
        # Select the stove
        
        observe_frying_pan_cleanliness(fryingpan)
        place_pan_on_stove(fryingpan, stove)

# Case 10:
When the sub-task is: 2. Turn on the stove.
A successful representation:
 
behavior __goal__():
    body:
        bind stove: item where:
            is_stove(stove) and id[stove] == 2135
        # Select the stove with ID 2135
        
        achieve is_on(stove)
        # Turn on the stove

# Case 11:
When the sub-task is: 3. Put oil in the pan.
A successful representation:

def is_clean_fryingpan_on_stove(fryingpan: item, stove: item):
    # Determine if the fryingpan is clean and placed on the stove
    symbol on_stove_and_clean = on(fryingpan, stove) and clean(fryingpan)
    return on_stove_and_clean

behavior __goal__():
    body:
        bind stove: item where:
            is_stove(stove)
        # Select the stove 

        bind fryingpan: item where:
            is_fryingpan(fryingpan) and is_clean_fryingpan_on_stove(fryingpan, stove)
        # Select a clean fryingpan that is already on the stove

        bind oil: item where:
            is_oil(oil)
        # Select the oil

        achieve inside(oil, fryingpan)
        # Add oil inside the fryingpan

# Case 12:
When the sub-task is: 4. Put the egg in the pan.
A successful representation:
behavior crack_egg_into_pan(egg:item, pan:item):
    body:
        achieve inside(egg, pan)

behavior __goal__():
    body:
        bind stove: item where:
            is_stove(stove) and id[stove] == 2135
        # Select the stove with ID 2135

        bind egg: item where:
            is_food_egg(egg)
        # Select the egg item
        
        bind pan: item where:
            is_fryingpan(pan) and on(pan, stove)
        # Select the frying pan on the stove with ID 2135

        crack_egg_into_pan(egg, pan)
# Case 13:
When the sub-task is: Use the pot to boil some water.
A successful representation:
behavior pour_water_into_pot(pot:item):
    body:
        achieve has_water(pot)

behavior turn_on_stove_for_pot(pot:item, stove:item):
    body:
        achieve on(pot, stove)
        # Ensure the pot is on the stove
        achieve is_on(stove)
        # Turn on the stove

behavior __goal__():
    body:
        bind pot: item where:
            is_pot(pot)
        # Select the pot

        bind stove: item where:
            is_stove(stove)
        # Select the stove

        pour_water_into_pot(pot)
        turn_on_stove_for_pot(pot, stove)
# Case 14:
When the sub-task is: 1. Find the bowls and plates that need washing.  
A successful representation:
 
def is_dirty_bowl_or_plate(item: item):
    # Function to check if an item is a dirty bowl or plate
    symbol is_dirty = (is_bowl(item) or is_plate(item)) and dirty(item)
    return is_dirty

behavior __goal__():
    body:
        # Check if any unvisited items that are bowls or plates are dirty, and need washing
        foreach item: item:
            if (is_bowl(item) or is_plate(item)) and not visited(item):
                observe(item, "Check if the item is dirty")
                # Observe if the item is dirty to find the bowls and plates needing washing

# Case 15:
When the sub-task is: 2. Use the dishwasher to wash the bowls and plates.
A successful representation:
 
behavior load_dishwasher(o:item, dishwasher:item):
    body:
        achieve inside(o, dishwasher)
        # Place the item inside the dishwasher

behavior start_dishwasher(dishwasher:item):
    body:
        achieve closed(dishwasher) # Close the dishwasher door
        achieve is_on(dishwasher) # Turn on the dishwasher

behavior __goal__():
    body:
        bind dishwasher: item where:
            is_dishwasher(dishwasher)
        # Select a dishwasher
        
        foreach o: item:
        # Load all bowls and plates that need washing into the dishwasher
            if (is_bowl(o) or is_plate(o)) and dirty(o):
                load_dishwasher(o, dishwasher)
                
        start_dishwasher(dishwasher) # Start the dishwasher
 
# Case 16:
When the sub-task is: Turn on the DVD player using the remote control.
A successful representation:
 
behavior __goal__():
    body:
        bind remote_control: item where:
            is_remote_control(remote_control) and id[remote_control] == 2124
        # Select the remote control with ID 2124

        bind dvd_player: item where:
            is_dvd_player(dvd_player) and id[dvd_player] == 2130
        # Select the DVD player with ID 2130

        achieve_once inhand(remote_control)
        # Temporarily hold the remote control in hand

        achieve close_char(char, dvd_player)
        # Approach the DVD player

        achieve is_on(dvd_player)
        # Turn on the DVD player

# Case 17:
When the sub-task is: 1. Locate the book within the household environment.
A successful representation:
 
def is_book_found(book: item):
    # Check if the book has already been visited
    symbol found = visited(book)
    return found

behavior find_book(book:item):
    body:
        if is_book_found(book):
            # If the book is already found, move close to it
            achieve close_char(char, book)
        else:
            # Observe all unvisited books to locate the book
            foreach item: item:
                if is_book(item) and not visited(item):
                    observe(item, "Locate the book")

behavior __goal__():
    body:
        bind book: item where:
            is_book(book)
        find_book(book)

# Case 18:
When the sub-task is: 2. Place the book on the coffee table in the home office.
A successful representation:
 
behavior place_book_on_coffee_table(book:item, coffee_table:item):
    body:
        achieve on(book, coffee_table)
        # Place the book on the coffee table

behavior __goal__():
    body:
        bind book: item where:
            is_book(book) and id[book]==2066
        # Select book with ID 2066

        bind home_office: item where:
            is_home_office(home_office)
        # Select the home office

        bind coffee_table: item where:
            is_coffee_table(coffee_table) and inside(coffee_table, home_office)
        # Select a coffee table inside the home office

        place_book_on_coffee_table(book, coffee_table) 

# Case 19:
When the sub-task is: 1. Put cleaning solution in the dishwasher.
A successful representation:
behavior pour_cleaning_solution(dishwasher:item, cleaning_solution:item):
    body:
        achieve inside(cleaning_solution, dishwasher)
        # Pour the cleaning solution inside the dishwasher

behavior __goal__():
    body:
        bind dishwasher: item where:
            is_dishwasher(dishwasher)
        # Select the dishwasher

        bind cleaning_solution: item where:
            is_cleaning_solution(cleaning_solution)
        # Select the cleaning solution

        pour_cleaning_solution(dishwasher, cleaning_solution)
        # Pour the cleaning solution into the dishwasher
# Case 20:
When the sub-task is: 2. Place the bowls and plates in the dishwasher to wash them.
A successful representation:
 
behavior load_dishwasher(o:item, dishwasher:item):
    body:
        achieve inside(o, dishwasher)
        # Place the item inside the dishwasher

behavior start_dishwasher(dishwasher:item):
    body:
        achieve closed(dishwasher) # Close the dishwasher door
        achieve is_on(dishwasher) # Turn on the dishwasher

behavior __goal__():
    body:
        bind dishwasher: item where:
            is_dishwasher(dishwasher)
        # Select a dishwasher
        
        foreach o: item:
        # Load all bowls and plates inside the dishwasher
            if is_bowl(o) or is_plate(o):
                load_dishwasher(o, dishwasher)
                
        start_dishwasher(dishwasher) # Start the dishwasher

# Case 21:
When the sub-task is: 1. Find the dining room table.
A successful representation:
 
behavior find_dining_room_table(dining_room:item):
    body:
        foreach table: item:
            if is_table(table) and inside(table, dining_room) and not visited(table):
                observe(table, "Locate the dining room table")
                
behavior __goal__():
    body:
        bind dining_room: item where:
            is_dining_room(dining_room)
        find_dining_room_table(dining_room)

# Case 22:
When the sub-task is: 2. Put the milk and egg on the dining room table.
A successful representation:
 
behavior place_item_on_table(item:item, table:item):
    body:
        achieve on(item, table)

behavior __goal__():
    body:
        bind dining_room: item where:
            is_dining_room(dining_room)

        bind table: item where:
            is_table(table) and inside(table, dining_room)

        bind milk: item where:
            is_milk(milk)

        bind egg: item where:
            is_food_egg(egg)

        place_item_on_table(milk, table)
        place_item_on_table(egg, table)

# Case 23:
When the sub-task is: 3. Take all the items from the fridge and throw them into the trashcan.
A successful representation:
 
behavior __goal__():
    body:
        bind fridge: item where:
            is_fridge(fridge) and id[fridge] == 126
        # Select the fridge with ID 126

        bind trashcan: item where:
            is_trashcan(trashcan)
        # Select the trashcan

        foreach item: item:
        # Throw away all items inside the fridge into the trashcan
            if inside(item, fridge):
                achieve inside(item, trashcan)

# Case 24:
When the sub-task is: 4. Put the milk and egg back into the fridge.
A successful representation:
 
behavior __goal__():
    body:
        bind table: item where:
            is_table(table) and id[table]==114
        # Select the table with ID 114 where the milk and egg were placed

        bind milk: item where:
            is_milk(milk) and on(milk, table)
        # Select the milk on the table
        
        bind egg: item where:
            is_food_egg(egg) and on(egg, table)
        # Select the egg on the table

        bind fridge: item where:
            is_fridge(fridge) and id[fridge]==126
        # Select the fridge with ID 126

        achieve inside(milk, fridge)
        # Put the milk back inside the fridge

        achieve inside(egg, fridge)
        # Put the egg back inside the fridge

# Case 25:
When the sub-task is: 1. Find a cup and fill it with milk.
A successful representation:
behavior find_cup(cup:item):
    body:
        if visited(cup):
            achieve close_char(char, cup)
        else:
            observe(cup, "Locate the cup")
            achieve close_char(char, cup)

behavior fill_cup_with_milk(cup:item, milk:item):
    body:
        achieve inside(milk, cup)
        
behavior __goal__():
    body:
        bind cup: item where:
            is_cup(cup)
        find_cup(cup)

        bind milk: item where:
            is_milk(milk)
        fill_cup_with_milk(cup, milk)
# Case 26:
When the sub-task is: 2. Heat the cup of milk in the microwave.
A successful representation:
 
behavior locate_microwave(microwave:item):
    body:
        observe(microwave, "Find the microwave")

behavior heat_milk_in_microwave(cup:item, microwave:item):
    body:
        achieve inside(cup, microwave)
        # Place the cup inside the microwave
        achieve closed(microwave)
        # Close the microwave door to ensure proper heating
        achieve is_on(microwave)
        # Turn on the microwave to start heating

behavior __goal__():
    body:
        bind cup: item where:
            is_cup(cup) and id[cup] == 2087
        # Select the milk cup with ID 2087
        
        if exists microwave: item : is_microwave(microwave) and close_char(char, microwave):
            # If we already know where the microwave is, proceed to use it
            bind microwave: item where:
                is_microwave(microwave) and close_char(char, microwave)
            heat_milk_in_microwave(cup, microwave)

        else:
            # If the microwave is not known, locate it first
            foreach microwave: item:
                if is_microwave(microwave) and not visited(microwave):
                    locate_microwave(microwave)
                    # Locate an unvisited microwave and proceed once found
                    heat_milk_in_microwave(cup, microwave)

# Case 27:
When the sub-task is: 1. Find the book and put it on the coffee table in the home office.
A successful representation:
 
def is_book_found(book: item):
    # Check if the book has already been visited
    symbol found = visited(book)
    return found

behavior find_book(book:item):
    body:
        if is_book_found(book):
            # If the book is already found, move close to it
            achieve close_char(char, book)
        else:
            # Observe all unvisited books to locate the book
            foreach item: item:
                if is_book(item) and not visited(item):
                    observe(item, "Locate the book")

behavior place_book_on_coffee_table(book:item, coffee_table:item):
    body:
        achieve on(book, coffee_table)
        # Place the book on the coffee table

behavior __goal__():
    body:
        bind book: item where:
            is_book(book)
        find_book(book)

        bind home_office: item where:
            is_home_office(home_office)
        # Select the home office

        bind coffee_table: item where:
            is_coffee_table(coffee_table) and inside(coffee_table, home_office)
        # Select a coffee table inside the home office

        place_book_on_coffee_table(book, coffee_table)

# Case 28:
When the sub-task is: 2. Prepare a cup of hot milk and put it on the coffee table in the home office.
A successful representation:

behavior find_cup(cup:item):
    body:
        if visited(cup):
            achieve close_char(char, cup)
        else:
            observe(cup, "Locate the cup")
            achieve close_char(char, cup)

behavior fill_cup_with_milk(cup:item, milk:item):
    body:
        achieve inside(milk, cup)

behavior place_item_on_table(item:item, table:item):
    body:
        achieve on(item, table)

behavior heat_milk_in_microwave(cup:item, microwave:item):
    body:
        achieve inside(cup, microwave)
        achieve closed(microwave)
        achieve is_on(microwave)

behavior __goal__():
    body:
        bind home_office: item where:
            is_home_office(home_office)

        bind coffee_table: item where:
            is_table(coffee_table) and inside(coffee_table, home_office)

        bind cup: item where:
            is_cup(cup)
        find_cup(cup)

        bind milk: item where:
            is_milk(milk)
        fill_cup_with_milk(cup, milk)

        if exists microwave: item : is_microwave(microwave) and close_char(char, microwave):
            bind microwave: item where:
                is_microwave(microwave) and close_char(char, microwave)
            heat_milk_in_microwave(cup, microwave)
        else:
            foreach microwave: item:
                if is_microwave(microwave) and not visited(microwave):
                    observe(microwave, "Find the microwave")
                    heat_milk_in_microwave(cup, microwave)

        place_item_on_table(cup, coffee_table)

# Case 29:
When the sub-task is: 1. Locate the cat.
A successful representation:
def is_cat_found(cat: item):
    # Determine if the cat has been observed or is known to be in a specific location
    symbol found = visited(cat)
    return found

behavior find_cat(cat:item):
    body:
        if is_cat_found(cat):
            # If the cat is already found, ensure the character is close to it
            achieve close_char(char, cat)
        else:
            # If the cat is not found, observe all unvisited items that could be the cat to locate it
            foreach item: item:
                if is_cat(item) and not visited(item):
                   observe(item, "Locate the cat") 

behavior __goal__():
    body:
        bind cat: item where:
            is_cat(cat)
        find_cat(cat)
# Case 30:
When the sub-task is: 2. Gently touch the cat.
A successful representation:
behavior gently_touch_cat(cat:item):
    body:
        achieve close_char(char, cat)
        # Move close to the cat to ensure a gentle interaction
        achieve facing_char(char, cat)
        # Face the cat for clear visibility and interaction
        touch(cat)
        # Gently touch the cat

behavior __goal__():
    body:
        bind cat: item where:
            is_cat(cat)
        gently_touch_cat(cat)
# Case 31:
When the sub-task is: 1. Find the book and put it on the coffee table in the home office.
A successful representation:
 
def is_book_found(book: item):
    # Check if the book has already been visited
    symbol found = visited(book)
    return found

behavior find_book(book:item):
    body:
        if is_book_found(book):
            # If the book is already found, move close to it
            achieve close_char(char, book)
        else:
            # Observe all unvisited books to locate the book
            foreach item: item:
                if is_book(item) and not visited(item):
                    observe(item, "Locate the book")

behavior place_book_on_coffee_table(book:item, coffee_table:item):
    body:
        achieve on(book, coffee_table)
        # Place the book on the coffee table

behavior __goal__():
    body:
        bind book: item where:
            is_book(book)
        find_book(book)

        bind home_office: item where:
            is_home_office(home_office)
        # Select the home office

        bind coffee_table: item where:
            is_coffee_table(coffee_table) and inside(coffee_table, home_office)
        # Select a coffee table inside the home office

        place_book_on_coffee_table(book, coffee_table)

# Case 32:
When the sub-task is: 2. Open the window in the home office.
A successful representation:
 
behavior __goal__():
    body:
        bind home_office: item where:
            is_home_office(home_office)
        # Select the home office

        foreach window: item:
            if is_window(window) and inside(window, home_office):
                # Check all windows inside the home office
                achieve open(window)
                # Open each window in the home office

# Case 33:
When the sub-task is: Open the windows in the bathroom.
A successful representation:
 
behavior __goal__():
    body:
        bind bathroom: item where:
            is_bathroom(bathroom)
        # Select the bathroom

        foreach window: item:
            if is_window(window) and inside(window, bathroom):
                # Check all windows inside the bathroom
                achieve open(window)
                # Open each window in the bathroom

# Case 34:
When the sub-task is: 1. Identify the basket containing clothes.
A successful representation:
behavior move_clothes_to_washing_machine(clothes:item, washing_machine:item):
    body:
        achieve inside(clothes, washing_machine)
        # Place the clothes inside the washing machine
        
behavior __goal__():
    body:
        bind basket: item where:
            is_basket_for_clothes(basket) and id[basket] == 2078
        # Select the basket with specified ID containing the clothes

        bind clothes: item where:
            is_clothes(clothes) and inside(clothes, basket)
        # Bind clothes from the basket

        bind washing_machine: item where:
            is_washing_machine(washing_machine)
        # Select a washing machine

        move_clothes_to_washing_machine(clothes, washing_machine)
        # Move clothes from the basket to the washing machine
# Case 35:
When the sub-task is: 2. Transfer the clothes to the washing machine.
A successful representation:
behavior transfer_clothes_to_washing_machine(clothes:item, washing_machine:item):
    body:
        achieve inside(clothes, washing_machine)

behavior __goal__():
    body:
        bind basket_for_clothes: item where:
            is_basket_for_clothes(basket_for_clothes) and id[basket_for_clothes] == 2078
        # Select the basket with clothes that has the specified ID

        foreach clothes: item:
            if is_clothes(clothes) and inside(clothes, basket_for_clothes):
                # Transfer each piece of clothing from the basket to the washing machine
                bind washing_machine: item where:
                    is_washing_machine(washing_machine) and id[washing_machine] == 2079
                # Select the washing machine with the specified ID

                transfer_clothes_to_washing_machine(clothes, washing_machine)
# Case 36:
When the sub-task is: 3. Add soap to the washing machine.
A successful representation:
 
behavior __goal__():
    body:
        bind washing_machine: item where:
            is_washing_machine(washing_machine) and id[washing_machine] == 2079
        # Select the washing machine with ID 2079

        bind soap: item where:
            is_soap(soap)
        # Select the soap item

        achieve inside(soap, washing_machine)
        # Add the soap inside the washing machine

# Case 37:
When the sub-task is: 4. Run the washing machine to wash the clothes.
A successful representation:
behavior run_washing_machine(washing_machine:item):
    body:
        achieve closed(washing_machine)
        # Ensure the washing machine is closed
        achieve is_on(washing_machine)
        # Turn on the washing machine to run it

behavior __goal__():
    body:
        bind washing_machine: item where:
            is_washing_machine(washing_machine)
        # Select the washing machine

        run_washing_machine(washing_machine)
# Case 38:
When the sub-task is: 2. Place the cup of water in the freezer.
A successful representation:
 
def is_filled_with_water(cup: item):
    # Check if the cup is filled with water
    symbol has_water = has_water(cup)
    return has_water

behavior place_cup_in_freezer(cup:item, freezer:item):
    body:
        achieve inside(cup, freezer)
        # Place the cup inside the freezer

behavior __goal__():
    body:
        bind cup: item where:
            is_cup(cup) and id[cup] == 2087 and is_filled_with_water(cup)
        # Select the cup with ID 2087 that is filled with water

        bind freezer: item where:
            is_freezer(freezer) and open(freezer)
        # Select an open freezer

        place_cup_in_freezer(cup, freezer)

# Case 39:
When the sub-task is: 1. Locate the milk, turkey, egg, fish, and chicken.
A successful representation:

def has_food_inside(room: item):
    # Function to check if the dining room contains specific food items
    symbol has_milk = exists o: item : is_milk(o) and inside(o, room)
    symbol has_turkey = exists o: item : is_food_turkey(o) and inside(o, room)
    symbol has_egg = exists o: item : is_food_egg(o) and inside(o, room)
    symbol has_fish = exists o: item : is_food_fish(o) and inside(o, room)
    symbol has_chicken = exists o: item : is_food_chicken(o) and inside(o, room)
    return has_milk or has_turkey or has_egg or has_fish or has_chicken

behavior __goal__():
    body:
        if exists room: item : is_dining_room(room) and has_food_inside(room):
            # Using known information to approach the dining room containing the required food items
            bind room: item where:
                is_dining_room(room) and has_food_inside(room)
            achieve close_char(char, room)

        else:
            # If no food items found, inspect the dining room for unvisited items
            foreach room: item:
                if is_dining_room(room) and not visited(room):
                    observe(room, "Check for milk, turkey, egg, fish, and chicken in the dining room")

# Case 40:
When the sub-task is: 2. Place the milk, turkey, egg, fish, and chicken on the table in the dining room.
A successful representation:
behavior place_item_on_table(item:item, table:item):
    body:
        achieve on(item, table)

behavior __goal__():
    body:
        bind dining_room: item where:
            is_dining_room(dining_room)
        
        bind table: item where:
            is_table(table) and inside(table, dining_room)

        bind milk: item where:
            is_milk(milk)

        bind turkey: item where:
            is_food_turkey(turkey)
        
        bind egg: item where:
            is_food_egg(egg)

        bind fish: item where:
            is_food_fish(fish)

        bind chicken: item where:
            is_food_chicken(chicken)

        place_item_on_table(milk, table)
        place_item_on_table(turkey, table)
        place_item_on_table(egg, table)
        place_item_on_table(fish, table)
        place_item_on_table(chicken, table)
# Case 41:
When the sub-task is: 1. Locate a cup and fill it with milk.
A successful representation:
behavior find_cup(cup:item):
    body:
        if visited(cup):
            achieve close_char(char, cup)
        else:
            observe(cup, "Locate the cup")
            achieve close_char(char, cup)

behavior fill_cup_with_milk(cup:item, milk:item):
    body:
        achieve inside(milk, cup)
        
behavior __goal__():
    body:
        bind cup: item where:
            is_cup(cup)
        find_cup(cup)

        bind milk: item where:
            is_milk(milk)
        fill_cup_with_milk(cup, milk)
# Case 42:
When the sub-task is: 2. Heat the cup of milk in the microwave.
A successful representation:
behavior locate_microwave(microwave:item):
    body:
        observe(microwave, "Find the microwave")

behavior heat_milk_in_microwave(cup:item, microwave:item):
    body:
        achieve inside(cup, microwave)
        # Place the cup inside the microwave
        achieve closed(microwave)
        # Close the microwave door to ensure proper heating
        achieve is_on(microwave)
        # Turn on the microwave to start heating

behavior __goal__():
    body:
        bind cup: item where:
            is_cup(cup) and id[cup] == 2063
        # Select the milk cup with ID 2063
        
        if exists microwave: item : is_microwave(microwave) and close_char(char, microwave):
            # If we already know where the microwave is, proceed to use it
            bind microwave: item where:
                is_microwave(microwave) and close_char(char, microwave)
            heat_milk_in_microwave(cup, microwave)

        else:
            # If the microwave is not known, locate it first
            foreach microwave: item:
                if is_microwave(microwave) and not visited(microwave):
                    locate_microwave(microwave)
                    # Locate an unvisited microwave and proceed once found
                    heat_milk_in_microwave(cup, microwave)
# Case 43:
When the sub-task is: 1. Locate the book.
A successful representation:
 
def is_book_found(book: item):
    # Check if the book has already been visited
    symbol found = visited(book)
    return found

behavior find_book(book:item):
    body:
        if is_book_found(book):
            # If the book is already found, move close to it
            achieve close_char(char, book)
        else:
            # Observe all unvisited books to locate the book
            foreach item: item:
                if is_book(item) and not visited(item):
                    observe(item, "Locate the book")

behavior __goal__():
    body:
        bind book: item where:
            is_book(book)
        find_book(book)

# Case 44:
When the sub-task is: 2. Place the book on the coffee table in the home office.
A successful representation:
 
behavior place_book_on_coffee_table(book:item, coffee_table:item):
    body:
        achieve on(book, coffee_table)
        # Place the book on the coffee table

behavior __goal__():
    body:
        bind book: item where:
            is_book(book) and id[book]==2091
        # Select book with ID 2091

        bind home_office: item where:
            is_home_office(home_office)
        # Select the home office

        bind coffee_table: item where:
            is_table(coffee_table) and inside(coffee_table, home_office)
        # Select a coffee table inside the home office

        place_book_on_coffee_table(book, coffee_table) 

# Case 45:
When the sub-task is: 1. Find the spectacles and put them on the coffee table in the home office.
A successful representation:
behavior find_spectacles(spectacles: item):
    body:
        if visited(spectacles):
            # If the spectacles have already been found, move close to them
            achieve close_char(char, spectacles)
        else:
            # Observe all unvisited spectacles to locate them
            foreach item: item:
                if is_spectacles(item) and not visited(item):
                    observe(item, "Locate the spectacles")

behavior place_spectacles_on_coffee_table(spectacles:item, coffee_table:item):
    body:
        achieve on(spectacles, coffee_table)
        # Place the spectacles on the coffee table

behavior __goal__():
    body:
        bind spectacles: item where:
            is_spectacles(spectacles)
        find_spectacles(spectacles)

        bind home_office: item where:
            is_home_office(home_office)
        # Select the home office

        bind coffee_table: item where:
            is_coffee_table(coffee_table) and inside(coffee_table, home_office)
        # Select the coffee table inside the home office

        place_spectacles_on_coffee_table(spectacles, coffee_table)
# Case 46:
When the sub-task is: 2. Find the book and put it on the coffee table in the home office.
A successful representation:
 
def is_book_found(book: item):
    # Check if the book has already been visited
    symbol found = visited(book)
    return found

behavior find_book(book:item):
    body:
        if is_book_found(book):
            # If the book is already found, move close to it
            achieve close_char(char, book)
        else:
            # Observe all unvisited books to locate the book
            foreach item: item:
                if is_book(item) and not visited(item):
                    observe(item, "Locate the book")

behavior place_book_on_coffee_table(book:item, coffee_table:item):
    body:
        achieve on(book, coffee_table)
        # Place the book on the coffee table

behavior __goal__():
    body:
        bind book: item where:
            is_book(book)
        find_book(book)

        bind home_office: item where:
            is_home_office(home_office)
        # Select the home office

        bind coffee_table: item where:
            is_coffee_table(coffee_table) and inside(coffee_table, home_office)
        # Select a coffee table inside the home office

        place_book_on_coffee_table(book, coffee_table)

# Case 47:
When the sub-task is: Make a cup of coffee using the coffee maker.
A successful representation:
 
behavior place_cup_and_turn_on(coffee_maker: item, cup: item):
    body:
        achieve inside(cup, coffee_maker)
        # Put the cup inside the coffee maker

        achieve is_on(coffee_maker)
        # Turn on the coffee maker

behavior __goal__():
    body:
        bind coffee_maker: item where:
            is_coffe_maker(coffee_maker)
        # Select the coffee maker

        bind cup: item where:
            is_cup(cup)
        # Select a cup

        place_cup_and_turn_on(coffee_maker, cup)

# Case 48:
When the sub-task is: Get a cup of water.
A successful representation:
behavior find_cup(cup:item):
    body:
        if visited(cup):
            # If the cup has already been found, move close to it
            achieve close_char(char, cup)
        else:
            # Observe all unvisited cups to locate it
            foreach item: item:
                if is_cup(item) and not visited(item):
                    observe(item, "Locate the cup")

behavior fill_cup_with_water(cup:item):
    body:
        achieve has_water(cup)

behavior __goal__():
    body:
        bind cup: item where:
            is_cup(cup)
        find_cup(cup)
        fill_cup_with_water(cup)

# Case 49:
When the sub-task is: 1. Hand wash the jacket.
A successful representation:
 
behavior __goal__():
    body:
        bind jacket: item where:
            is_clothes_jacket(jacket)
        # Select the jacket for hand washing

        wash(jacket)
        # Perform hand washing on the jacket

# Case 50:
When the sub-task is: 2. Wash the jacket using a washing machine.
A successful representation:
 
behavior place_jacket_in_washing_machine(jacket:item, washing_machine:item):
    body:
        achieve inside(jacket, washing_machine)
        # Place the jacket inside the washing machine

behavior start_wash_cycle(washing_machine:item):
    body:
        achieve closed(washing_machine)
        # Ensure the washing machine door is closed
        achieve is_on(washing_machine)
        # Start the washing cycle

behavior __goal__():
    body:
        bind jacket: item where:
            is_clothes_jacket(jacket)
        # Select the jacket

        bind washing_machine: item where:
            is_washing_machine(washing_machine)
        # Select the washing machine

        place_jacket_in_washing_machine(jacket, washing_machine)
        start_wash_cycle(washing_machine)

# Case 51:
When the sub-task is: 1. Find a sink in the bathroom.
A successful representation:
behavior find_bathroom_sink(sink:item):
    body:
        if visited(sink):
            # If the sink has already been visited, ensure the character is close to it
            achieve close_char(char, sink)
        else:
            # Observe all unvisited sinks to locate the sink
            foreach item: item:
                if is_sink(item) and not visited(item):
                    observe(item, "Locate the sink in the bathroom")
                    
behavior __goal__():
    body:
        bind sink: item where:
            is_sink(sink)
        find_bathroom_sink(sink)
# Case 52:
When the sub-task is: 2. Fill the sink with water.
A successful representation:
 
behavior fill_sink_with_water(sink:item):
    body:
        achieve has_water(sink)

behavior __goal__():
    body:
        bind sink: item where:
            is_sink(sink) and id[sink] == 42
        # Select the sink with ID 42, which is in the bathroom
        
        fill_sink_with_water(sink)
        # Fill the selected sink with water

# Case 53:
When the sub-task is: Put soap in the sink to make the water soapy.
A successful representation:
 
def has_faucet(sink:item):
    # Determine whether this sink has a faucet
    symbol has_faucet=exists faucet:item: is_faucet(faucet) and close(faucet,sink)
    return has_faucet

behavior pour_soap_in_sink(soap:item, sink:item):
    body:
        achieve inside(soap, sink)
        # Place the soap inside the sink to make water soapy

behavior fill_sink_with_water(sink:item):
    body:
        if has_faucet(sink):
            bind faucet: item where:
                is_faucet(faucet) and close(faucet, sink)
            achieve_once is_on(faucet)
            # Turn on the faucet to fill the sink with water
            achieve has_water(sink)
            # Ensure the sink has water
            achieve_once is_off(faucet)
            # Turn off the faucet once the sink has water

behavior __goal__():
    body:
        bind sink: item where:
            is_sink(sink) and id[sink] == 42
        # Select the sink with ID 42
        
        bind soap: item where:
            is_soap(soap) and id[soap] == 2053
        # Select the soap item with ID 2053

        pour_soap_in_sink(soap, sink)
        fill_sink_with_water(sink)

# Case 54:
When the sub-task is: Clean the bathroom sink directly.
A successful representation:
behavior clean_sink(sink:item):
    body:
        achieve clean(sink)
        # Achieve the clean state for the sink

behavior __goal__():
    body:
        bind sink: item where:
            is_sink(sink)
        # Select a sink

        clean_sink(sink)
        # Clean the sink directly
# Case 55:
When the sub-task is: Make a cup of coffee using the coffee maker.
A successful representation:
 
behavior prepare_coffee(coffee_maker: item, cup: item):
    body:
        achieve inside(cup, coffee_maker)
        # Place the cup inside the coffee maker

        achieve is_on(coffee_maker)
        # Turn on the coffee maker to prepare coffee

behavior __goal__():
    body:
        bind coffee_maker: item where:
            is_coffe_maker(coffee_maker)
        # Select the coffee maker

        bind cup: item where:
            is_cup(cup)
        # Select a cup

        prepare_coffee(coffee_maker, cup)

# Case 56:
When the sub-task is: Turn on the TV with the remote control.
A successful representation:
 
behavior __goal__():
    body:
        bind remote_control: item where:
            is_remote_control(remote_control)
        # Select the remote control

        bind television: item where:
            is_television(television)
        # Select the television

        achieve_once inhand(remote_control)
        # Temporarily hold the remote control in hand

        achieve is_on(television)
        # Turn on the television

# Case 57:
When the sub-task is: 1. Find the sink you will use to wash the cat.  
A successful representation:
behavior find_sink(sink:item):
    body:
        if visited(sink):
            # If the sink has already been visited, ensure the character is close to it
            achieve close_char(char, sink)
        else:
            # Observe all unvisited sinks to locate the sink for washing the cat
            foreach item: item:
                if is_sink(item) and not visited(item):
                    observe(item, "Locate the sink to wash the cat")

behavior __goal__():
    body:
        bind sink: item where:
            is_sink(sink)
        find_sink(sink)
# Case 58:
When the sub-task is: 2. Wash the cat in the sink.
A successful representation:

def is_cat_found(cat: item):
    # Check if the cat has already been visited
    symbol found = visited(cat)
    return found

behavior find_cat(cat:item):
    body:
        if is_cat_found(cat):
            # If the cat is already found, move close to it
            achieve close_char(char, cat)
        else:
            # Observe all unvisited potential cat locations to locate the cat
            foreach item: item:
                if is_cat(item) and not visited(item):
                    observe(item, "Locate the cat")

def has_faucet(sink:item):
    # Determine whether the sink has a faucet nearby
    symbol has_faucet=exists faucet:item: is_faucet(faucet) and close(faucet,sink)
    return has_faucet

behavior clean_cat(cat:item, sink:item):
    body:
        achieve_once inside(cat, sink)
        # Ensure the cat is inside the sink for washing

        if has_faucet(sink):
            bind faucet: item where:
                is_faucet(faucet) and close(faucet, sink)
            achieve_once is_on(faucet)
            # Turn on the faucet to start washing

        wash(cat)
        # Wash the cat in the sink

        if has_faucet(sink):
            bind faucet: item where:
                is_faucet(faucet) and close(faucet, sink)
            achieve_once is_off(faucet)
            # Turn off the faucet after washing

behavior __goal__():
    body:
        bind sink: item where:
            is_sink(sink) and id[sink]==231
        # Select sink with ID 231

        bind cat: item where:
            is_cat(cat)
        find_cat(cat)
        # Ensure the cat is located

        clean_cat(cat, sink)
        # Clean the cat in the sink

# Case 59:
When the sub-task is: 1. Use the dishwasher to wash the bowls and plates.
A successful representation:

behavior load_dishwasher(o:item, dishwasher:item):
    body:
        achieve inside(o, dishwasher)
        # Place the item inside the dishwasher

behavior start_dishwasher(dishwasher:item):
    body:
        achieve closed(dishwasher) # Close the dishwasher door
        achieve is_on(dishwasher) # Turn on the dishwasher

behavior __goal__():
    body:
        bind dishwasher: item where:
            is_dishwasher(dishwasher)
        # Select a dishwasher
        
        foreach o: item:
        # Load all bowls and plates that need washing into the dishwasher
            if is_bowl(o) or is_plate(o):
                load_dishwasher(o, dishwasher)
                
        start_dishwasher(dishwasher) # Start the dishwasher

# Case 60:
When the sub-task is: 2. Wash the forks by hand.
A successful representation:
behavior __goal__():
    body:
        bind fork: item where:
            is_fork(fork) and id[fork]==2151
        # Select fork with ID 2151 for hand washing

        wash(fork)
        # Wash the fork by hand to complete the subtask of washing the forks by hand
# Case 61:
When the sub-task is: Turn on the lights in the bedroom. Then turn on the lights in the bathroom.
A successful representation:
 
behavior turn_on_lights_in_room(room:item):
    body:
        foreach light: item:
            if is_light(light) and inside(light, room):
                # Check all lights inside the specified room
                achieve is_on(light)
                # Turn on each light in the room

behavior __goal__():
    body:
        bind bedroom: item where:
            is_bedroom(bedroom)
        # Select the bedroom
        turn_on_lights_in_room(bedroom)
        # Turn on the lights in the bedroom

        bind bathroom: item where:
            is_bathroom(bathroom)
        # Select the bathroom
        turn_on_lights_in_room(bathroom)
        # Turn on the lights in the bathroom

# Case 62:
When the sub-task is: 1. Find a sink in the bathroom.
A successful representation:
behavior find_bathroom_sink(sink:item):
    body:
        if visited(sink):
            # If the sink has already been visited, ensure the character is close to it
            achieve close_char(char, sink)
        else:
            # Observe all unvisited sinks to locate the sink
            foreach item: item:
                if is_sink(item) and not visited(item):
                    observe(item, "Locate the sink in the bathroom")

behavior __goal__():
    body:
        bind sink: item where:
            is_sink(sink)
        find_bathroom_sink(sink)
# Case 63:
When the sub-task is: 2. Fill the sink with water.
A successful representation:
behavior __goal__():
    body:
        bind sink: item where:
            is_sink(sink) and id[sink] == 307
        # Select the sink with ID 307

        bind faucet: item where:
            is_faucet(faucet) and close(faucet, sink)
        # Select the faucet close to the sink_307

        achieve_once is_on(faucet)
        # Turn on the faucet to fill sink_307 with water

        achieve has_water(sink)
        # Fill the sink with water

        achieve_once is_off(faucet)
        # Turn off the faucet after filling the sink
# Case 64:
When the sub-task is: 3. Add soap to create soapy water.
A successful representation:
 
def has_faucet(sink:item):
    # Determine whether the sink has a faucet nearby
    symbol has_faucet=exists faucet:item: is_faucet(faucet) and close(faucet,sink)
    return has_faucet

behavior add_soap_to_sink(soap:item, sink:item):
    body:
        achieve inside(soap, sink)
        # Add the soap inside the sink to create soapy water

behavior __goal__():
    body:
        bind sink: item where:
            is_sink(sink) and id[sink]==307
        # Select the sink with ID 307
        
        bind soap: item where:
            is_soap(soap)
        # Select the soap

        add_soap_to_sink(soap, sink)
        # Add soap to the selected sink


# Case 65:
When the sub-task is: Clean the bathroom sink directly.
A successful representation:

behavior clean_sink(sink:item):
    body:
        achieve clean(sink)
        # Achieve the clean state for the sink

behavior __goal__():
    body:
        bind sink: item where:
            is_sink(sink)
        # Select a sink

        clean_sink(sink)
        # Clean the sink directly

# Case 66:
When the sub-task is: 1. Find the table in the dining room.
A successful representation:
behavior find_dining_room_table(dining_room:item):
    body:
        foreach table: item:
            if is_table(table) and inside(table, dining_room) and not visited(table):
                observe(table, "Locate the dining room table")

behavior __goal__():
    body:
        bind dining_room: item where:
            is_dining_room(dining_room)
        find_dining_room_table(dining_room)
# Case 67:
When the sub-task is: 2. Put the milk and egg on the table in the dining room.
A successful representation:
 
behavior place_item_on_table(item:item, table:item):
    body:
        achieve on(item, table)

behavior __goal__():
    body:
        bind dining_room: item where:
            is_dining_room(dining_room)

        bind table: item where:
            is_table(table) and inside(table, dining_room)

        bind milk: item where:
            is_milk(milk)

        bind egg: item where:
            is_food_egg(egg)

        place_item_on_table(milk, table)
        place_item_on_table(egg, table)

# Case 68:
When the sub-task is: 3. Remove all items from the fridge and throw them into the trashcan.
A successful representation:

behavior remove_items_from_fridge_to_trashcan(item:item, trashcan:item):
    body:
        achieve inside(item, trashcan)
        # Move the item from fridge to trashcan

behavior __goal__():
    body:
        bind fridge: item where:
            is_freezer(fridge) and id[fridge] == 140
        # Select the fridge with ID 140

        bind trashcan: item where:
            is_trashcan(trashcan)
        # Select the trashcan

        foreach item: item:
        # Remove all items from the fridge and throw them into the trashcan
            if inside(item, fridge):
                remove_items_from_fridge_to_trashcan(item, trashcan)

# Case 69:
When the sub-task is: 4. Put the milk and eggs back in the fridge.
A successful representation:
behavior __goal__():
    body:
        bind table: item where:
            is_table(table) and id[table] == 123
        # Select the table with ID 123 where the milk and egg are placed

        bind milk: item where:
            is_milk(milk) and on(milk, table)
        # Select the milk on the table

        bind egg: item where:
            is_food_egg(egg) and on(egg, table)
        # Select the egg on the table

        bind fridge: item where:
            is_freezer(fridge) and id[fridge] == 140
        # Select the fridge with ID 140

        achieve inside(milk, fridge)
        # Put the milk back inside the fridge

        achieve inside(egg, fridge)
        # Put the egg back inside the fridge
# Case 70:
When the sub-task is: 1. Identify all the windows in the house.
A successful representation:
behavior observe_all_windows_in_house():
    body:
        foreach window: item:
            if is_window(window) and not visited(window):
                observe(window, "Identify the window in the house")

behavior __goal__():
    body:
        observe_all_windows_in_house()
# Case 71:
When the sub-task is: 2. Wipe each window with a towel.
A successful representation:
behavior wipe_window_with_towel(window:item, towel:item):
    body:
        achieve_once inhand(towel)
        achieve clean(window)

behavior __goal__():
    body:
        foreach window: item:
            if is_window(window):
                bind towel: item where:
                    is_towel(towel)
                wipe_window_with_towel(window, towel)
# Case 72:
When the sub-task is: Turn on the lights in the bathroom.
A successful representation:
 
behavior __goal__():
    body:
        bind bathroom: item where:
            is_bathroom(bathroom)
        # Select the bathroom

        bind light: item where:
            is_light(light) and inside(light, bathroom)
        # Select the light inside the bathroom

        achieve is_on(light)
        # Turn on the light in the bathroom

# Case 73:
When the sub-task is: 1. Identify the basket that contains clothes.
A successful representation:
behavior identify_basket_with_clothes(basket:item):
    body:
        observe(basket, "Check if this basket contains clothes")

behavior __goal__():
    body:
        foreach basket: item:
            if is_basket_for_clothes(basket) and not visited(basket):
                identify_basket_with_clothes(basket)
# Case 74:
When the sub-task is: 2. Add the clothes from the basket into the washing machine.
A successful representation:
 
def has_clothes_inside(basket:item):
    # Check if the basket contains any clothes
    symbol has_clothes = exists o: item : is_clothes(o) and inside(o, basket)
    return has_clothes

behavior transfer_clothes_to_washing_machine(clothes:item, washing_machine:item):
    body:
        achieve inside(clothes, washing_machine)

behavior __goal__():
    body:
        bind basket: item where:
            is_basket_for_clothes(basket) and id[basket] == 2006
        # Select the basket with clothes (specified by ID 2006)

        if has_clothes_inside(basket):
            bind washing_machine: item where:
                is_washing_machine(washing_machine) and id[washing_machine] == 2007
            # Select the washing machine (specified by ID 2007)

            foreach clothes: item:
                if is_clothes(clothes) and inside(clothes, basket):
                    transfer_clothes_to_washing_machine(clothes, washing_machine)

# Case 75:
When the sub-task is: 3. Add soap to the washing machine.
A successful representation:
behavior __goal__():
    body:
        bind washing_machine: item where:
            is_washing_machine(washing_machine) and id[washing_machine] == 2007
        # Select the washing machine with ID 2007

        bind soap: item where:
            is_soap(soap)
        # Select the soap item

        achieve inside(soap, washing_machine)
        # Add the soap inside the washing machine
# Case 76:
When the sub-task is: 4. Run the washing machine.
A successful representation:
 
behavior run_washing_machine(washing_machine:item):
    body:
        achieve closed(washing_machine)
        # Ensure the washing machine is closed
        achieve is_on(washing_machine)
        # Turn on the washing machine to run it

behavior __goal__():
    body:
        bind washing_machine: item where:
            is_washing_machine(washing_machine)
        # Select the washing machine

        run_washing_machine(washing_machine)

# Case 77:
When the sub-task is: 1. Find the basket containing clothes.
A successful representation:
behavior identify_basket_with_clothes(basket:item):
    body:
        observe(basket, "Check if this basket contains clothes")

behavior __goal__():
    body:
        foreach basket: item:
            if is_basket_for_clothes(basket) and not visited(basket):
                identify_basket_with_clothes(basket)
# Case 78:
When the sub-task is: 2. Put all the clothes from the basket into the washing machine and start the washing process.
A successful representation:
behavior transfer_clothes_to_washing_machine(clothes:item, washing_machine:item):
    body:
        achieve inside(clothes, washing_machine)

behavior start_wash_cycle(washing_machine:item):
    body:
        achieve closed(washing_machine)
        # Ensure the washing machine is closed
        achieve is_on(washing_machine)
        # Start the washing cycle

behavior __goal__():
    body:
        bind basket_for_clothes: item where:
            is_basket_for_clothes(basket_for_clothes) and id[basket_for_clothes] == 2040
        # Select the basket containing clothes with ID 2040

        bind washing_machine: item where:
            is_washing_machine(washing_machine) and id[washing_machine] == 2041
        # Select the washing machine with ID 2041

        foreach clothes: item:
            if is_clothes(clothes) and inside(clothes, basket_for_clothes):
                transfer_clothes_to_washing_machine(clothes, washing_machine)
        
        start_wash_cycle(washing_machine)
# Case 79:
When the sub-task is: 1. Find the chicken.
A successful representation:
behavior find_chicken(chicken:item):
    body:
        if visited(chicken):
            # If the chicken has already been found, ensure the character is close to it
            achieve close_char(char, chicken)
        else:
            # If the chicken is not found, observe all unvisited items that could be the chicken to locate it
            foreach item: item:
                if is_food_chicken(item) and not visited(item):
                    observe(item, "Locate the chicken")

behavior __goal__():
    body:
        bind chicken: item where:
            is_food_chicken(chicken)
        find_chicken(chicken)
# Case 80:
When the sub-task is: 2. Slice the chicken.
A successful representation:
 
behavior slice_chicken(chicken:item):
    body:
        achieve cut(chicken)
        # Ensure the chicken is sliced

behavior __goal__():
    body:
        bind chicken: item where:
            is_food_chicken(chicken)
        # Select the chicken

        slice_chicken(chicken)
        # Slice the chicken

# Case 81:
When the sub-task is: 3. Give the sliced chicken to your cat.
A successful representation:
 
def is_cat_found(cat: item):
    # Determine if the cat has been observed or is known to be in a specific location
    symbol found = visited(cat)
    return found

behavior find_cat(cat:item):
    body:
        if is_cat_found(cat):
            # If the cat is already found, ensure the character is close to it
            achieve close_char(char, cat)
        else:
            # If the cat is not found, observe all unvisited items that could be the cat to locate it
            foreach item: item:
                if is_cat(item) and not visited(item):
                    observe(item, "Locate the cat")

behavior place_sliced_chicken_for_cat(chicken:item, cat:item):
    body:
        achieve close(chicken, cat)
        # Place the sliced chicken close to the cat
        
behavior __goal__():
    body:
        bind cat: item where:
            is_cat(cat)
        find_cat(cat)

        bind sliced_chicken: item where:
            is_food_chicken(sliced_chicken) and cut(sliced_chicken)
        
        place_sliced_chicken_for_cat(sliced_chicken, cat)

# Case 82:
When the sub-task is: Turn on the computer in the home office.
A successful representation:
 
behavior __goal__():
    body:
        bind home_office: item where:
            is_home_office(home_office)
        # Select the home office

        bind computer: item where:
            is_computer(computer) and inside(computer, home_office)
        # Select the computer inside the home office

        achieve is_on(computer)
        # Turn on the computer in the home office

# Case 83:
When the sub-task is: 1. Find the spectacles and put them on the coffee table in the home office.
A successful representation:
behavior find_spectacles(spectacles: item):
    body:
        if visited(spectacles):
            # If the spectacles have already been found, move close to them
            achieve close_char(char, spectacles)
        else:
            # Observe all unvisited spectacles to locate them
            foreach item: item:
                if is_spectacles(item) and not visited(item):
                    observe(item, "Locate the spectacles")

behavior place_spectacles_on_coffee_table(spectacles:item, coffee_table:item):
    body:
        achieve on(spectacles, coffee_table)
        # Place the spectacles on the coffee table

behavior __goal__():
    body:
        bind spectacles: item where:
            is_spectacles(spectacles)
        find_spectacles(spectacles)

        bind home_office: item where:
            is_home_office(home_office)
        # Select the home office

        bind coffee_table: item where:
            is_coffee_table(coffee_table) and inside(coffee_table, home_office)
        # Select the coffee table inside the home office

        place_spectacles_on_coffee_table(spectacles, coffee_table)
# Case 84:
When the sub-task is: 2. Find the book and put it on the coffee table in the home office.
A successful representation:
 
def is_book_found(book: item):
    # Check if the book has already been visited
    symbol found = visited(book)
    return found

behavior find_book(book:item):
    body:
        if is_book_found(book):
            # If the book is already found, move close to it
            achieve close_char(char, book)
        else:
            # Observe all unvisited books to locate the book
            foreach item: item:
                if is_book(item) and not visited(item):
                    observe(item, "Locate the book")

behavior place_book_on_coffee_table(book:item, coffee_table:item):
    body:
        achieve on(book, coffee_table)
        # Place the book on the coffee table

behavior __goal__():
    body:
        bind book: item where:
            is_book(book)
        find_book(book)

        bind home_office: item where:
            is_home_office(home_office)
        # Select the home office

        bind coffee_table: item where:
            is_coffee_table(coffee_table) and inside(coffee_table, home_office)
        # Select a coffee table inside the home office

        place_book_on_coffee_table(book, coffee_table)

# Case 85:
When the sub-task is: Turn on the lights in the bathroom.
A successful representation:
 
behavior __goal__():
    body:
        bind bathroom: item where:
            is_bathroom(bathroom)
        # Select the bathroom

        bind light: item where:
            is_light(light) and inside(light, bathroom)
        # Select the light inside the bathroom

        achieve is_on(light)
        # Turn on the light in the bathroom

# Case 86:
When the sub-task is: 1. Brew a cup of coffee using the coffee maker.
A successful representation:
 
behavior place_cup_and_brew_coffee(coffee_maker: item, cup: item):
    body:
        achieve inside(cup, coffee_maker)
        # Place the cup inside the coffee maker

        achieve is_on(coffee_maker)
        # Turn on the coffee maker to brew coffee

behavior __goal__():
    body:
        bind coffee_maker: item where:
            is_coffe_maker(coffee_maker)
        # Select the coffee maker

        bind cup: item where:
            is_cup(cup)
        # Select a cup

        place_cup_and_brew_coffee(coffee_maker, cup)

# Case 87:
When the sub-task is: 2. Add milk and sugar to the brewed coffee.
A successful representation:
behavior prepare_coffee_cup_with_additions(cup:item, milk:item, sugar:item):
    body:
        bind coffee_maker: item where:
            is_coffe_maker(coffee_maker)
        # Select the coffee maker

        achieve inside(cup, coffee_maker)
        # Position the cup inside the coffee maker to collect brewed coffee

        achieve is_on(coffee_maker)
        # Switch on the coffee maker

        achieve inside(milk, cup)
        # Add milk to the brewed coffee in the cup

        achieve inside(sugar, cup)
        # Add sugar to the brewed coffee in the cup

behavior __goal__():
    body:
        bind cup: item where:
            is_cup(cup) and id[cup] == 2064
        # Select the cup used for brewing coffee

        bind milk: item where:
            is_milk(milk)
        # Select the milk

        bind sugar: item where:
            is_food_sugar(sugar)
        # Select the sugar

        prepare_coffee_cup_with_additions(cup, milk, sugar)
# Case 88:
When the sub-task is: 1. Load the bowls and plates into the dishwasher.
A successful representation:
behavior load_dishwasher(item:item, dishwasher:item):
    body:
        achieve inside(item, dishwasher)
        # Place the item inside the dishwasher

behavior __goal__():
    body:
        bind dishwasher: item where:
            is_dishwasher(dishwasher)
        # Select the dishwasher
        
        foreach item: item:
        # Load all bowls and plates inside the dishwasher
            if is_bowl(item) or is_plate(item):
                load_dishwasher(item, dishwasher)
        # Load each bowl and plate into the dishwasher
# Case 89:
When the sub-task is: 2. Start the dishwasher to wash the bowls and plates.
A successful representation:
behavior start_dishwasher(dishwasher:item):
    body:
        achieve closed(dishwasher)
        # Ensure the dishwasher door is closed
        achieve is_on(dishwasher)
        # Turn on the dishwasher to start washing

behavior __goal__():
    body:
        bind dishwasher: item where:
            is_dishwasher(dishwasher)
        # Select the dishwasher

        start_dishwasher(dishwasher)
        # Start the dishwasher to wash the bowls and plates
# Case 90:
When the sub-task is: 3. Wash the forks by hand.
A successful representation:
 
behavior __goal__():
    body:
        foreach fork: item:
            if is_fork(fork):
                wash(fork)

# Case 91:
When the sub-task is: 1. Find a couch and sit on it.
A successful representation:
behavior find_couch(couch:item):
    body:
        if visited(couch):
            # If the couch has been found, approach it
            achieve close_char(char, couch)
        else:
            # If the couch is not yet found, observe all items that could be a couch
            foreach item: item:
                if is_couch(item) and not visited(item):
                    observe(item, "Locate the couch")

behavior sit_on_couch(couch:item):
    body:
        achieve on_char(char, couch)
        # Sit on the couch

behavior __goal__():
    body:
        bind couch: item where:
            is_couch(couch)
        find_couch(couch)
        sit_on_couch(couch)
# Case 92:
When the sub-task is: 2. Use the remote control to turn on the TV.
A successful representation:
 
behavior __goal__():
    body:
        bind remote_control: item where:
            is_remote_control(remote_control)
        # Select the remote control

        bind television: item where:
            is_television(television)
        # Select the television

        achieve_once inhand(remote_control)
        # Temporarily hold the remote control in hand

        achieve is_on(television)
        # Turn on the television

# Case 93:
When the sub-task is: 1. Identify all the rooms in the house.
A successful representation:
 
def is_room_found(room: item):
    # Check if the room has already been visited
    symbol found = visited(room)
    return found

behavior find_rooms(room:item):
    body:
        if is_room_found(room):
            # If the room is already found, ensure character is close to it
            achieve close_char(char, room)
        else:
            # Observe all unvisited rooms to identify them
            foreach item: item:
                if is_room(item) and not visited(item):
                    observe(item, "Identify the room")

behavior __goal__():
    body:
        foreach room: item:
            if is_room(room):
                find_rooms(room)

# Case 94:
When the sub-task is: 2. Check if each room has a light on.
A successful representation:
behavior check_lights_in_room(room:item):
    body:
        foreach light: item:
            if is_light(light) and inside(light, room):
                # Verify if the light inside the room is on
                if not is_on(light):
                    observe(light, "Check if the light is on in the room")
                # Observe the light only if its not confirmed to be on

behavior __goal__():
    body:
        foreach room: item:
            # Check each identified room to ensure lights are on
            check_lights_in_room(room)
# Case 95:
When the sub-task is: 3. Turn on a light in rooms where no light is currently on.
A successful representation:
 
def is_light_off(light: item):
    # Function to check if a light is off
    symbol light_is_off = is_off(light)
    return light_is_off

behavior turn_on_light_if_off(light:item):
    body:
        if is_light_off(light):
            achieve is_on(light)
        # Turn on the light if it is off

behavior __goal__():
    body:
        bind bathroom: item where:
            is_bathroom(bathroom)
        # Check and turn on bathroom lights
        foreach light: item:
            if is_light(light) and inside(light, bathroom):
                turn_on_light_if_off(light)
                
        bind bedroom: item where:
            is_bedroom(bedroom)
        # Check and turn on bedroom lights
        foreach light: item:
            if is_light(light) and inside(light, bedroom):
                turn_on_light_if_off(light)

        bind dining_room: item where:
            is_dining_room(dining_room)
        # Check and turn on dining room lights
        foreach light: item:
            if is_light(light) and inside(light, dining_room):
                turn_on_light_if_off(light)

        bind home_office: item where:
            is_home_office(home_office)
        # Check and turn on home office lights
        foreach light: item:
            if is_light(light) and inside(light, home_office):
                turn_on_light_if_off(light)

# Case 96:
When the sub-task is: Use the pot to boil some water.
A successful representation:
behavior pour_water_into_pot(pot:item):
    body:
        achieve has_water(pot)

behavior turn_on_stove_for_pot(pot:item, stove:item):
    body:
        achieve on(pot, stove)
        # Ensure the pot is on the stove
        achieve is_on(stove)
        # Turn on the stove

behavior __goal__():
    body:
        bind pot: item where:
            is_pot(pot)
        # Select the pot

        bind stove: item where:
            is_stove(stove)
        # Select the stove

        pour_water_into_pot(pot)
        turn_on_stove_for_pot(pot, stove)
# Case 97:
When the sub-task is: 1. Find the book.  
A successful representation:
 
def is_book_found(book: item):
    # Check if the book has already been visited
    symbol found = visited(book)
    return found

behavior find_book(book:item):
    body:
        if is_book_found(book):
            # If the book is already found, move close to it
            achieve close_char(char, book)
        else:
            # Observe all unvisited books to locate the book
            foreach item: item:
                if is_book(item) and not visited(item):
                    observe(item, "Locate the book")

behavior __goal__():
    body:
        bind book: item where:
            is_book(book)
        find_book(book)
 
# Case 98:
When the sub-task is: 2. Put the book on the coffee table in the home office.
A successful representation:
behavior place_book_on_coffee_table(book:item, coffee_table:item):
    body:
        achieve on(book, coffee_table)
        # Place the book on the coffee table

behavior __goal__():
    body:
        bind book: item where:
            is_book(book)
        # Select the book

        bind home_office: item where:
            is_home_office(home_office)
        # Select the home office

        bind coffee_table: item where:
            is_table(coffee_table) and inside(coffee_table, home_office)
        # Select a coffee table inside the home office

        place_book_on_coffee_table(book, coffee_table)
# Case 99:
When the sub-task is: 1. Wash all the vegetables.
A successful representation:
behavior wash_vegetables(vegetable:item):
    body:
        wash(vegetable)
        # Wash the vegetable

behavior __goal__():
    body:
        foreach vegetable: item:
            if is_food_vegetable(vegetable):
                wash_vegetables(vegetable)
                # Wash each vegetable that is found to be a food vegetable
# Case 100:
When the sub-task is: 2. Put the washed vegetables in a pot and boil them on the stove.
A successful representation:
behavior place_vegetables_in_pot(vegetable:item, pot:item):
    body:
        achieve inside(vegetable, pot)

behavior boil_vegetables_on_stove(pot:item, stove:item):
    body:
        achieve on(pot, stove)
        achieve is_on(stove)

behavior __goal__():
    body:
        bind stove: item where:
            is_stove(stove)
        # Select the stove

        bind pot: item where:
            is_pot(pot)
        # Select the pot

        foreach vegetable: item:
            if is_food_vegetable(vegetable) and clean(vegetable):
                place_vegetables_in_pot(vegetable, pot)
                # Place washed vegetables in the pot

        boil_vegetables_on_stove(pot, stove)
        # Boil the vegetables on the stove
# Case 101:
When the sub-task is: 3. Store the pot in the fridge.
A successful representation:
 
behavior __goal__():
    body:
        bind fridge: item where:
            is_fridge(fridge) and id[fridge] == 126
        # Select the fridge with ID 126

        bind pot: item where:
            is_pot(pot) and id[pot] == 2138
        # Select the pot with ID 2138

        achieve inside(pot, fridge)
        # Place the pot inside the fridge

# Case 102:
When the sub-task is: Boil some rice in a pot.
A successful representation:
 
def is_rice_in_pot(pot:item):
    # Check if the pot contains rice
    symbol has_rice = exists rice: item : is_food_rice(rice) and inside(rice, pot)
    return has_rice

behavior add_rice_to_pot(rice:item, pot:item):
    body:
        achieve inside(rice, pot)
        # Add rice to the pot

behavior __goal__():
    body:
        bind pot: item where:
            is_pot(pot) and has_water(pot)
        # Select the pot that has water

        bind stove: item where:
            is_stove(stove) and on(pot, stove) and is_on(stove)
        # Select the stove that has the pot on it and is on

        if not is_rice_in_pot(pot):
            bind rice: item where:
                is_food_rice(rice)
            # Select rice

            add_rice_to_pot(rice, pot)
        # Add rice to the pot if it is not already inside

# Case 103:
When the sub-task is: Boil some rice in the pot.
A successful representation:
behavior pour_water_into_pot(pot:item):
    body:
        achieve has_water(pot)

behavior add_rice_to_pot(rice:item, pot:item):
    body:
        achieve inside(rice, pot)

behavior boil_rice_on_stove(pot:item, stove:item):
    body:
        achieve on(pot, stove)
        achieve is_on(stove)

behavior __goal__():
    body:
        bind pot: item where:
            is_pot(pot)
        # Select a pot
        
        bind stove: item where:
            is_stove(stove)
        # Select a stove
        
        bind rice: item where:
            is_food_rice(rice)
        # Select rice

        pour_water_into_pot(pot)
        add_rice_to_pot(rice, pot)
        boil_rice_on_stove(pot, stove)
# Case 104:
When the sub-task is: Get a cup of water.
A successful representation:
behavior find_cup(cup:item):
    body:
        if visited(cup):
            # If the cup has already been found, move close to it
            achieve close_char(char, cup)
        else:
            # Observe all unvisited cups to locate it
            foreach item: item:
                if is_cup(item) and not visited(item):
                    observe(item, "Locate the cup")

behavior fill_cup_with_water(cup:item):
    body:
        achieve has_water(cup)

behavior __goal__():
    body:
        bind cup: item where:
            is_cup(cup)
        find_cup(cup)
        fill_cup_with_water(cup)
# Case 105:
When the sub-task is: 1. Hand wash the jacket.
A successful representation:

behavior __goal__():
    body:
        bind jacket: item where:
            is_clothes_jacket(jacket)
        # Select the jacket for hand washing

        wash(jacket)
        # Perform hand washing on the jacket

# Case 106:
When the sub-task is: 2. Wash the jacket using the washing machine.
A successful representation:

behavior place_jacket_in_washing_machine(jacket:item, washing_machine:item):
    body:
        achieve inside(jacket, washing_machine)
        # Place the jacket inside the washing machine

behavior start_wash_cycle(washing_machine:item):
    body:
        achieve closed(washing_machine)
        # Ensure the washing machine door is closed
        achieve is_on(washing_machine)
        # Start the washing cycle

behavior __goal__():
    body:
        bind jacket: item where:
            is_clothes_jacket(jacket)
        # Select the jacket

        bind washing_machine: item where:
            is_washing_machine(washing_machine)
        # Select the washing machine

        place_jacket_in_washing_machine(jacket, washing_machine)
        start_wash_cycle(washing_machine)

# Case 107:
When the sub-task is: 1. Wash the bowls and plates using the dishwasher.
A successful representation:
 
behavior load_dishwasher(o:item, dishwasher:item):
    body:
        achieve inside(o, dishwasher)
        # Place the item inside the dishwasher

behavior start_dishwasher(dishwasher:item):
    body:
        achieve closed(dishwasher) # Close the dishwasher door
        achieve is_on(dishwasher) # Turn on the dishwasher

behavior __goal__():
    body:
        bind dishwasher: item where:
            is_dishwasher(dishwasher)
        # Select a dishwasher

        foreach o: item:
        # Load all bowls and plates into the dishwasher
            if is_bowl(o) or is_plate(o):
                load_dishwasher(o, dishwasher)

        start_dishwasher(dishwasher) # Start the dishwasher

# Case 108:
When the sub-task is: 2. Wash the forks by hand.
A successful representation:

behavior __goal__():
    body:
        foreach fork: item:
            if is_fork(fork):
                wash(fork)

# Case 109:
When the sub-task is: Turn on the lights in the bedroom, then turn on the lights in the bathroom.
A successful representation:
 
behavior turn_on_lights_in_room(room:item):
    body:
        foreach light: item:
            if is_light(light) and inside(light, room):
                # Check all lights inside the specified room
                achieve is_on(light)
                # Turn on each light in the room

behavior __goal__():
    body:
        bind bedroom: item where:
            is_bedroom(bedroom)
        # Select the bedroom
        turn_on_lights_in_room(bedroom)
        # Turn on the lights in the bedroom

        bind bathroom: item where:
            is_bathroom(bathroom)
        # Select the bathroom
        turn_on_lights_in_room(bathroom)
        # Turn on the lights in the bathroom

# Case 110:
When the sub-task is: 1. Get a cup and fill it with water.
A successful representation:
behavior find_cup(cup:item):
    body:
        if visited(cup):
            # If the cup has already been found, move close to it
            achieve close_char(char, cup)
        else:
            # Observe all unvisited cups to locate a cup
            foreach item: item:
                if is_cup(item) and not visited(item):
                    observe(item, "Locate the cup")

behavior fill_cup_with_water(cup:item):
    body:
        achieve has_water(cup)
        # Fill the cup with water

behavior __goal__():
    body:
        bind cup: item where:
            is_cup(cup)
        find_cup(cup)
        fill_cup_with_water(cup)
# Case 111:
When the sub-task is: 2. Slice the kiwi and add it to the cup of water.
A successful representation:
behavior slice_kiwi_and_add_to_cup(food_kiwi:item, cup:item):
    body:
        achieve cut(food_kiwi)
        # Slice the kiwi

        achieve inside(food_kiwi, cup)
        # Add the sliced kiwi to the cup of water

behavior __goal__():
    body:
        bind food_kiwi: item where:
            is_food_kiwi(food_kiwi) and cuttable(food_kiwi)
        # Select the kiwi that is cuttable

        bind cup: item where:
            is_cup(cup) and has_water(cup)
        # Select a cup that has water

        slice_kiwi_and_add_to_cup(food_kiwi, cup)
        # Slice the kiwi and add it to the cup of water
# Case 112:
When the sub-task is: 1. Find a sink suitable for washing your cat.
A successful representation:
 
def is_sink_cleanable(sink: item):
    # Function to check if the sink can be cleaned (ie, it is dirty)
    symbol cleanable_sink = dirty(sink)
    return cleanable_sink

behavior clean_sink(sink: item):
    body:
        if is_sink_cleanable(sink):
            scrub(sink)
            # Scrub and wash the sink if it is dirty

behavior __goal__():
    body:
        if exists sink: item : is_sink(sink) and dirty(sink):
            # If a dirty sink is already known, proceed to clean it
            bind sink: item where:
                is_sink(sink) and dirty(sink)
            clean_sink(sink)

        else:
            # Check all sinks that have not been visited for cleanliness
            foreach sink: item:
                if is_sink(sink) and not visited(sink):
                    observe(sink, "Check if this sink is suitable for washing the cat")
                    if dirty(sink):
                        clean_sink(sink)

# Case 113:
When the sub-task is: 1. Locate all the windows in the house.
A successful representation:
behavior observe_all_windows_in_house():
    body:
        foreach window: item:
            if is_window(window) and not visited(window):
                observe(window, "Identify the window in the house")

behavior __goal__():
    body:
        observe_all_windows_in_house()
# Case 114:
When the sub-task is: 2. Wipe each window with a towel.
A successful representation:
 
behavior wipe_window_with_towel(window:item, towel:item):
    body:
        achieve_once inhand(towel)
        achieve clean(window)

behavior __goal__():
    body:
        foreach window: item:
            if is_window(window):
                bind towel: item where:
                    is_towel(towel)
                wipe_window_with_towel(window, towel)

# Case 115:
When the sub-task is: 2. Put the vegetables in a pot and boil them on the stove.
A successful representation:
behavior place_vegetables_in_pot(vegetable:item, pot:item):
    body:
        achieve inside(vegetable, pot)

behavior boil_vegetables_on_stove(pot:item, stove:item):
    body:
        achieve on(pot, stove)
        achieve is_on(stove)

behavior __goal__():
    body:
        bind pot: item where:
            is_pot(pot)
        # Select the pot

        bind stove: item where:
            is_stove(stove)
        # Select the stove

        foreach vegetable: item:
            if is_food_vegetable(vegetable) and clean(vegetable):
                place_vegetables_in_pot(vegetable, pot)
                # Place the washed vegetables in the pot

        boil_vegetables_on_stove(pot, stove)
        # Boil the vegetables on the stove
# Case 116:
When the sub-task is: 3. Transfer the boiled vegetables to a bowl to cool.
A successful representation:
def is_boiled_vegetables(pot: item):
    # Check if the vegetables are boiled in the pot
    symbol boiled = exists vegetable: item : is_food_vegetable(vegetable) and inside(vegetable, pot)
    return boiled

behavior transfer_vegetables_to_bowl(boiled_vegetables: item, bowl: item):
    body:
        achieve inside(boiled_vegetables, bowl)

behavior __goal__():
    body:
        bind pot: item where:
            is_pot(pot) and is_boiled_vegetables(pot)
        # Select the pot containing boiled vegetables

        bind bowl: item where:
            is_bowl(bowl)
        # Select a bowl

        foreach vegetable: item:
            if is_food_vegetable(vegetable) and inside(vegetable, pot):
                transfer_vegetables_to_bowl(vegetable, bowl)
                # Transfer each boiled vegetable from the pot to the bowl
# Case 117:
When the sub-task is: 1. Find the table in the dining room and place milk and eggs on it.
A successful representation:
 
behavior place_item_on_table(item:item, table:item):
    body:
        achieve on(item, table)

behavior __goal__():
    body:
        bind dining_room: item where:
            is_dining_room(dining_room)
        
        bind table: item where:
            is_table(table) and inside(table, dining_room)

        bind milk: item where:
            is_milk(milk)

        bind egg: item where:
            is_food_egg(egg)

        place_item_on_table(milk, table)
        place_item_on_table(egg, table)

# Case 118:
When the sub-task is: 2. Remove all items from the fridge and throw them into the trashcan.
A successful representation:
behavior remove_items_from_fridge_to_trashcan(item:item, trashcan:item):
    body:
        achieve inside(item, trashcan)
        # Move the item from fridge to trashcan

behavior __goal__():
    body:
        bind fridge: item where:
            is_fridge(fridge) and id[fridge] == 289
        # Select the fridge with ID 289

        bind trashcan: item where:
            is_trashcan(trashcan)
        # Select the trashcan

        foreach item: item:
        # Remove all items from the fridge and throw them into the trashcan
            if inside(item, fridge):
                remove_items_from_fridge_to_trashcan(item, trashcan)
# Case 119:
When the sub-task is: 3. Put the milk and eggs back in the fridge.
A successful representation:
 
behavior __goal__():
    body:
        bind table: item where:
            is_table(table) and id[table] == 226
        # Select the table with ID 226 where the milk and eggs are placed initially

        bind milk: item where:
            is_milk(milk) and on(milk, table)
        # Select the milk on the table

        bind egg: item where:
            is_food_egg(egg) and on(egg, table)
        # Select the egg on the table

        bind fridge: item where:
            is_fridge(fridge) and id[fridge] == 289
        # Select the fridge with ID 289

        achieve inside(milk, fridge)
        # Put the milk back inside the fridge

        achieve inside(egg, fridge)
        # Put the egg back inside the fridge

# Case 120:
When the sub-task is: 1. Identify the basket containing clothes.
A successful representation:
 
behavior identify_basket_with_clothes(basket:item):
    body:
        observe(basket, "Check if this basket contains clothes")

behavior __goal__():
    body:
        foreach basket: item:
            if is_basket_for_clothes(basket) and not visited(basket):
                identify_basket_with_clothes(basket)

# Case 121:
When the sub-task is: 2. Add soap to the washing machine.
A successful representation:
 
behavior __goal__():
    body:
        bind washing_machine: item where:
            is_washing_machine(washing_machine) and id[washing_machine] == 2041
        # Select the washing machine with ID 2041

        bind soap: item where:
            is_soap(soap)
        # Select the soap item

        achieve inside(soap, washing_machine)
        # Add the soap inside the washing machine

# Case 122:
When the sub-task is: 3. Load the clothes into the washing machine and run it.
A successful representation:
 
behavior load_clothes_into_washing_machine(clothes:item, washing_machine:item):
    body:
        achieve inside(clothes, washing_machine)
        # Load each clothing item inside the washing machine

behavior __goal__():
    body:
        bind basket_for_clothes: item where:
            is_basket_for_clothes(basket_for_clothes) and id[basket_for_clothes] == 2040
        # Select the basket containing clothes with ID 2040

        bind washing_machine: item where:
            is_washing_machine(washing_machine) and id[washing_machine] == 2041
        # Select the washing machine with ID 2041

        foreach clothes: item:
            if is_clothes(clothes) and inside(clothes, basket_for_clothes):
                load_clothes_into_washing_machine(clothes, washing_machine)
        
        achieve closed(washing_machine)
        # Ensure the washing machine is closed

        achieve is_on(washing_machine)
        # Turn on the washing machine to run it

# Case 123:
When the sub-task is: Place the chicken and onion in the oven and turn it on.
A successful representation:
 
behavior place_items_in_oven(chicken:item, onion:item, oven:item):
    body:
        achieve inside(chicken, oven)
        achieve inside(onion, oven)

behavior start_oven(oven:item):
    body:
        achieve closed(oven)
        achieve is_on(oven)

behavior __goal__():
    body:
        bind chicken: item where:
            is_food_chicken(chicken)
        # Select the chicken

        bind onion: item where:
            is_food_onion(onion)
        # Select the onion

        bind oven: item where:
            is_oven(oven)
        # Select the oven

        place_items_in_oven(chicken, onion, oven)
        start_oven(oven)

# Case 124:
When the sub-task is: 1. Find the sink where you can wash the cat.
A successful representation:
 
behavior find_sink(sink:item):
    body:
        if visited(sink):
            # If the sink has already been visited, ensure the character is close to it
            achieve close_char(char, sink)
        else:
            # Observe all unvisited sinks to locate the sink for washing the cat
            foreach item: item:
                if is_sink(item) and not visited(item):
                    observe(item, "Locate the sink to wash the cat")

behavior __goal__():
    body:
        bind sink: item where:
            is_sink(sink)
        find_sink(sink)

# Case 125:
When the sub-task is: 2. Wash the cat in the sink.
A successful representation:
def is_cat_found(cat: item):
    # Check if the cat has already been visited
    symbol found = visited(cat)
    return found

behavior find_cat(cat:item):
    body:
        if is_cat_found(cat):
            # If the cat is already found, move close to it
            achieve close_char(char, cat)
        else:
            # Observe all unvisited potential cat locations to locate the cat
            foreach item: item:
                if is_cat(item) and not visited(item):
                    observe(item, "Locate the cat")

def has_faucet(sink:item):
    # Determine whether the sink has a faucet nearby
    symbol has_faucet=exists faucet:item: is_faucet(faucet) and close(faucet,sink)
    return has_faucet

behavior clean_cat(cat:item, sink:item):
    body:
        achieve_once inside(cat, sink)
        # Place the cat inside the sink for washing

        if has_faucet(sink):
            bind faucet: item where:
                is_faucet(faucet) and close(faucet, sink)
            achieve_once is_on(faucet)
            # If the sink has a faucet, turn it on to start washing

        wash(cat)
        # Wash the cat in the sink

        if has_faucet(sink):
            bind faucet: item where:
                is_faucet(faucet) and close(faucet, sink)
            achieve_once is_off(faucet)
            # Turn off the faucet after washing

behavior __goal__():
    body:
        bind sink: item where:
            is_sink(sink) and id[sink]==307
        # Select sink with ID 307

        bind cat: item where:
            is_cat(cat)
        find_cat(cat)
        # Ensure the cat is located

        clean_cat(cat, sink)
        # Clean the cat in the selected sink
# Case 126:
When the sub-task is: 2. Place the bowl on the table in the home office.
A successful representation:
behavior place_bowl_on_table(bowl:item, table:item):
    body:
        achieve on(bowl, table)
        # Place the bowl on the table

behavior __goal__():
    body:
        bind bowl: item where:
            is_bowl(bowl) and id[bowl] == 2095
        # Select the bowl with ID 2095

        bind home_office: item where:
            is_home_office(home_office)
        # Select the home office

        bind table: item where:
            is_table(table) and inside(table, home_office)
        # Select a table inside the home office

        place_bowl_on_table(bowl, table)
# Case 127:
When the sub-task is: 3. Find your cat and put it on the table in the home office.
A successful representation:
 
def is_cat_found(cat: item):
    # Determine if the cat has been observed or is known to be in a specific location
    symbol found = visited(cat)
    return found

behavior find_cat(cat:item):
    body:
        if is_cat_found(cat):
            # If the cat is already found, ensure the character is close to it
            achieve close_char(char, cat)
        else:
            # If the cat is not found, observe all unvisited items that could be the cat to locate it
            foreach item: item:
                if is_cat(item) and not visited(item):
                    observe(item, "Locate the cat")

behavior place_cat_on_table(cat:item, table:item):
    body:
        achieve on(cat, table)
        # Place the cat on the table

behavior __goal__():
    body:
        bind cat: item where:
            is_cat(cat)
        find_cat(cat)

        bind home_office: item where:
            is_home_office(home_office)
        # Select the home office

        bind table: item where:
            is_table(table) and inside(table, home_office)
        # Select a table inside the home office

        place_cat_on_table(cat, table)

# Case 128:
When the sub-task is: 1. Find the basket containing clothes.
A successful representation:
behavior identify_basket_with_clothes(basket:item):
    body:
        observe(basket, "Check if this basket contains clothes")

behavior __goal__():
    body:
        foreach basket: item:
            if is_basket_for_clothes(basket) and not visited(basket):
                identify_basket_with_clothes(basket)
# Case 129:
When the sub-task is: 2. Put the clothes from the basket into the washing machine and start the wash.
A successful representation:
 
behavior transfer_clothes_to_washing_machine(clothes:item, washing_machine:item):
    body:
        achieve inside(clothes, washing_machine)
        # Transfer each clothing item into the washing machine

behavior start_wash_cycle(washing_machine:item):
    body:
        achieve closed(washing_machine)
        # Ensure the washing machine is closed
        achieve is_on(washing_machine)
        # Start the washing cycle

behavior __goal__():
    body:
        bind basket_for_clothes: item where:
            is_basket_for_clothes(basket_for_clothes) and id[basket_for_clothes] == 2006
        # Select the basket containing clothes with ID 2006

        bind washing_machine: item where:
            is_washing_machine(washing_machine) and id[washing_machine] == 2007
        # Select the washing machine with ID 2007

        foreach clothes: item:
            if is_clothes(clothes) and inside(clothes, basket_for_clothes):
                transfer_clothes_to_washing_machine(clothes, washing_machine)

        start_wash_cycle(washing_machine)

# Case 130:
When the sub-task is: 1. Find the basket that contains clothes.
A successful representation:
behavior identify_basket_with_clothes(basket:item):
    body:
        observe(basket, "Check if this basket contains clothes")

behavior __goal__():
    body:
        foreach basket: item:
            if is_basket_for_clothes(basket) and not visited(basket):
                identify_basket_with_clothes(basket)
# Case 131:
When the sub-task is: 2. Load the clothes into the washing machine.
A successful representation:
behavior load_clothes_into_washing_machine(clothes:item, washing_machine:item):
    body:
        achieve inside(clothes, washing_machine)

behavior __goal__():
    body:
        bind basket_for_clothes: item where:
            is_basket_for_clothes(basket_for_clothes) and id[basket_for_clothes] == 2078
        # Select the basket containing clothes with ID 2078

        bind washing_machine: item where:
            is_washing_machine(washing_machine) and id[washing_machine] == 2079
        # Select the washing machine with ID 2079

        foreach clothes: item:
            if is_clothes(clothes) and inside(clothes, basket_for_clothes):
                load_clothes_into_washing_machine(clothes, washing_machine)
        # Transfer each clothing item from the basket to the washing machine
# Case 132:
When the sub-task is: 3. Wash the clothes using the washing machine.
A successful representation:
 
behavior run_washing_machine(washing_machine:item):
    body:
        achieve closed(washing_machine)
        # Ensure the washing machine is closed
        achieve is_on(washing_machine)
        # Turn on the washing machine to run it

behavior __goal__():
    body:
        bind washing_machine: item where:
            is_washing_machine(washing_machine)
        # Select the washing machine

        run_washing_machine(washing_machine)

# Case 133:
When the sub-task is: 1. Put cleaning solution in the dishwasher.
A successful representation:

behavior pour_cleaning_solution(dishwasher:item, cleaning_solution:item):
    body:
        achieve inside(cleaning_solution, dishwasher)
        # Pour the cleaning solution inside the dishwasher

behavior __goal__():
    body:
        bind dishwasher: item where:
            is_dishwasher(dishwasher)
        # Select the dishwasher

        bind cleaning_solution: item where:
            is_cleaning_solution(cleaning_solution)
        # Select the cleaning solution

        pour_cleaning_solution(dishwasher, cleaning_solution)
        # Pour the cleaning solution into the dishwasher

# Case 134:
When the sub-task is: 2. Wash the bowls and plates with the dishwasher.
A successful representation:
 
behavior load_dishwasher(item:item, dishwasher:item):
    body:
        achieve inside(item, dishwasher)
        # Place the item inside the dishwasher

behavior start_dishwasher(dishwasher:item):
    body:
        achieve closed(dishwasher)
        # Ensure the dishwasher door is closed
        achieve is_on(dishwasher)
        # Turn on the dishwasher to start washing

behavior __goal__():
    body:
        bind dishwasher: item where:
            is_dishwasher(dishwasher)
        # Select the dishwasher

        foreach item: item:
            if is_bowl(item) or is_plate(item):
                load_dishwasher(item, dishwasher)
        # Load all bowls and plates into the dishwasher

        start_dishwasher(dishwasher)
        # Start the dishwasher to wash the bowls and plates

# Case 135:
When the sub-task is: 1. Identify the location of milk, turkey, egg, fish, and chicken.
A successful representation:

def has_food_inside(room: item):
    # Function to check if the given room contains specific food items
    symbol has_milk = exists o: item : is_milk(o) and inside(o, room)
    symbol has_turkey = exists o: item : is_food_turkey(o) and inside(o, room)
    symbol has_egg = exists o: item : is_food_egg(o) and inside(o, room)
    symbol has_fish = exists o: item : is_food_fish(o) and inside(o, room)
    symbol has_chicken = exists o: item : is_food_chicken(o) and inside(o, room)
    return has_milk or has_turkey or has_egg or has_fish or has_chicken

behavior __goal__():
    body:
        if exists room: item : is_dining_room(room) and has_food_inside(room):
            # Using known information to approach the dining room containing the required food items
            bind room: item where:
                is_dining_room(room) and has_food_inside(room)
            achieve close_char(char, room)

        else:
            # If no food items found, inspect the dining room for unvisited items
            foreach room: item:
                if is_dining_room(room) and not visited(room):
                    observe(room, "Check for milk, turkey, egg, fish, and chicken")

# Case 136:
When the sub-task is: 2. Place milk, turkey, egg, fish, and chicken on the table in the dining room.
A successful representation:
behavior place_item_on_table(item:item, table:item):
    body:
        achieve on(item, table)

behavior __goal__():
    body:
        bind dining_room: item where:
            is_dining_room(dining_room)
        
        bind table: item where:
            is_table(table) and inside(table, dining_room)

        bind milk: item where:
            is_milk(milk)

        bind turkey: item where:
            is_food_turkey(turkey)
        
        bind egg: item where:
            is_food_egg(egg)

        bind fish: item where:
            is_food_fish(fish)

        bind chicken: item where:
            is_food_chicken(chicken)

        place_item_on_table(milk, table)
        place_item_on_table(turkey, table)
        place_item_on_table(egg, table)
        place_item_on_table(fish, table)
        place_item_on_table(chicken, table)
# Case 137:
When the sub-task is: 1. Put cleaning solution in the dishwasher.  
A successful representation:
 
behavior pour_cleaning_solution(dishwasher:item, cleaning_solution:item):
    body:
        achieve inside(cleaning_solution, dishwasher)
        # Pour the cleaning solution inside the dishwasher

behavior __goal__():
    body:
        bind dishwasher: item where:
            is_dishwasher(dishwasher)
        # Select the dishwasher

        bind cleaning_solution: item where:
            is_cleaning_solution(cleaning_solution)
        # Select the cleaning solution

        pour_cleaning_solution(dishwasher, cleaning_solution)
        # Pour the cleaning solution into the dishwasher

# Case 138:
When the sub-task is: 2. Wash the bowls and plates with the dishwasher.
A successful representation:
 
behavior load_dishwasher(item:item, dishwasher:item):
    body:
        achieve inside(item, dishwasher)
        # Place the item inside the dishwasher

behavior start_dishwasher(dishwasher:item):
    body:
        achieve closed(dishwasher)
        # Ensure the dishwasher door is closed
        achieve is_on(dishwasher)
        # Turn on the dishwasher to start washing

behavior __goal__():
    body:
        bind dishwasher: item where:
            is_dishwasher(dishwasher)
        # Select the dishwasher

        foreach item: item:
            if is_bowl(item) or is_plate(item):
                load_dishwasher(item, dishwasher)
        # Load all bowls and plates into the dishwasher

        start_dishwasher(dishwasher)
        # Start the dishwasher to wash the bowls and plates

# Case 139:
When the sub-task is: Make a cup of coffee using the coffee maker.
A successful representation:
behavior make_coffee_with_coffee_maker(coffee_maker:item, cup:item):
    body:
        achieve inside(cup, coffee_maker)
        # Place the cup inside the coffee maker

        achieve is_on(coffee_maker)
        # Turn on the coffee maker to make coffee

behavior __goal__():
    body:
        bind coffee_maker: item where:
            is_coffe_maker(coffee_maker)
        # Select the coffee maker

        bind cup: item where:
            is_cup(cup)
        # Select a cup

        make_coffee_with_coffee_maker(coffee_maker, cup)
# Case 140:
When the sub-task is: Put a cup of water on the nightstand.
A successful representation:
 
behavior find_cup(cup:item):
    body:
        if visited(cup):
            # If the cup has already been found, bring the character close to it
            achieve close_char(char, cup)
        else:
            # Observe all unvisited cups to locate one
            foreach item: item:
                if is_cup(item) and not visited(item):
                    observe(item, "Locate the cup")

behavior fill_cup_with_water(cup:item):
    body:
        achieve has_water(cup)
        # Fill the cup with water

behavior place_cup_on_nightstand(cup:item, nightstand:item):
    body:
        achieve on(cup, nightstand)
        # Place the cup on the nightstand

behavior __goal__():
    body:
        bind cup: item where:
            is_cup(cup)
        find_cup(cup)

        fill_cup_with_water(cup)

        bind nightstand: item where:
            is_nightstand(nightstand)
        # Select a nightstand

        place_cup_on_nightstand(cup, nightstand)

# Case 141:
When the sub-task is: Turn on the DVD player with the remote control.
A successful representation:
 
behavior __goal__():
    body:
        bind remote_control: item where:
            is_remote_control(remote_control)
        # Select the remote control

        bind dvd_player: item where:
            is_dvd_player(dvd_player)
        # Select the DVD player

        achieve_once inhand(remote_control)
        # Temporarily hold the remote control in hand

        achieve is_on(dvd_player)
        # Turn on the DVD player

# Case 142:
When the sub-task is: Turn on the computer in the home office.
A successful representation:

behavior __goal__():
    body:
        bind home_office: item where:
            is_home_office(home_office)
        # Select the home office

        bind computer: item where:
            is_computer(computer) and inside(computer, home_office)
        # Select the computer inside the home office

        achieve is_on(computer)
        # Turn on the computer in the home office

# Case 143:
When the sub-task is: Turn on the DVD player with the remote control.
A successful representation:
 
behavior __goal__():
    body:
        bind remote_control: item where:
            is_remote_control(remote_control)
        # Select the remote control

        bind dvd_player: item where:
            is_dvd_player(dvd_player)
        # Select the DVD player

        achieve_once inhand(remote_control)
        # Temporarily hold the remote control in hand

        achieve is_on(dvd_player)
        # Turn on the DVD player


## Output Requirements:
You need to think step by step to give resonable output. However, you can only output content similar to the 'Output' in the 'Example'. Do not include any explanation or any other symbols.
