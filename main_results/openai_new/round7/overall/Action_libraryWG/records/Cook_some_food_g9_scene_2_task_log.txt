From agent.py
Reset goals: The sub-goals are: 
['1. Find and wash potatoes.', '2. Cut the potatoes into fries and fry them until golden brown.', '3. Drain excess oil and serve the French fries.']
##############################
Goal representation from planning.py

#exp_behavior

behavior find_food_potato_2066_around_kitchen_counter_128(food_potato:item):
    goal: not unknown(food_potato)
    body:
        assert is_food_potato(food_potato)
        bind kitchen_counter_instance:item where:
            is_kitchen_counter(kitchen_counter_instance) and id[kitchen_counter_instance]==128
        achieve close_char(char,kitchen_counter_instance)
        if can_open(kitchen_counter_instance):
            achieve_once open(kitchen_counter_instance)
            exp(food_potato,kitchen_counter_instance)
        else:
            exp(food_potato,kitchen_counter_instance)
    eff:
        unknown[food_potato]=False
        close[food_potato,kitchen_counter_instance]=True
        close[kitchen_counter_instance,food_potato]=True
    

#exp_behavior_end

#goal_representation
 
def is_dirty_or_unwashed_potato(obj:item)  bool:
    # Function to check if the potato is either dirty or unwashed
    return is_food_potato(obj) and (dirty(obj) or not visited(obj))

behavior find_and_wash_potato(potato:item):
    body:
        # Ensure the potato is clean by washing it if necessary
        if dirty(potato):
            wash(potato)

behavior __goal__():
    body:
        # Check the existing knowledge for potatoes that need washing
        foreach o:item:
            if is_dirty_or_unwashed_potato(o):
                find_and_wash_potato(o)


#goal_representation_end

##############################
Inner TransformationError Debug
Unexpected token Token('BASIC_TYPENAME', 'bool') at line 5734, column 44.
Expected one of: 
	* FEATURE
	* TYPEDEF
	* _PRAGMA_KEYWORD
	* UNDIRECTED_GENERATOR
	* INIT
	* BEHAVIOR
	* $END
	* IMPORT
	* _RIGHT_ARROW
	* CONTROLLER
	* _NEWLINE
	* OBJECTS
	* GOAL
	* COLON
	* INCLUDE
	* DEF
	* DOMAIN
	* GENERATOR
Previous tokens: [Token('RPAR', ')')]

##############################
Goal representation after debugging in planning.py
#exp_behavior

behavior find_cleaning_solution_2098_around_bathroom_cabinet_305(cleaning_solution:item):
    goal: not unknown(cleaning_solution)
    body:
        assert is_cleaning_solution(cleaning_solution)
        bind bathroom_cabinet_instance:item where:
            is_bathroom_cabinet(bathroom_cabinet_instance) and id[bathroom_cabinet_instance]==305
        achieve close_char(char,bathroom_cabinet_instance)
        if can_open(bathroom_cabinet_instance):
            achieve_once open(bathroom_cabinet_instance)
            exp(cleaning_solution,bathroom_cabinet_instance)
        else:
            exp(cleaning_solution,bathroom_cabinet_instance)
    eff:
        unknown[cleaning_solution]=False
        close[cleaning_solution,bathroom_cabinet_instance]=True
        close[bathroom_cabinet_instance,cleaning_solution]=True
    

behavior find_food_potato_2066_around_kitchen_counter_132(food_potato:item):
    goal: not unknown(food_potato)
    body:
        assert is_food_potato(food_potato)
        bind kitchen_counter_instance:item where:
            is_kitchen_counter(kitchen_counter_instance) and id[kitchen_counter_instance]==132
        achieve close_char(char,kitchen_counter_instance)
        if can_open(kitchen_counter_instance):
            achieve_once open(kitchen_counter_instance)
            exp(food_potato,kitchen_counter_instance)
        else:
            exp(food_potato,kitchen_counter_instance)
    eff:
        unknown[food_potato]=False
        close[food_potato,kitchen_counter_instance]=True
        close[kitchen_counter_instance,food_potato]=True
    

#goal_representation
 
def is_dirty_or_unwashed_potato(obj: item)  bool:
    # Function to check if the potato is either dirty or unwashed
    return is_food_potato(obj) and (dirty(obj) or not visited(obj))

behavior find_and_wash_potato(potato: item):
    body:
        # Ensure the potato is clean by washing it if necessary
        if dirty(potato):
            wash(potato)

behavior __goal__():
    body:
        # Check the existing knowledge for potatoes that need washing
        foreach o: item:
            if is_dirty_or_unwashed_potato(o):
                find_and_wash_potato(o)

#goal_representation_end

##############################
Inner TransformationError Debug
Unexpected token Token('BASIC_TYPENAME', 'bool') at line 5752, column 45.
Expected one of: 
	* FEATURE
	* TYPEDEF
	* _PRAGMA_KEYWORD
	* UNDIRECTED_GENERATOR
	* INIT
	* BEHAVIOR
	* $END
	* IMPORT
	* _RIGHT_ARROW
	* CONTROLLER
	* _NEWLINE
	* OBJECTS
	* GOAL
	* COLON
	* INCLUDE
	* DEF
	* DOMAIN
	* GENERATOR
Previous tokens: [Token('RPAR', ')')]

##############################
Goal representation after debugging in planning.py
#exp_behavior

behavior find_food_potato_2066_around_kitchen_counter_132(food_potato:item):
    goal: not unknown(food_potato)
    body:
        assert is_food_potato(food_potato)
        bind kitchen_counter_instance:item where:
            is_kitchen_counter(kitchen_counter_instance) and id[kitchen_counter_instance]==132
        achieve close_char(char,kitchen_counter_instance)
        if can_open(kitchen_counter_instance):
            achieve_once open(kitchen_counter_instance)
            exp(food_potato,kitchen_counter_instance)
        else:
            exp(food_potato,kitchen_counter_instance)
    eff:
        unknown[food_potato]=False
        close[food_potato,kitchen_counter_instance]=True
        close[kitchen_counter_instance,food_potato]=True
    

behavior find_cleaning_solution_2098_around_bathroom_cabinet_305(cleaning_solution:item):
    goal: not unknown(cleaning_solution)
    body:
        assert is_cleaning_solution(cleaning_solution)
        bind bathroom_cabinet_instance:item where:
            is_bathroom_cabinet(bathroom_cabinet_instance) and id[bathroom_cabinet_instance]==305
        achieve close_char(char,bathroom_cabinet_instance)
        if can_open(bathroom_cabinet_instance):
            achieve_once open(bathroom_cabinet_instance)
            exp(cleaning_solution,bathroom_cabinet_instance)
        else:
            exp(cleaning_solution,bathroom_cabinet_instance)
    eff:
        unknown[cleaning_solution]=False
        close[cleaning_solution,bathroom_cabinet_instance]=True
        close[bathroom_cabinet_instance,cleaning_solution]=True
    

#goal_representation
 
def is_dirty_or_unwashed_potato(obj: item)  bool:
    # Function to check if the potato is either dirty or unwashed
    return is_food_potato(obj) and (dirty(obj) or not visited(obj))

behavior find_and_wash_potato(potato: item):
    body:
        # Ensure the potato is clean by washing it if necessary
        if dirty(potato):
            wash(potato)

behavior __goal__():
    body:
        # Check the existing knowledge for potatoes that need washing
        foreach o: item:
            if is_dirty_or_unwashed_potato(o):
                find_and_wash_potato(o)

#goal_representation_end

##############################
Goal representation from planning.py

#exp_behavior

behavior find_food_potato_2066_around_kitchen_counter_128(food_potato:item):
    goal: not unknown(food_potato)
    body:
        assert is_food_potato(food_potato)
        bind kitchen_counter_instance:item where:
            is_kitchen_counter(kitchen_counter_instance) and id[kitchen_counter_instance]==128
        achieve close_char(char,kitchen_counter_instance)
        if can_open(kitchen_counter_instance):
            achieve_once open(kitchen_counter_instance)
            exp(food_potato,kitchen_counter_instance)
        else:
            exp(food_potato,kitchen_counter_instance)
    eff:
        unknown[food_potato]=False
        close[food_potato,kitchen_counter_instance]=True
        close[kitchen_counter_instance,food_potato]=True
    

#exp_behavior_end

#goal_representation
 
def is_potato(x: item):
    # Determines if an item is a potato
    return is_food_potato(x)

behavior observe_and_wash_potato(potato: item):
    body:
        observe(potato, "Check if the potato is clean or dirty")
        # Observe the potato to determine if it needs washing
        if dirty(potato):
            # If the potato is dirty, wash it
            achieve_once clean(potato)

behavior __goal__():
    body:
        # Attempt to find a potato and ensure its washed
        foreach potato: item:
            if is_potato(potato):
                observe_and_wash_potato(potato)
                # Observe and wash each potato found

#goal_representation_end

##############################
Goal representation from planning.py

#exp_behavior

behavior find_food_potato_2066_around_kitchen_counter_132(food_potato:item):
    goal: not unknown(food_potato)
    body:
        assert is_food_potato(food_potato)
        bind kitchen_counter_instance:item where:
            is_kitchen_counter(kitchen_counter_instance) and id[kitchen_counter_instance]==132
        achieve close_char(char,kitchen_counter_instance)
        if can_open(kitchen_counter_instance):
            achieve_once open(kitchen_counter_instance)
            exp(food_potato,kitchen_counter_instance)
        else:
            exp(food_potato,kitchen_counter_instance)
    eff:
        unknown[food_potato]=False
        close[food_potato,kitchen_counter_instance]=True
        close[kitchen_counter_instance,food_potato]=True
    

behavior find_bowl_2097_around_kitchen_counter_132(bowl:item):
    goal: not unknown(bowl)
    body:
        assert is_bowl(bowl)
        bind kitchen_counter_instance:item where:
            is_kitchen_counter(kitchen_counter_instance) and id[kitchen_counter_instance]==132
        achieve close_char(char,kitchen_counter_instance)
        if can_open(kitchen_counter_instance):
            achieve_once open(kitchen_counter_instance)
            exp(bowl,kitchen_counter_instance)
        else:
            exp(bowl,kitchen_counter_instance)
    eff:
        unknown[bowl]=False
        close[bowl,kitchen_counter_instance]=True
        close[kitchen_counter_instance,bowl]=True
    

#exp_behavior_end

#goal_representation
 
def has_potatoes(kitchen_counter: item):
    # Function to check if there are potatoes on a specified kitchen counter
    symbol has_potatoes= exists o: item : (is_food_potato(o) and on(o, kitchen_counter))
    return has_potatoes

behavior __goal__():
    body:
        if exists kitchen_counter: item : (is_kitchen_counter(kitchen_counter) and has_potatoes(kitchen_counter)):
            # If we have already found the kitchen counter with potatoes, we can directly approach it
            bind kitchen_counter: item where:
                is_kitchen_counter(kitchen_counter) and has_potatoes(kitchen_counter)
            achieve close_char(char, kitchen_counter)

        else:
            # Check all kitchen counters in the scene that have not been visited
            foreach kitchen_counter: item:
                if is_kitchen_counter(kitchen_counter) and not visited(kitchen_counter):
                    observe(kitchen_counter,"Check is there any potatoes on the kitchen counter")

#goal_representation_end

##############################
From agent.py->reset_goal
 
def has_potatoes(kitchen_counter: item):
    # Function to check if there are potatoes on a specified kitchen counter
    symbol has_potatoes= exists o: item : (is_food_potato(o) and on(o, kitchen_counter))
    return has_potatoes

behavior __goal__():
    body:
        if exists kitchen_counter: item : (is_kitchen_counter(kitchen_counter) and has_potatoes(kitchen_counter)):
            # If we have already found the kitchen counter with potatoes, we can directly approach it
            bind kitchen_counter: item where:
                is_kitchen_counter(kitchen_counter) and has_potatoes(kitchen_counter)
            achieve close_char(char, kitchen_counter)

        else:
            # Check all kitchen counters in the scene that have not been visited
            foreach kitchen_counter: item:
                if is_kitchen_counter(kitchen_counter) and not visited(kitchen_counter):
                    observe(kitchen_counter,"Check is there any potatoes on the kitchen counter")

##############################
From agent.py-> find a plan in act()
walk_executor(kitchen_counter_128)obs(kitchen_counter_128, Check is there any potatoes on the kitchen counter)walk_executor(kitchen_counter_129)obs(kitchen_counter_129, Check is there any potatoes on the kitchen counter)walk_executor(kitchen_counter_132)obs(kitchen_counter_132, Check is there any potatoes on the kitchen counter)
##############################
From agent.py
walk_executor(kitchen_counter_128)
Robot find: food_orange_2008, spectacles_2106, Robot is close to the kitchen_counter_128. 
##############################
From agent.py
obs(kitchen_counter_128, Check is there any potatoes on the kitchen counter)
Get this information:  kitchen_counter_128 is inside dining_room_1. cutting_board_2080 is on kitchen_counter_128. kitchen_counter_128 is close to cutting_board_2080. kitchen_counter_128 is close to cupboard_130. kitchen_counter_128 is close to kitchen_counter_132. kitchen_counter_128 is close to sink_133. kitchen_counter_128 is close to wall_6. kitchen_counter_128 is close to floor_167. kitchen_counter_128 is close to floor_165. kitchen_counter_128 is close to wall_172. kitchen_counter_128 is close to wall_174. kitchen_counter_128 is close to floor_15. kitchen_counter_128 is close to microwave_149. kitchen_counter_128 is close to food_orange_2008. kitchen_counter_128 is close to spectacles_2106. kitchen_counter_128 is close to ceiling_27. kitchen_counter_128 is close to bookshelf_188. kitchen_counter_128 is close to bookshelf_189. kitchen_counter_128 is close to character_219. kitchen_counter_128 is on floor_15. food_orange_2008 is on kitchen_counter_128. spectacles_2106 is on kitchen_counter_128. kitchen_counter_128 is CLOSED. kitchen_counter_128 is CLEAN.
##############################
From agent.py
walk_executor(kitchen_counter_129)
Robot find: fryingpan_2107, oil_2102, pot_54, pot_2093, Robot is close to the kitchen_counter_129. 
##############################
From agent.py
obs(kitchen_counter_129, Check is there any potatoes on the kitchen counter)
Get this information:  fryingpan_2107 is on kitchen_counter_129. coffe_maker_147 is on kitchen_counter_129. toaster_144 is on kitchen_counter_129. kitchen_counter_129 is inside dining_room_1. stove_2090 is on kitchen_counter_129. kitchen_counter_129 is close to wall_2. kitchen_counter_129 is close to cupboard_131. kitchen_counter_129 is close to wall_7. kitchen_counter_129 is close to wall_8. kitchen_counter_129 is close to stovefan_139. kitchen_counter_129 is close to fridge_140. kitchen_counter_129 is close to oven_141. kitchen_counter_129 is close to tray_142. kitchen_counter_129 is close to dishwasher_143. kitchen_counter_129 is close to toaster_144. kitchen_counter_129 is close to floor_16. kitchen_counter_129 is close to coffe_maker_147. kitchen_counter_129 is close to floor_21. kitchen_counter_129 is close to floor_22. kitchen_counter_129 is close to stove_2090. kitchen_counter_129 is close to walllamp_44. kitchen_counter_129 is close to pot_2093. kitchen_counter_129 is close to walllamp_46. kitchen_counter_129 is close to oil_2102. kitchen_counter_129 is close to pot_54. kitchen_counter_129 is close to fryingpan_2107. kitchen_counter_129 is close to character_219. pot_2093 is on kitchen_counter_129. oil_2102 is on kitchen_counter_129. kitchen_counter_129 is CLOSED. kitchen_counter_129 is CLEAN.
##############################
From agent.py
walk_executor(kitchen_counter_132)
Robot find: Robot is close to the kitchen_counter_132. 
##############################
From agent.py
obs(kitchen_counter_132, Check is there any potatoes on the kitchen counter)
Get this information:  microwave_149 is on kitchen_counter_132. kitchen_counter_132 is inside dining_room_1. faucet_134 is on kitchen_counter_132. kitchen_counter_132 is close to kitchen_counter_128. kitchen_counter_132 is close to wall_2. kitchen_counter_132 is close to cupboard_130. kitchen_counter_132 is close to sink_133. kitchen_counter_132 is close to faucet_134. kitchen_counter_132 is close to wall_6. kitchen_counter_132 is close to stovefan_139. kitchen_counter_132 is close to wall_172. kitchen_counter_132 is close to walllamp_45. kitchen_counter_132 is close to oven_141. kitchen_counter_132 is close to floor_15. kitchen_counter_132 is close to floor_16. kitchen_counter_132 is close to tray_142. kitchen_counter_132 is close to walllamp_46. kitchen_counter_132 is close to knifeblock_52. kitchen_counter_132 is close to microwave_149. kitchen_counter_132 is close to pot_54. kitchen_counter_132 is close to character_219. sink_133 is inside kitchen_counter_132. kitchen_counter_132 is OPEN. kitchen_counter_132 is CLEAN.
##############################
From agent.py -> evaluate_current_subgoal()
The evaluation result for current subgoal: No
The feedback instruction: You need to locate the potatoes, as they have not yet been found on any of the inspected kitchen counters. Continue searching other areas or counters for potatoes.
##############################
From agent.py
Human Instruction: You need to locate the potatoes, as they have not yet been found on any of the inspected kitchen counters. Continue searching other areas or counters for potatoes.

The actions you have taken:
Action 1: Walk to kitchen_counter_128.
Action 2: Observe around kitchen_counter_128 with the question of Check is there any potatoes on the kitchen counter.
Action 3: Walk to kitchen_counter_129.
Action 4: Observe around kitchen_counter_129 with the question of Check is there any potatoes on the kitchen counter.
Action 5: Walk to kitchen_counter_132.
Action 6: Observe around kitchen_counter_132 with the question of Check is there any potatoes on the kitchen counter.

##############################
Goal representation from planning.py

#exp_behavior

behavior find_food_potato_2066_around_cupboard_131(food_potato:item):
    goal: not unknown(food_potato)
    body:
        assert is_food_potato(food_potato)
        bind cupboard_instance:item where:
            is_cupboard(cupboard_instance) and id[cupboard_instance]==131
        achieve close_char(char,cupboard_instance)
        if can_open(cupboard_instance):
            achieve_once open(cupboard_instance)
            exp(food_potato,cupboard_instance)
        else:
            exp(food_potato,cupboard_instance)
    eff:
        unknown[food_potato]=False
        close[food_potato,cupboard_instance]=True
        close[cupboard_instance,food_potato]=True
    

#exp_behavior_end

#goal_representation
  
def has_potatoes_on_counter(counter:item):
    # Function to check if there are potatoes on a specified kitchen counter
    symbol has_potatoes=exists o: item : (is_food_potato(o) and on(o, counter))
    return has_potatoes

behavior __goal__():
    body:
        if exists counter: item : (is_kitchen_counter(counter) and has_potatoes_on_counter(counter)):
            # If we have already found the counter with potatoes, we can directly approach it
            bind counter: item where:
                is_kitchen_counter(counter) and has_potatoes_on_counter(counter)
            achieve close_char(char, counter)

        else:
            # Check all kitchen counters in the scene that have not been visited
            foreach counter: item:
                if is_kitchen_counter(counter) and not visited(counter):
                    observe(counter,"Check is there any potatoes on the kitchen counter")
  
#goal_representation_end

##############################
Goal representation from planning.py

#exp_behavior

behavior find_cleaning_solution_2098_around_bathroom_cabinet_305(cleaning_solution:item):
    goal: not unknown(cleaning_solution)
    body:
        assert is_cleaning_solution(cleaning_solution)
        bind bathroom_cabinet_instance:item where:
            is_bathroom_cabinet(bathroom_cabinet_instance) and id[bathroom_cabinet_instance]==305
        achieve close_char(char,bathroom_cabinet_instance)
        if can_open(bathroom_cabinet_instance):
            achieve_once open(bathroom_cabinet_instance)
            exp(cleaning_solution,bathroom_cabinet_instance)
        else:
            exp(cleaning_solution,bathroom_cabinet_instance)
    eff:
        unknown[cleaning_solution]=False
        close[cleaning_solution,bathroom_cabinet_instance]=True
        close[bathroom_cabinet_instance,cleaning_solution]=True
    

behavior find_blender_2032_around_cupboard_131(blender:item):
    goal: not unknown(blender)
    body:
        assert is_blender(blender)
        bind cupboard_instance:item where:
            is_cupboard(cupboard_instance) and id[cupboard_instance]==131
        achieve close_char(char,cupboard_instance)
        if can_open(cupboard_instance):
            achieve_once open(cupboard_instance)
            exp(blender,cupboard_instance)
        else:
            exp(blender,cupboard_instance)
    eff:
        unknown[blender]=False
        close[blender,cupboard_instance]=True
        close[cupboard_instance,blender]=True
    

behavior find_food_potato_2066_around_fridge_140(food_potato:item):
    goal: not unknown(food_potato)
    body:
        assert is_food_potato(food_potato)
        bind fridge_instance:item where:
            is_fridge(fridge_instance) and id[fridge_instance]==140
        achieve close_char(char,fridge_instance)
        if can_open(fridge_instance):
            achieve_once open(fridge_instance)
            exp(food_potato,fridge_instance)
        else:
            exp(food_potato,fridge_instance)
    eff:
        unknown[food_potato]=False
        close[food_potato,fridge_instance]=True
        close[fridge_instance,food_potato]=True
    

#exp_behavior_end

#goal_representation
 
def has_potatoes_on_counter(counter: item):
    # Function to check if there are potatoes on a specified counter
    symbol has_potatoes = exists o: item : (is_food_potato(o) and on(o, counter))
    return has_potatoes

behavior __goal__():
    body:
        if exists kitchen_counter: item : (is_kitchen_counter(kitchen_counter) and has_potatoes_on_counter(kitchen_counter)):
            # Check if there is a kitchen counter with potatoes based on the available information
            bind kitchen_counter: item where:
                is_kitchen_counter(kitchen_counter) and has_potatoes_on_counter(kitchen_counter)
            # Select a kitchen counter that has potatoes on it
            achieve close_char(char, kitchen_counter)
            # Move the character closer to the kitchen counter with potatoes

        else: 
            # If no kitchen counter with potatoes is found, initiate exploration to locate one
            foreach kitchen_counter: item:
                if is_kitchen_counter(kitchen_counter) and not visited(kitchen_counter):
                    # Check all unvisited kitchen counters
                    observe(kitchen_counter, "Check is there any potatoes on the kitchen counter")
                    # Observe whether each kitchen counter has any potatoes
            

#goal_representation_end

##############################
Goal representation from planning.py

#exp_behavior

behavior find_towel_rack_299_around_bathroom_cabinet_305(towel_rack:item):
    goal: not unknown(towel_rack)
    body:
        assert is_towel_rack(towel_rack)
        bind bathroom_cabinet_instance:item where:
            is_bathroom_cabinet(bathroom_cabinet_instance) and id[bathroom_cabinet_instance]==305
        achieve close_char(char,bathroom_cabinet_instance)
        if can_open(bathroom_cabinet_instance):
            achieve_once open(bathroom_cabinet_instance)
            exp(towel_rack,bathroom_cabinet_instance)
        else:
            exp(towel_rack,bathroom_cabinet_instance)
    eff:
        unknown[towel_rack]=False
        close[towel_rack,bathroom_cabinet_instance]=True
        close[bathroom_cabinet_instance,towel_rack]=True
    

behavior find_bowl_2097_around_cupboard_131(bowl:item):
    goal: not unknown(bowl)
    body:
        assert is_bowl(bowl)
        bind cupboard_instance:item where:
            is_cupboard(cupboard_instance) and id[cupboard_instance]==131
        achieve close_char(char,cupboard_instance)
        if can_open(cupboard_instance):
            achieve_once open(cupboard_instance)
            exp(bowl,cupboard_instance)
        else:
            exp(bowl,cupboard_instance)
    eff:
        unknown[bowl]=False
        close[bowl,cupboard_instance]=True
        close[cupboard_instance,bowl]=True
    

behavior find_food_potato_2066_around_cupboard_131(food_potato:item):
    goal: not unknown(food_potato)
    body:
        assert is_food_potato(food_potato)
        bind cupboard_instance:item where:
            is_cupboard(cupboard_instance) and id[cupboard_instance]==131
        achieve close_char(char,cupboard_instance)
        if can_open(cupboard_instance):
            achieve_once open(cupboard_instance)
            exp(food_potato,cupboard_instance)
        else:
            exp(food_potato,cupboard_instance)
    eff:
        unknown[food_potato]=False
        close[food_potato,cupboard_instance]=True
        close[cupboard_instance,food_potato]=True
    

behavior find_towel_2083_around_bathroom_cabinet_305(towel:item):
    goal: not unknown(towel)
    body:
        assert is_towel(towel)
        bind bathroom_cabinet_instance:item where:
            is_bathroom_cabinet(bathroom_cabinet_instance) and id[bathroom_cabinet_instance]==305
        achieve close_char(char,bathroom_cabinet_instance)
        if can_open(bathroom_cabinet_instance):
            achieve_once open(bathroom_cabinet_instance)
            exp(towel,bathroom_cabinet_instance)
        else:
            exp(towel,bathroom_cabinet_instance)
    eff:
        unknown[towel]=False
        close[towel,bathroom_cabinet_instance]=True
        close[bathroom_cabinet_instance,towel]=True
    

#exp_behavior_end

#goal_representation

def has_potatoes_on_kitchen_counter(counter:item):
    # Function to check if there are potatoes on a specified kitchen counter
    symbol has_potatoes= exists o: item : (is_food_potato(o) and on(o, counter))
    return has_potatoes

behavior __goal__():
    body:
        if exists counter: item : (is_kitchen_counter(counter) and has_potatoes_on_kitchen_counter(counter)):
            # Check if there is a kitchen counter with potatoes based on the available information
            bind counter: item where:
                is_kitchen_counter(counter) and has_potatoes_on_kitchen_counter(counter)
            # Select a kitchen counter that has potatoes on it
            achieve close_char(char, counter)
            # Move the character closer to the kitchen counter with potatoes

        else:
            # If no kitchen counter with potatoes is found, initiate exploration to locate one
            foreach counter: item:
                if is_kitchen_counter(counter) and not visited(counter):
                    observe(counter,"Check is there any potatoes on the kitchen counter")
                    # Observe whether each counter has any potatoes

#goal_representation_end

##############################
VH_pipeline: Fail to generate a valid plan
##############################
From agent.py -> query_LLM_human
Record from func query_LLM_human in agent.py
Question: Can you teach me how to "1. find and wash potatoes." ?
Answer: Your plan to "find and wash potatoes" deviates from the required steps. Instead, focus on locating the potatoes first.
Re-decompose: True

##############################
From agent.py
Reset goals: The sub-goals are: 
['1. Locate the potatoes.', '2. Wash, peel, and slice the potatoes.', '3. Fry the potatoes until they are golden and crispy.']
##############################
Goal representation from planning.py

#exp_behavior

behavior find_food_potato_2066_around_cupboard_131(food_potato:item):
    goal: not unknown(food_potato)
    body:
        assert is_food_potato(food_potato)
        bind cupboard_instance:item where:
            is_cupboard(cupboard_instance) and id[cupboard_instance]==131
        achieve close_char(char,cupboard_instance)
        if can_open(cupboard_instance):
            achieve_once open(cupboard_instance)
            exp(food_potato,cupboard_instance)
        else:
            exp(food_potato,cupboard_instance)
    eff:
        unknown[food_potato]=False
        close[food_potato,cupboard_instance]=True
        close[cupboard_instance,food_potato]=True
    

behavior find_food_carrot_2047_around_fridge_140(food_carrot:item):
    goal: not unknown(food_carrot)
    body:
        assert is_food_carrot(food_carrot)
        bind fridge_instance:item where:
            is_fridge(fridge_instance) and id[fridge_instance]==140
        achieve close_char(char,fridge_instance)
        if can_open(fridge_instance):
            achieve_once open(fridge_instance)
            exp(food_carrot,fridge_instance)
        else:
            exp(food_carrot,fridge_instance)
    eff:
        unknown[food_carrot]=False
        close[food_carrot,fridge_instance]=True
        close[fridge_instance,food_carrot]=True
    

behavior find_food_vegetable_2072_around_cupboard_131(food_vegetable:item):
    goal: not unknown(food_vegetable)
    body:
        assert is_food_vegetable(food_vegetable)
        bind cupboard_instance:item where:
            is_cupboard(cupboard_instance) and id[cupboard_instance]==131
        achieve close_char(char,cupboard_instance)
        if can_open(cupboard_instance):
            achieve_once open(cupboard_instance)
            exp(food_vegetable,cupboard_instance)
        else:
            exp(food_vegetable,cupboard_instance)
    eff:
        unknown[food_vegetable]=False
        close[food_vegetable,cupboard_instance]=True
        close[cupboard_instance,food_vegetable]=True
    

#exp_behavior_end

#goal_representation
 
def has_potatoes_on_counter(counter:item):
    # Function to check if there are potatoes on a specified kitchen counter
    symbol has_potato=exists o: item : (is_food_potato(o) and on(o, counter))
    return has_potato

behavior __goal__():
    body:
        if exists counter: item : (is_kitchen_counter(counter) and has_potatoes_on_counter(counter)):
            # If any kitchen counter already has potatoes, we can directly approach it
            bind counter: item where:
                is_kitchen_counter(counter) and has_potatoes_on_counter(counter)
            achieve close_char(char, counter)

        else:
            # Check all kitchen counters in the scene that have not been visited
            foreach counter: item:
                if is_kitchen_counter(counter) and not visited(counter):
                    observe(counter,"Check is there any potatoes on the kitchen counter")

#goal_representation_end

##############################
Goal representation from planning.py

#exp_behavior

behavior find_food_potato_2066_around_cupboard_131(food_potato:item):
    goal: not unknown(food_potato)
    body:
        assert is_food_potato(food_potato)
        bind cupboard_instance:item where:
            is_cupboard(cupboard_instance) and id[cupboard_instance]==131
        achieve close_char(char,cupboard_instance)
        if can_open(cupboard_instance):
            achieve_once open(cupboard_instance)
            exp(food_potato,cupboard_instance)
        else:
            exp(food_potato,cupboard_instance)
    eff:
        unknown[food_potato]=False
        close[food_potato,cupboard_instance]=True
        close[cupboard_instance,food_potato]=True
    

behavior find_food_carrot_2047_around_cupboard_131(food_carrot:item):
    goal: not unknown(food_carrot)
    body:
        assert is_food_carrot(food_carrot)
        bind cupboard_instance:item where:
            is_cupboard(cupboard_instance) and id[cupboard_instance]==131
        achieve close_char(char,cupboard_instance)
        if can_open(cupboard_instance):
            achieve_once open(cupboard_instance)
            exp(food_carrot,cupboard_instance)
        else:
            exp(food_carrot,cupboard_instance)
    eff:
        unknown[food_carrot]=False
        close[food_carrot,cupboard_instance]=True
        close[cupboard_instance,food_carrot]=True
    

#exp_behavior_end

#goal_representation
 
def has_potatoes_on_counter(counter:item):
    # Function to check if there are potatoes on a specified kitchen counter
    symbol has_potatoes = exists o: item : (is_food_potato(o) and on(o, counter))
    return has_potatoes

behavior __goal__():
    body:
        if exists counter: item : (is_kitchen_counter(counter) and has_potatoes_on_counter(counter)):
            # If we know there is a counter with potatoes, approach it
            bind counter: item where:
                is_kitchen_counter(counter) and has_potatoes_on_counter(counter)
            achieve close_char(char, counter)

        else:
            # Check all kitchen counters in the scene that have not been visited
            foreach counter: item:
                if is_kitchen_counter(counter) and not visited(counter):
                    observe(counter, "Check is there any potatoes on the kitchen counter")

#goal_representation_end

##############################
Goal representation from planning.py

#exp_behavior

behavior find_food_potato_2066_around_fridge_140(food_potato:item):
    goal: not unknown(food_potato)
    body:
        assert is_food_potato(food_potato)
        bind fridge_instance:item where:
            is_fridge(fridge_instance) and id[fridge_instance]==140
        achieve close_char(char,fridge_instance)
        if can_open(fridge_instance):
            achieve_once open(fridge_instance)
            exp(food_potato,fridge_instance)
        else:
            exp(food_potato,fridge_instance)
    eff:
        unknown[food_potato]=False
        close[food_potato,fridge_instance]=True
        close[fridge_instance,food_potato]=True
    

#exp_behavior_end

#goal_representation

behavior __goal__():
    body:
        if exists kitchen_counter: item : (is_kitchen_counter(kitchen_counter) and not exists potato: item: (is_food_potato(potato) and on(potato,kitchen_counter)) and not visited(kitchen_counter)):
            # If we have already confirmed that the potatoes are not on any kitchen counters
            foreach counter: item:
                if is_kitchen_counter(counter) and not visited(counter):
                    # Check unvisited kitchen counters in the scene
                    observe(counter, "Check is there any potatoes on the kitchen counter")
        else:
            foreach counter: item:
                if is_kitchen_counter(counter) and not visited(counter):
                    # Check all unvisited kitchen counters
                    observe(counter, "Check is there any potatoes on the kitchen counter")

#goal_representation_end

##############################
Inner TransformationError Debug
Unexpected token Token('VARNAME', 'potato') at line 5757, column 95.
Expected one of: 
	* COMMA
	* RPAR

##############################
Goal representation after debugging in planning.py
#exp_behavior

behavior find_food_potato_2066_around_cupboard_131(food_potato:item):
    goal: not unknown(food_potato)
    body:
        assert is_food_potato(food_potato)
        bind cupboard_instance:item where:
            is_cupboard(cupboard_instance) and id[cupboard_instance]==131
        achieve close_char(char,cupboard_instance)
        if can_open(cupboard_instance):
            achieve_once open(cupboard_instance)
            exp(food_potato,cupboard_instance)
        else:
            exp(food_potato,cupboard_instance)
    eff:
        unknown[food_potato]=False
        close[food_potato,cupboard_instance]=True
        close[cupboard_instance,food_potato]=True
    

#goal_representation

behavior __goal__():
    body:
        if exists kitchen_counter: item : (is_kitchen_counter(kitchen_counter) and not exists potato: item: (is_food_potato(potato) and on(potato,kitchen_counter)) and not visited(kitchen_counter)):
            # If we have already confirmed that the potatoes are not on any kitchen counters
            foreach counter: item:
                if is_kitchen_counter(counter) and not visited(counter):
                    # Check unvisited kitchen counters in the scene
                    observe(counter, "Check is there any potatoes on the kitchen counter")
        else:
            foreach counter: item:
                if is_kitchen_counter(counter) and not visited(counter):
                    # Check all unvisited kitchen counters
                    observe(counter, "Check is there any potatoes on the kitchen counter")

#goal_representation_end

##############################
Inner TransformationError Debug
Unexpected token Token('VARNAME', 'potato') at line 5757, column 95.
Expected one of: 
	* COMMA
	* RPAR

##############################
Goal representation after debugging in planning.py
#exp_behavior

behavior find_food_potato_2066_around_cupboard_130(food_potato:item):
    goal: not unknown(food_potato)
    body:
        assert is_food_potato(food_potato)
        bind cupboard_instance:item where:
            is_cupboard(cupboard_instance) and id[cupboard_instance]==130
        achieve close_char(char,cupboard_instance)
        if can_open(cupboard_instance):
            achieve_once open(cupboard_instance)
            exp(food_potato,cupboard_instance)
        else:
            exp(food_potato,cupboard_instance)
    eff:
        unknown[food_potato]=False
        close[food_potato,cupboard_instance]=True
        close[cupboard_instance,food_potato]=True
    

#goal_representation

behavior __goal__():
    body:
        if exists kitchen_counter: item : (is_kitchen_counter(kitchen_counter) and not exists potato: item: (is_food_potato(potato) and on(potato,kitchen_counter))):
            # If we have already confirmed that the potatoes are not on any kitchen counters
            foreach counter: item:
                if is_kitchen_counter(counter) and not visited(counter):
                    # Check unvisited kitchen counters in the scene
                    observe(counter, "Check is there any potatoes on the kitchen counter")
        else:
            foreach counter: item:
                if is_kitchen_counter(counter) and not visited(counter):
                    # Check all unvisited kitchen counters
                    observe(counter, "Check is there any potatoes on the kitchen counter")

#goal_representation_end

##############################
VH_pipeline: Fail to generate a valid plan
##############################
Error record: Error during problem transformation
##############################
Task Summary:
Task Goal:
Syntax Error
Action History:
['walk_executor(kitchen_counter_128)', 'walk_executor(kitchen_counter_129)', 'walk_executor(kitchen_counter_132)']
Time info:
Time consume: 263 seconds
Exp_helper query times: 0
Guidance query times: 1
library scale: 66
goal generate times: 9
goal correct times: 2
action_num: 3

Task complete rate:
Keystate: k1 - Requires: 26 steps
Action Completion Rate: No actions required
Scene_id: 2
##############################
