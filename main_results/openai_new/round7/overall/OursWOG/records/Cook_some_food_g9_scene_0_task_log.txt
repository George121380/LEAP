From agent.py
Reset goals: The sub-goals are: 
['1. Find and peel the potatoes.', '2. Cut the potatoes into strips suitable for French fries.', '3. Fry the potato strips until crispy.']
##############################
Goal representation from planning.py

#exp_behavior

behavior find_knife_2050_around_kitchen_counter_230(knife:item):
    goal: not unknown(knife)
    body:
        assert is_knife(knife)
        bind kitchen_counter_instance:item where:
            is_kitchen_counter(kitchen_counter_instance) and id[kitchen_counter_instance]==230
        achieve close_char(char,kitchen_counter_instance)
        if can_open(kitchen_counter_instance):
            achieve_once open(kitchen_counter_instance)
            exp(knife,kitchen_counter_instance)
        else:
            exp(knife,kitchen_counter_instance)
    eff:
        unknown[knife]=False
        close[knife,kitchen_counter_instance]=True
        close[kitchen_counter_instance,knife]=True
    

behavior find_food_potato_2035_around_fridge_289(food_potato:item):
    goal: not unknown(food_potato)
    body:
        assert is_food_potato(food_potato)
        bind fridge_instance:item where:
            is_fridge(fridge_instance) and id[fridge_instance]==289
        achieve close_char(char,fridge_instance)
        if can_open(fridge_instance):
            achieve_once open(fridge_instance)
            exp(food_potato,fridge_instance)
        else:
            exp(food_potato,fridge_instance)
    eff:
        unknown[food_potato]=False
        close[food_potato,fridge_instance]=True
        close[fridge_instance,food_potato]=True
    

#exp_behavior_end

#goal_representation
 
def is_food_potato(x:item):
    return is_food(x) and is_food_potato(x)

def is_peeler(x:item):
    return is_utensil(x) and is_peeler(x)

def is_sink(x:item):
    return is_sink(x)

def is_find_and_peel_potatoes(x:item):
    return is_task(x) and is_find_and_peel_potatoes(x)

behavior find_and_peel_potatoes(potato: item, peeler: item, sink: item):
    body:
        achieve_once inhand(peeler)
        achieve clean(potato)
        achieve cut(potato)

behavior __goal__():
    body:
        bind potato: item where:
            is_food_potato(potato)
        bind peeler: item where:
            is_peeler(peeler)
        bind sink: item where:
            is_sink(sink)
        
        find_and_peel_potatoes(potato, peeler, sink)

#goal_representation_end

##############################
Inner TransformationError Debug
Error trying to process rule "function_definition":

'Function is_utensil not found. Note that recursive function calls are not supported in the current version.'
##############################
Goal representation after debugging in planning.py
#exp_behavior

behavior find_food_potato_2035_around_fridge_289(food_potato:item):
    goal: not unknown(food_potato)
    body:
        assert is_food_potato(food_potato)
        bind fridge_instance:item where:
            is_fridge(fridge_instance) and id[fridge_instance]==289
        achieve close_char(char,fridge_instance)
        if can_open(fridge_instance):
            achieve_once open(fridge_instance)
            exp(food_potato,fridge_instance)
        else:
            exp(food_potato,fridge_instance)
    eff:
        unknown[food_potato]=False
        close[food_potato,fridge_instance]=True
        close[fridge_instance,food_potato]=True
    

behavior find_knife_2050_around_kitchen_counter_230(knife:item):
    goal: not unknown(knife)
    body:
        assert is_knife(knife)
        bind kitchen_counter_instance:item where:
            is_kitchen_counter(kitchen_counter_instance) and id[kitchen_counter_instance]==230
        achieve close_char(char,kitchen_counter_instance)
        if can_open(kitchen_counter_instance):
            achieve_once open(kitchen_counter_instance)
            exp(knife,kitchen_counter_instance)
        else:
            exp(knife,kitchen_counter_instance)
    eff:
        unknown[knife]=False
        close[knife,kitchen_counter_instance]=True
        close[kitchen_counter_instance,knife]=True
    

#goal_representation
 
def is_food_potato(x:item):
    return is_food(x) and is_food_potato(x)

def is_peeler_item(x:item):
    return is_peeler(x) # Correcting to use is_peeler, as is_utensil is not available

def is_sink(x:item):
    return is_sink(x)

def is_find_and_peel_potatoes(x:item):
    return is_task(x) and is_find_and_peel_potatoes(x)

behavior find_and_peel_potatoes(potato: item, peeler: item, sink: item):
    body:
        achieve_once inhand(peeler)
        achieve clean(potato)
        achieve cut(potato)

behavior __goal__():
    body:
        bind potato: item where:
            is_food_potato(potato)
        bind peeler: item where:
            is_peeler(peeler)
        bind sink: item where:
            is_sink(sink)
        
        find_and_peel_potatoes(potato, peeler, sink)

#goal_representation_end

##############################
Inner TransformationError Debug
Error trying to process rule "function_definition":

'Function is_peeler not found. Note that recursive function calls are not supported in the current version.'
##############################
Goal representation after debugging in planning.py
#exp_behavior

behavior find_knife_2050_around_kitchen_counter_230(knife:item):
    goal: not unknown(knife)
    body:
        assert is_knife(knife)
        bind kitchen_counter_instance:item where:
            is_kitchen_counter(kitchen_counter_instance) and id[kitchen_counter_instance]==230
        achieve close_char(char,kitchen_counter_instance)
        if can_open(kitchen_counter_instance):
            achieve_once open(kitchen_counter_instance)
            exp(knife,kitchen_counter_instance)
        else:
            exp(knife,kitchen_counter_instance)
    eff:
        unknown[knife]=False
        close[knife,kitchen_counter_instance]=True
        close[kitchen_counter_instance,knife]=True
    

behavior find_food_potato_2035_around_fridge_289(food_potato:item):
    goal: not unknown(food_potato)
    body:
        assert is_food_potato(food_potato)
        bind fridge_instance:item where:
            is_fridge(fridge_instance) and id[fridge_instance]==289
        achieve close_char(char,fridge_instance)
        if can_open(fridge_instance):
            achieve_once open(fridge_instance)
            exp(food_potato,fridge_instance)
        else:
            exp(food_potato,fridge_instance)
    eff:
        unknown[food_potato]=False
        close[food_potato,fridge_instance]=True
        close[fridge_instance,food_potato]=True
    

#goal_representation
 
def is_food_potato(x:item):
    return is_food(x) and is_food_potato(x)

def is_sink(x:item):
    return is_sink(x)

behavior find_and_peel_potatoes(potato: item, peeler: item, sink: item):
    body:
        achieve_once inhand(peeler)
        achieve clean(potato)
        achieve cut(potato)

behavior __goal__():
    body:
        bind potato: item where:
            is_food_potato(potato)
        bind peeler: item where:
            is_knife(peeler)
        bind sink: item where:
            is_sink(sink)
        
        find_and_peel_potatoes(potato, peeler, sink)

#goal_representation_end

##############################
From agent.py->reset_goal
 
def is_food_potato(x:item):
    return is_food(x) and is_food_potato(x)

def is_sink(x:item):
    return is_sink(x)

behavior find_and_peel_potatoes(potato: item, peeler: item, sink: item):
    body:
        achieve_once inhand(peeler)
        achieve clean(potato)
        achieve cut(potato)

behavior __goal__():
    body:
        bind potato: item where:
            is_food_potato(potato)
        bind peeler: item where:
            is_knife(peeler)
        bind sink: item where:
            is_sink(sink)
        
        find_and_peel_potatoes(potato, peeler, sink)

##############################
From agent.py-> find a plan in act()
walk_executor(kitchen_counter_230)exp(knife_2050, kitchen_counter_230)walk_executor(knife_2050)grab_executor(knife_2050)walk_executor(fridge_289)switchoff_executor(fridge_289)open_executor(fridge_289)exp(food_potato_2035, fridge_289)walk_executor(food_potato_2035)grab_executor(food_potato_2035)walk_executor(kitchen_counter_230)put_executor(knife_2050, kitchen_counter_230)switchon_executor(faucet_232)wash_executor(food_potato_2035)switchoff_executor(faucet_232)put_executor(food_potato_2035, cutting_board_2051)walk_executor(knife_2050)grab_executor(knife_2050)walk_executor(food_potato_2035)cut_executor(food_potato_2035)
##############################
From agent.py
walk_executor(kitchen_counter_230)
Robot find: drawing_238, drawing_239, drawing_240, drawing_241, drawing_242, drawing_243, napkin_2005, oil_2079, cup_2063, knife_2050, cup_2064, pot_2069, fryingpan_2083, Robot is close to the kitchen_counter_230. 
##############################
From agent.py
exp(knife_2050, kitchen_counter_230)
Find knife_2050. 
##############################
From agent.py-> find a plan in act()
walk_executor(knife_2050)grab_executor(knife_2050)walk_executor(fridge_289)switchoff_executor(fridge_289)open_executor(fridge_289)exp(food_potato_2035, fridge_289)walk_executor(food_potato_2035)grab_executor(food_potato_2035)walk_executor(kitchen_counter_230)put_executor(knife_2050, kitchen_counter_230)switchon_executor(faucet_232)wash_executor(food_potato_2035)switchoff_executor(faucet_232)put_executor(food_potato_2035, cutting_board_2051)walk_executor(knife_2050)grab_executor(knife_2050)walk_executor(food_potato_2035)cut_executor(food_potato_2035)
##############################
From agent.py
walk_executor(knife_2050)
Robot find: Robot is close to the kitchen_counter_230. Robot is close to the knife_2050. 
##############################
From agent.py
grab_executor(knife_2050)
Robot find: Robot is close to the kitchen_counter_230. Robot is close to the knife_2050. Grabbing knife_2050 by right hand. 
##############################
From agent.py
walk_executor(fridge_289)
Robot find: Robot is close to the knife_2050. Robot is close to the fridge_289. 
##############################
From agent.py
switchoff_executor(fridge_289)
Robot find: Robot is close to the knife_2050. Robot is close to the fridge_289. fridge_289 is turned off. 
##############################
From agent.py
open_executor(fridge_289)
Robot find: sauce_2078, food_steak_2008, food_apple_2009, food_bacon_2010, food_banana_2011, food_bread_2012, food_cake_2013, food_carrot_2014, food_cereal_2015, food_cheese_2016, food_chicken_2017, food_dessert_2018, food_donut_2019, food_egg_2020, food_fish_2021, food_food_2022, food_fruit_2023, food_hamburger_2024, food_ice_cream_2025, food_jam_2026, food_kiwi_2027, food_lemon_2028, food_noodles_2029, food_oatmeal_2030, food_orange_2031, food_onion_2032, food_peanut_butter_2033, food_pizza_2034, food_potato_2035, food_rice_2036, food_salt_2037, food_snack_2038, food_sugar_2039, food_turkey_2040, food_vegetable_2041, dry_pasta_2042, milk_2043, Robot is close to the knife_2050. Robot is close to the sauce_2078. Robot is close to the fridge_289. Robot is close to the food_steak_2008. Robot is close to the food_apple_2009. Robot is close to the food_bacon_2010. Robot is close to the food_banana_2011. Robot is close to the food_bread_2012. Robot is close to the food_cake_2013. Robot is close to the food_carrot_2014. Robot is close to the food_cereal_2015. Robot is close to the food_cheese_2016. Robot is close to the food_chicken_2017. Robot is close to the food_dessert_2018. Robot is close to the food_donut_2019. Robot is close to the food_egg_2020. Robot is close to the food_fish_2021. Robot is close to the food_food_2022. Robot is close to the food_fruit_2023. Robot is close to the food_hamburger_2024. Robot is close to the food_ice_cream_2025. Robot is close to the food_jam_2026. Robot is close to the food_kiwi_2027. Robot is close to the food_lemon_2028. Robot is close to the food_noodles_2029. Robot is close to the food_oatmeal_2030. Robot is close to the food_orange_2031. Robot is close to the food_onion_2032. Robot is close to the food_peanut_butter_2033. Robot is close to the food_pizza_2034. Robot is close to the food_potato_2035. Robot is close to the food_rice_2036. Robot is close to the food_salt_2037. Robot is close to the food_snack_2038. Robot is close to the food_sugar_2039. Robot is close to the food_turkey_2040. Robot is close to the food_vegetable_2041. Robot is close to the dry_pasta_2042. Robot is close to the milk_2043. fridge_289 is opened. 
##############################
From agent.py
exp(food_potato_2035, fridge_289)
Find food_potato_2035. 
##############################
From agent.py-> find a plan in act()
grab_executor(food_potato_2035)walk_executor(cutting_board_2051)put_executor(food_potato_2035, cutting_board_2051)walk_executor(food_potato_2035)cut_executor(food_potato_2035)
##############################
From agent.py
grab_executor(food_potato_2035)
Robot find: Robot is close to the knife_2050. Robot is close to the sauce_2078. Robot is close to the fridge_289. Robot is close to the food_steak_2008. Robot is close to the food_apple_2009. Robot is close to the food_bacon_2010. Robot is close to the food_banana_2011. Robot is close to the food_bread_2012. Robot is close to the food_cake_2013. Robot is close to the food_carrot_2014. Robot is close to the food_cereal_2015. Robot is close to the food_cheese_2016. Robot is close to the food_chicken_2017. Robot is close to the food_dessert_2018. Robot is close to the food_donut_2019. Robot is close to the food_egg_2020. Robot is close to the food_fish_2021. Robot is close to the food_food_2022. Robot is close to the food_fruit_2023. Robot is close to the food_hamburger_2024. Robot is close to the food_ice_cream_2025. Robot is close to the food_jam_2026. Robot is close to the food_kiwi_2027. Robot is close to the food_lemon_2028. Robot is close to the food_noodles_2029. Robot is close to the food_oatmeal_2030. Robot is close to the food_orange_2031. Robot is close to the food_onion_2032. Robot is close to the food_peanut_butter_2033. Robot is close to the food_pizza_2034. Robot is close to the food_potato_2035. Robot is close to the food_rice_2036. Robot is close to the food_salt_2037. Robot is close to the food_snack_2038. Robot is close to the food_sugar_2039. Robot is close to the food_turkey_2040. Robot is close to the food_vegetable_2041. Robot is close to the dry_pasta_2042. Robot is close to the milk_2043. Grabbing food_potato_2035 by left hand. 
##############################
From agent.py
walk_executor(cutting_board_2051)
Robot find: Robot is close to the knife_2050. Robot is close to the food_potato_2035. Robot is close to the cutting_board_2051. Robot is close to the kitchen_counter_230. 
##############################
From agent.py
put_executor(food_potato_2035, cutting_board_2051)
Robot find: Robot is close to the knife_2050. Robot is close to the food_potato_2035. Robot is close to the cutting_board_2051. Robot is close to the kitchen_counter_230. cutting_board_2051 is close food_potato_2035. food_potato_2035 is close cutting_board_2051. food_potato_2035 is on cutting_board_2051. food_potato_2035 released by left hand. 
##############################
From agent.py
walk_executor(food_potato_2035)
Robot find: Robot is close to the knife_2050. Robot is close to the food_potato_2035. Robot is close to the cutting_board_2051. 
##############################
From agent.py
cut_executor(food_potato_2035)
Robot find: Robot is close to the knife_2050. Robot is close to the food_potato_2035. Robot is close to the cutting_board_2051. 
##############################
From agent.py -> evaluate_current_subgoal()
The evaluation result for current subgoal: No
The feedback instruction: You have not yet peeled the potatoes. The task requires peeling the potatoes, but the actions performed only include cutting them. You need to peel the potatoes before proceeding.
##############################
From agent.py
Human Instruction: You have not yet peeled the potatoes. The task requires peeling the potatoes, but the actions performed only include cutting them. You need to peel the potatoes before proceeding.

The actions you have taken:
Action 1: Walk to kitchen_counter_230.
Action 2: look for knife_2050 around kitchen_counter_230.
Action 3: Walk to knife_2050.
Action 4: Grab knife_2050.
Action 5: Walk to fridge_289.
Action 6: Switch off fridge_289.
Action 7: Open fridge_289.
Action 8: look for food_potato_2035 around fridge_289.
Action 9: Grab food_potato_2035.
Action 10: Walk to cutting_board_2051.
Action 11: Put food_potato_2035 on cutting_board_2051.
Action 12: Walk to food_potato_2035.
Action 13: Cut food_potato_2035.

##############################
Goal representation from planning.py

#exp_behavior

behavior find_chair_2004_around_desk_104(chair:item):
    goal: not unknown(chair)
    body:
        assert is_chair(chair)
        bind desk_instance:item where:
            is_desk(desk_instance) and id[desk_instance]==104
        achieve close_char(char,desk_instance)
        if can_open(desk_instance):
            achieve_once open(desk_instance)
            exp(chair,desk_instance)
        else:
            exp(chair,desk_instance)
    eff:
        unknown[chair]=False
        close[chair,desk_instance]=True
        close[desk_instance,chair]=True
    

behavior find_plate_1000_around_cupboard_229(plate:item):
    goal: not unknown(plate)
    body:
        assert is_plate(plate)
        bind cupboard_instance:item where:
            is_cupboard(cupboard_instance) and id[cupboard_instance]==229
        achieve close_char(char,cupboard_instance)
        if can_open(cupboard_instance):
            achieve_once open(cupboard_instance)
            exp(plate,cupboard_instance)
        else:
            exp(plate,cupboard_instance)
    eff:
        unknown[plate]=False
        close[plate,cupboard_instance]=True
        close[cupboard_instance,plate]=True
    

behavior find_bowl_2072_around_cupboard_229(bowl:item):
    goal: not unknown(bowl)
    body:
        assert is_bowl(bowl)
        bind cupboard_instance:item where:
            is_cupboard(cupboard_instance) and id[cupboard_instance]==229
        achieve close_char(char,cupboard_instance)
        if can_open(cupboard_instance):
            achieve_once open(cupboard_instance)
            exp(bowl,cupboard_instance)
        else:
            exp(bowl,cupboard_instance)
    eff:
        unknown[bowl]=False
        close[bowl,cupboard_instance]=True
        close[cupboard_instance,bowl]=True
    

#exp_behavior_end

#goal_representation
 
behavior peel_potatoes(potatoes:item, knife:item, cutting_board:item):
    body:
        achieve_once on(potatoes, cutting_board)
        foreach potato: item:
            if inside(potato, potatoes):
                achieve_once cut(potato)
        # Simulate peeling action using cutting behavior

behavior __goal__():
    body:
        bind potatoes: item where:
            is_food_potato(potatoes)
        # Select food_potato_2035 which you have already grabbed

        bind knife: item where:
            is_knife(knife)
        # Select the knife_2050

        bind cutting_board: item where:
            is_cutting_board(cutting_board)
        # Select the cutting_board_2051

        peel_potatoes(potatoes, knife, cutting_board)


#goal_representation_end

##############################
Goal representation from planning.py

#exp_behavior

#exp_behavior_end

#goal_representation

behavior peel_potatoes(potato:item, knife:item):
    body:
        achieve_once inhand(knife)
        # Hold the knife to peel potatoes
        achieve_once clean(potato)
        # Ensure the potatoes are peeled

behavior __goal__():
    body:
        bind potato: item where:
            is_food_potato(potato)
        # Select a potato to peel

        bind knife: item where:
            is_knife(knife)
        # Select a knife for peeling the potatoes
        
        peel_potatoes(potato, knife)
        # Peel the potato using the knife

#goal_representation_end

##############################
Goal representation from planning.py

#exp_behavior

#exp_behavior_end

#goal_representation
 
def has_unpeeled_potatoes(potato:item):
    # Function to check if there are any unpeeled potatoes
    return is_food_potato(potato) and not cut(potato)

behavior __goal__():
    body:
        if exists potato: item : (has_unpeeled_potatoes(potato)):
            # Check if there are any unpeeled potatoes
            bind potato: item where:
                has_unpeeled_potatoes(potato)
            # Approach the potato
            achieve close_char(char, potato)
        else:
            # If no unpeeled potatoes are found, initiate exploration to find them
            foreach potato: item:
                if is_food_potato(potato) and not visited(potato):
                    observe(potato, "Locate unpeeled potatoes")
 
#goal_representation_end

##############################
From agent.py->reset_sub_goal
 
def has_unpeeled_potatoes(potato:item):
    # Function to check if there are any unpeeled potatoes
    return is_food_potato(potato) and not cut(potato)

behavior __goal__():
    body:
        if exists potato: item : (has_unpeeled_potatoes(potato)):
            # Check if there are any unpeeled potatoes
            bind potato: item where:
                has_unpeeled_potatoes(potato)
            # Approach the potato
            achieve close_char(char, potato)
        else:
            # If no unpeeled potatoes are found, initiate exploration to find them
            foreach potato: item:
                if is_food_potato(potato) and not visited(potato):
                    observe(potato, "Locate unpeeled potatoes")
 
##############################
From agent.py-> find a plan in act()
obs(food_potato_2035, Locate unpeeled potatoes)
##############################
From agent.py
obs(food_potato_2035, Locate unpeeled potatoes)
Get this information:  food_potato_2035 is inside dining_room_201. food_potato_2035 is close to character_65. food_potato_2035 is close to cutting_board_2051. food_potato_2035 is on cutting_board_2051. food_potato_2035 is CLEAN.
##############################
From agent.py -> evaluate_current_subgoal()
The evaluation result for current subgoal: No
The feedback instruction: You need to peel the potatoes. The current actions only involve cutting the potatoes, but peeling has not been completed as the instructions specified.
##############################
From agent.py
Human Instruction: You need to peel the potatoes. The current actions only involve cutting the potatoes, but peeling has not been completed as the instructions specified.

The actions you have taken:
Action 1: Walk to kitchen_counter_230.
Action 2: look for knife_2050 around kitchen_counter_230.
Action 3: Walk to knife_2050.
Action 4: Grab knife_2050.
Action 5: Walk to fridge_289.
Action 6: Switch off fridge_289.
Action 7: Open fridge_289.
Action 8: look for food_potato_2035 around fridge_289.
Action 9: Grab food_potato_2035.
Action 10: Walk to cutting_board_2051.
Action 11: Put food_potato_2035 on cutting_board_2051.
Action 12: Walk to food_potato_2035.
Action 13: Cut food_potato_2035.
Action 14: Observe around food_potato_2035 with the question of Locate unpeeled potatoes.

##############################
Goal representation from planning.py

#exp_behavior

#exp_behavior_end

#goal_representation
 
def has_unpeeled_potatoes(potato:item):
    # Function to check if a potato is not yet peeled
    symbol found=not cut(potato)
    return found

behavior find_unpeeled_potatoes(potato:item):
    body:
        achieve close_char(char, potato)

behavior __goal__():
    body:
        if exists potato: item: (is_food_potato(potato) and has_unpeeled_potatoes(potato)):
            # Check if there is an unpeeled potato based on the known information
            bind potato: item where:
                is_food_potato(potato) and has_unpeeled_potatoes(potato)
            # Select an unpeeled potato
            find_unpeeled_potatoes(potato)
        
        else:
            # If no unpeeled potatoes are found, initiate exploration
            foreach potato: item:
                if is_food_potato(potato) and not visited(potato):
                    observe(potato, "Locate unpeeled potatoes")

#goal_representation_end

##############################
Goal representation from planning.py

#exp_behavior

behavior find_iron_2089_around_ironing_board_2074(iron:item):
    goal: not unknown(iron)
    body:
        assert is_iron(iron)
        bind ironing_board_instance:item where:
            is_ironing_board(ironing_board_instance) and id[ironing_board_instance]==2074
        achieve close_char(char,ironing_board_instance)
        if can_open(ironing_board_instance):
            achieve_once open(ironing_board_instance)
            exp(iron,ironing_board_instance)
        else:
            exp(iron,ironing_board_instance)
    eff:
        unknown[iron]=False
        close[iron,ironing_board_instance]=True
        close[ironing_board_instance,iron]=True
    

behavior find_plate_1000_around_cupboard_229(plate:item):
    goal: not unknown(plate)
    body:
        assert is_plate(plate)
        bind cupboard_instance:item where:
            is_cupboard(cupboard_instance) and id[cupboard_instance]==229
        achieve close_char(char,cupboard_instance)
        if can_open(cupboard_instance):
            achieve_once open(cupboard_instance)
            exp(plate,cupboard_instance)
        else:
            exp(plate,cupboard_instance)
    eff:
        unknown[plate]=False
        close[plate,cupboard_instance]=True
        close[cupboard_instance,plate]=True
    

behavior find_bowl_2071_around_cupboard_229(bowl:item):
    goal: not unknown(bowl)
    body:
        assert is_bowl(bowl)
        bind cupboard_instance:item where:
            is_cupboard(cupboard_instance) and id[cupboard_instance]==229
        achieve close_char(char,cupboard_instance)
        if can_open(cupboard_instance):
            achieve_once open(cupboard_instance)
            exp(bowl,cupboard_instance)
        else:
            exp(bowl,cupboard_instance)
    eff:
        unknown[bowl]=False
        close[bowl,cupboard_instance]=True
        close[cupboard_instance,bowl]=True
    

#exp_behavior_end

#goal_representation
 
def has_unpeeled_potatoes(potato:item):
    # Function to check if food_potato is unpeeled
    symbol unpeeled=exists o: item : (is_food_potato(o) and not cut(o))
    return unpeeled

behavior peel_potatoes(potato:item):
    body:
        achieve cut(potato)
        # Peeling the potatoes involves cutting them

behavior __goal__():
    body:
        if exists potato: item : (is_food_potato(potato) and has_unpeeled_potatoes(potato)):
            # If unpeeled potatoes exist, bind and peel them
            bind potato: item where:
                is_food_potato(potato) and has_unpeeled_potatoes(potato)
            # Select the potato to peel
            peel_potatoes(potato)

        else:
            # If no unpeeled potatoes are found, start searching
            foreach potato: item:
                if is_food_potato(potato) and not visited(potato):
                    observe(potato, "Locate unpeeled potatoes")

#goal_representation_end

##############################
Error is:
Failed to rename the derived function application.
##############################
Goal representation from planning.py

#exp_behavior

behavior find_cleaning_solution_2073_around_bathroom_cabinet_40(cleaning_solution:item):
    goal: not unknown(cleaning_solution)
    body:
        assert is_cleaning_solution(cleaning_solution)
        bind bathroom_cabinet_instance:item where:
            is_bathroom_cabinet(bathroom_cabinet_instance) and id[bathroom_cabinet_instance]==40
        achieve close_char(char,bathroom_cabinet_instance)
        if can_open(bathroom_cabinet_instance):
            achieve_once open(bathroom_cabinet_instance)
            exp(cleaning_solution,bathroom_cabinet_instance)
        else:
            exp(cleaning_solution,bathroom_cabinet_instance)
    eff:
        unknown[cleaning_solution]=False
        close[cleaning_solution,bathroom_cabinet_instance]=True
        close[bathroom_cabinet_instance,cleaning_solution]=True
    

#exp_behavior_end

#goal_representation
 
def is_food_potato_unpeeled(potato:item):
    # Check if the potato is unpeeled
    symbol unpeeled=exists o: item : (is_food_potato(o) and not clean(o))
    return unpeeled

behavior find_and_peel_potatoes(potato:item):
    body:
        if is_food_potato_unpeeled(potato):
            achieve_once inhand(potato)
            observe(potato, "Check if potato is unpeeled")
            achieve_once clean(potato)
        else:
            return

behavior __goal__():
    body:
        bind potato: item where:
            is_food_potato(potato)
        
        find_and_peel_potatoes(potato)

#goal_representation_end

##############################
Inner TransformationError Debug
Unexpected token Token('_NEWLINE', '\n\n') at line 5807, column 19.
Expected one of: 
	* LPAR
	* HEX_NUMBER
	* FINDALL
	* STRING
	* FALSE
	* LSQB
	* NONE
	* ELLIPSIS
	* FORALL
	* PLUS
	* DO
	* COLON
	* TILDE
	* FINDONE
	* TRUE
	* EXISTS
	* LONG_STRING
	* MINUS
	* BIN_NUMBER
	* FLOAT_NUMBER
	* NOT
	* OCT_NUMBER
	* DEC_NUMBER
	* IMAG_NUMBER
	* VARNAME

##############################
Goal representation after debugging in planning.py
#exp_behavior

#goal_representation
 
def is_food_potato_unpeeled(potato:item):
    # Check if the potato is unpeeled
    symbol unpeeled=exists o: item : (is_food_potato(o) and not clean(o))
    return unpeeled

behavior find_and_peel_potatoes(potato:item):
    body:
        if is_food_potato_unpeeled(potato):
            achieve_once inhand(potato)
            observe(potato, "Check if potato is unpeeled")
            achieve_once clean(potato)
        else:
            return

behavior __goal__():
    body:
        bind potato: item where:
            is_food_potato(potato)
        
        find_and_peel_potatoes(potato)

#goal_representation_end

##############################
Inner TransformationError Debug
Unexpected token Token('_NEWLINE', '\n\n') at line 5789, column 19.
Expected one of: 
	* LPAR
	* HEX_NUMBER
	* FINDALL
	* STRING
	* FALSE
	* LSQB
	* NONE
	* ELLIPSIS
	* FORALL
	* PLUS
	* DO
	* COLON
	* TILDE
	* FINDONE
	* TRUE
	* EXISTS
	* LONG_STRING
	* MINUS
	* BIN_NUMBER
	* FLOAT_NUMBER
	* NOT
	* OCT_NUMBER
	* DEC_NUMBER
	* IMAG_NUMBER
	* VARNAME

##############################
Goal representation after debugging in planning.py
#exp_behavior

behavior find_cleaning_solution_2073_around_bathroom_cabinet_40(cleaning_solution:item):
    goal: not unknown(cleaning_solution)
    body:
        assert is_cleaning_solution(cleaning_solution)
        bind bathroom_cabinet_instance:item where:
            is_bathroom_cabinet(bathroom_cabinet_instance) and id[bathroom_cabinet_instance]==40
        achieve close_char(char,bathroom_cabinet_instance)
        if can_open(bathroom_cabinet_instance):
            achieve_once open(bathroom_cabinet_instance)
            exp(cleaning_solution,bathroom_cabinet_instance)
        else:
            exp(cleaning_solution,bathroom_cabinet_instance)
    eff:
        unknown[cleaning_solution]=False
        close[cleaning_solution,bathroom_cabinet_instance]=True
        close[bathroom_cabinet_instance,cleaning_solution]=True
    

#goal_representation
 
def is_food_potato_unpeeled(potato:item):
    # Check if the potato is unpeeled
    symbol unpeeled=exists o: item : (is_food_potato(o) and not clean(o))
    return unpeeled

behavior find_and_peel_potatoes(potato:item):
    body:
        if is_food_potato_unpeeled(potato):
            achieve_once inhand(potato)
            observe(potato, "Check if potato is unpeeled")
            achieve_once clean(potato)

behavior __goal__():
    body:
        bind potato: item where:
            is_food_potato(potato)
        
        find_and_peel_potatoes(potato)

#goal_representation_end

##############################
VH_pipeline: Fail to generate a valid plan
##############################
From agent.py
Reset goals: The sub-goals are: 
['1. Peel and cut the potatoes into fries.', '2. Fry the potatoes in oil until they are golden and crispy.', '3. Place the French fries on a plate.']
##############################
Goal representation from planning.py

#exp_behavior

#exp_behavior_end

#goal_representation
 
behavior peel_and_cut_potatoes(potato: item, cutting_board: item, knife: item):
    body:
        achieve_once on(potato, cutting_board)
        # Place the potato on the cutting board
        achieve_once cut(potato)
        # Cut the potatoes into fries

behavior __goal__():
    body:
        bind potato: item where:
            is_food_potato(potato)
        # Select the potato

        bind cutting_board: item where:
            is_cutting_board(cutting_board)
        # Select a cutting board for peeling and cutting the potatoes

        bind knife: item where:
            is_knife(knife)
        # Select a knife for peeling and cutting the potatoes

        peel_and_cut_potatoes(potato, cutting_board, knife)

#goal_representation_end

##############################
Goal representation from planning.py

#exp_behavior

#exp_behavior_end

#goal_representation
 
def peel_potatoes(potato:item):
    # This function is used to ensure that the potato is peeled
    achieve clean(potato)

behavior cut_potato_into_fries(potato:item, cutting_board:item, knife:item):
    body:
        achieve_once on(potato, cutting_board)
        # Place the potato on the cutting board
        achieve_once cut(potato)
        # Cut the potato into fries

behavior __goal__():
    body:
        bind potato: item where:
            is_food_potato(potato)
        # Select the potato to be peeled and cut

        bind cutting_board: item where:
            is_cutting_board(cutting_board)
        # Select a cutting board for cutting

        bind knife: item where:
            is_knife(knife)
        # Select a knife for cutting the potatoes

        peel_potatoes(potato)
        cut_potato_into_fries(potato, cutting_board, knife)

#goal_representation_end

##############################
Inner TransformationError Debug
Error trying to process rule "function_definition":

Achieve statements are not allowed in the current mode: SymbolicExecutionMode.DERIVED
##############################
Goal representation after debugging in planning.py
#exp_behavior

#goal_representation
 
behavior peel_potatoes(potato:item):
    body:
        achieve_once clean(potato)

behavior cut_potato_into_fries(potato:item, cutting_board:item, knife:item):
    body:
        achieve_once on(potato, cutting_board)
        achieve_once cut(potato)

behavior __goal__():
    body:
        bind potato: item where:
            is_food_potato(potato)

        bind cutting_board: item where:
            is_cutting_board(cutting_board)

        bind knife: item where:
            is_knife(knife)

        peel_potatoes(potato)
        cut_potato_into_fries(potato, cutting_board, knife)

#goal_representation_end

##############################
Goal representation from planning.py

#exp_behavior

behavior find_cleaning_solution_2073_around_bathroom_cabinet_40(cleaning_solution:item):
    goal: not unknown(cleaning_solution)
    body:
        assert is_cleaning_solution(cleaning_solution)
        bind bathroom_cabinet_instance:item where:
            is_bathroom_cabinet(bathroom_cabinet_instance) and id[bathroom_cabinet_instance]==40
        achieve close_char(char,bathroom_cabinet_instance)
        if can_open(bathroom_cabinet_instance):
            achieve_once open(bathroom_cabinet_instance)
            exp(cleaning_solution,bathroom_cabinet_instance)
        else:
            exp(cleaning_solution,bathroom_cabinet_instance)
    eff:
        unknown[cleaning_solution]=False
        close[cleaning_solution,bathroom_cabinet_instance]=True
        close[bathroom_cabinet_instance,cleaning_solution]=True
    

#exp_behavior_end

#goal_representation
 
behavior peel_potatoes(potato:item):
    body:
        achieve_once clean(potato)

behavior cut_potatoes_into_fries(potato:item, knife:item, cutting_board:item):
    body:
        achieve_once on(potato, cutting_board) 
        achieve_once cut(potato)

behavior __goal__():
    body:
        bind food_potato: item where:
            is_food_potato(food_potato)
        # Select the potato to be peeled and cut into fries

        bind knife: item where:
            is_knife(knife)
        # Select a knife for cutting

        bind cutting_board: item where:
            is_cutting_board(cutting_board)
        # Select a cutting board for cutting the potatoes

        peel_potatoes(food_potato)
        cut_potatoes_into_fries(food_potato, knife, cutting_board)

#goal_representation_end

##############################
VH_pipeline: Fail to generate a valid plan
##############################
From agent.py->reset_goal
Fail to generate the goal representation
##############################
From agent.py
Reset goals: The sub-goals are: 
['1. Peel and cut the potatoes into fries.', '2. Fry the potato pieces until they are crispy.', '3. Place the cooked French fries on a serving plate.']
##############################
Goal representation from planning.py

#exp_behavior

behavior find_pencil_2001_around_desk_357(pencil:item):
    goal: not unknown(pencil)
    body:
        assert is_pencil(pencil)
        bind desk_instance:item where:
            is_desk(desk_instance) and id[desk_instance]==357
        achieve close_char(char,desk_instance)
        if can_open(desk_instance):
            achieve_once open(desk_instance)
            exp(pencil,desk_instance)
        else:
            exp(pencil,desk_instance)
    eff:
        unknown[pencil]=False
        close[pencil,desk_instance]=True
        close[desk_instance,pencil]=True
    

#exp_behavior_end

#goal_representation
behavior peel_potatoes(potato: item):
    body:
        # The goal here is to peel the potatoes
        achieve_once not dirty(potato)

behavior cut_potatoes_into_fries(potato: item, cutting_board: item, knife: item):
    body:
        # Place the potato on the cutting board
        achieve_once on(potato, cutting_board)
        # Use the knife to cut the potatoes into fries
        achieve_once cut(potato)

behavior __goal__():
    body:
        bind potato: item where:
            is_food_potato(potato)
        # Select a potato

        bind cutting_board: item where:
            is_cutting_board(cutting_board)
        # Select a cutting board

        bind knife: item where:
            is_knife(knife)
        # Select a knife for cutting

        peel_potatoes(potato)
        cut_potatoes_into_fries(potato, cutting_board, knife)
#goal_representation_end

##############################
Goal representation from planning.py

#exp_behavior

#exp_behavior_end

#goal_representation
behavior peel_and_cut_potatoes(potato:item, cutting_board:item, knife:item):
    body:
        achieve_once on(potato, cutting_board)
        # Place the potato on the cutting board
        # Assume the potato is peeled before cutting
        achieve_once cut(potato)
        # Cut the potato into fries

behavior __goal__():
    body:
        bind potato: item where:
            is_food_potato(potato) and id[potato] == 2035
        # Select the potato with ID 2035

        bind cutting_board: item where:
            is_cutting_board(cutting_board) and id[cutting_board] == 2051
        # Select the cutting board with ID 2051

        bind knife: item where:
            is_knife(knife)
        # Select a knife to peel and cut the potato

        peel_and_cut_potatoes(potato, cutting_board, knife)
#goal_representation_end

##############################
Goal representation from planning.py

#exp_behavior

behavior find_iron_2089_around_ironing_board_2074(iron:item):
    goal: not unknown(iron)
    body:
        assert is_iron(iron)
        bind ironing_board_instance:item where:
            is_ironing_board(ironing_board_instance) and id[ironing_board_instance]==2074
        achieve close_char(char,ironing_board_instance)
        if can_open(ironing_board_instance):
            achieve_once open(ironing_board_instance)
            exp(iron,ironing_board_instance)
        else:
            exp(iron,ironing_board_instance)
    eff:
        unknown[iron]=False
        close[iron,ironing_board_instance]=True
        close[ironing_board_instance,iron]=True
    

behavior find_fork_2080_around_wallshelf_235(fork:item):
    goal: not unknown(fork)
    body:
        assert is_fork(fork)
        bind wallshelf_instance:item where:
            is_wallshelf(wallshelf_instance) and id[wallshelf_instance]==235
        achieve close_char(char,wallshelf_instance)
        if can_open(wallshelf_instance):
            achieve_once open(wallshelf_instance)
            exp(fork,wallshelf_instance)
        else:
            exp(fork,wallshelf_instance)
    eff:
        unknown[fork]=False
        close[fork,wallshelf_instance]=True
        close[wallshelf_instance,fork]=True
    

#exp_behavior_end

#goal_representation
 
behavior peel_and_cut_potatoes(potato: item, knife: item, cutting_board: item):
    body:
        achieve_once inhand(knife)
        # Temporarily hold the knife to peel the potato
        achieve_once on(potato, cutting_board)
        # Place the potato on the cutting board to peel and cut

behavior __goal__():
    body:
        bind potato: item where:
            is_food_potato(potato) and id[potato] == 2035
        # Select the potato to peel and cut

        bind knife: item where:
            is_knife(knife) and id[knife] == 2050
        # Select the knife for peeling and cutting

        bind cutting_board: item where:
            is_cutting_board(cutting_board) and id[cutting_board] == 2051
        # Select the cutting board for peeling and cutting

        peel_and_cut_potatoes(potato, knife, cutting_board)

#goal_representation_end

##############################
VH_pipeline: Fail to generate a valid plan
##############################
From agent.py->reset_goal
Fail to generate the goal representation
##############################
Task Summary:
Task Goal:
Make some French fries.
Action History:
['walk_executor(kitchen_counter_230)', 'walk_executor(knife_2050)', 'grab_executor(knife_2050)', 'walk_executor(fridge_289)', 'switchoff_executor(fridge_289)', 'open_executor(fridge_289)', 'grab_executor(food_potato_2035)', 'walk_executor(cutting_board_2051)', 'put_executor(food_potato_2035, cutting_board_2051)', 'walk_executor(food_potato_2035)', 'cut_executor(food_potato_2035)']
Time info:
Time consume: 331 seconds
Exp_helper query times: 0
Guidance query times: 0
library scale: 149
goal generate times: 13
goal correct times: 4
action_num: 11

Task complete rate:
Keystate: k1 - Requires: 13 steps
Action Completion Rate: No actions required
Scene_id: 0
##############################
