From agent.py
Reset goals: The sub-goals are: 
['1. Identify a pot on the stove.', '2. Boil the vegetables in the identified pot.']
##############################
Goal representation from planning.py

#exp_behavior

behavior find_sauce_2078_around_stove_2065(sauce:item):
    goal: not unknown(sauce)
    body:
        assert is_sauce(sauce)
        bind stove_instance:item where:
            is_stove(stove_instance) and id[stove_instance]==2065
        achieve close_char(char,stove_instance)
        if can_open(stove_instance):
            achieve_once open(stove_instance)
            exp(sauce,stove_instance)
        else:
            exp(sauce,stove_instance)
    eff:
        unknown[sauce]=False
        close[sauce,stove_instance]=True
        close[stove_instance,sauce]=True
    

behavior find_pot_2069_around_stove_2065(pot:item):
    goal: not unknown(pot)
    body:
        assert is_pot(pot)
        bind stove_instance:item where:
            is_stove(stove_instance) and id[stove_instance]==2065
        achieve close_char(char,stove_instance)
        if can_open(stove_instance):
            achieve_once open(stove_instance)
            exp(pot,stove_instance)
        else:
            exp(pot,stove_instance)
    eff:
        unknown[pot]=False
        close[pot,stove_instance]=True
        close[stove_instance,pot]=True
    

#exp_behavior_end

#goal_representation
 
def is_pot_on_stove(pot:item, stove:item):
    # Check if the pot is on the stove
    return on(pot, stove)

behavior observe_pot_on_stove(pot:item, stove:item):
    body:
        observe(pot, "Identify if the pot is on the stove")

behavior identify_pot_on_stove():
    body:
        bind pot: item where:
            is_pot(pot)
        bind stove: item where:
            is_stove(stove)
        
        if not is_pot_on_stove(pot, stove):
            observe_pot_on_stove(pot, stove)

behavior __goal__():
    body:
        identify_pot_on_stove()

#goal_representation_end

##############################
From agent.py->reset_goal
 
def is_pot_on_stove(pot:item, stove:item):
    # Check if the pot is on the stove
    return on(pot, stove)

behavior observe_pot_on_stove(pot:item, stove:item):
    body:
        observe(pot, "Identify if the pot is on the stove")

behavior identify_pot_on_stove():
    body:
        bind pot: item where:
            is_pot(pot)
        bind stove: item where:
            is_stove(stove)
        
        if not is_pot_on_stove(pot, stove):
            observe_pot_on_stove(pot, stove)

behavior __goal__():
    body:
        identify_pot_on_stove()

##############################
From agent.py-> find a plan in act()
walk_executor(stove_2065)open_executor(stove_2065)exp(pot_2069, stove_2065)walk_executor(pot_2069)open_executor(pot_2069)obs(pot_2069, Identify if the pot is on the stove)
##############################
From agent.py
walk_executor(stove_2065)
Robot find: drawing_238, drawing_239, drawing_240, drawing_241, drawing_242, drawing_243, napkin_2005, oil_2079, cup_2063, knife_2050, cup_2064, pot_2069, fryingpan_2083, Robot is close to the stove_2065. Robot is close to the kitchen_counter_230. 
##############################
From agent.py
open_executor(stove_2065)
Robot find: Robot is close to the stove_2065. Robot is close to the kitchen_counter_230. stove_2065 is opened. 
##############################
From agent.py
exp(pot_2069, stove_2065)
Find pot_2069. 
##############################
From agent.py-> find a plan in act()
walk_executor(pot_2069)open_executor(pot_2069)obs(pot_2069, Identify if the pot is on the stove)
##############################
From agent.py
walk_executor(pot_2069)
Robot find: Robot is close to the kitchen_counter_230. Robot is close to the pot_2069. 
##############################
From agent.py
open_executor(pot_2069)
Robot find: Robot is close to the kitchen_counter_230. Robot is close to the pot_2069. pot_2069 is opened. 
##############################
From agent.py
obs(pot_2069, Identify if the pot is on the stove)
Get this information:  pot_2069 is inside dining_room_201. pot_2069 is close to kitchen_counter_230. pot_2069 is close to character_65. pot_2069 is on kitchen_counter_230. pot_2069 is OPEN.
##############################
From agent.py -> evaluate_current_subgoal()
The evaluation result for current subgoal: No
The feedback instruction: The pot is currently on the kitchen counter, not on the stove. You need to move the pot from the kitchen counter to the stove to complete this sub-task.
##############################
From agent.py
Human Instruction: The pot is currently on the kitchen counter, not on the stove. You need to move the pot from the kitchen counter to the stove to complete this sub-task.

The actions you have taken:
Action 1: Walk to stove_2065.
Action 2: Open stove_2065.
Action 3: look for pot_2069 around stove_2065.
Action 4: Walk to pot_2069.
Action 5: Open pot_2069.
Action 6: Observe around pot_2069 with the question of Identify if the pot is on the stove.

##############################
Goal representation from planning.py

#exp_behavior

behavior find_bowl_2072_around_table_226(bowl:item):
    goal: not unknown(bowl)
    body:
        assert is_bowl(bowl)
        bind table_instance:item where:
            is_table(table_instance) and id[table_instance]==226
        achieve close_char(char,table_instance)
        if can_open(table_instance):
            achieve_once open(table_instance)
            exp(bowl,table_instance)
        else:
            exp(bowl,table_instance)
    eff:
        unknown[bowl]=False
        close[bowl,table_instance]=True
        close[table_instance,bowl]=True
    

#exp_behavior_end

#goal_representation
 
behavior locate_pot_and_move(pot: item, stove: item):
    body:
        if not on(pot, stove):
            if not inhand(pot):
                grab(pot)
            put_on(pot, stove)

behavior __goal__():
    body:
        bind pot: item where:
            is_pot(pot) and id[pot] == 2069
        # Select the pot with ID 2069

        bind stove: item where:
            is_stove(stove) and id[stove] == 2065
        # Select the stove with ID 2065

        walk_to(pot)
        # Approach the pot on the kitchen counter

        locate_pot_and_move(pot, stove)
        # Move the pot from the kitchen counter to the stove

#goal_representation_end

##############################
From agent.py->reset_sub_goal
 
behavior locate_pot_and_move(pot: item, stove: item):
    body:
        if not on(pot, stove):
            if not inhand(pot):
                grab(pot)
            put_on(pot, stove)

behavior __goal__():
    body:
        bind pot: item where:
            is_pot(pot) and id[pot] == 2069
        # Select the pot with ID 2069

        bind stove: item where:
            is_stove(stove) and id[stove] == 2065
        # Select the stove with ID 2065

        walk_to(pot)
        # Approach the pot on the kitchen counter

        locate_pot_and_move(pot, stove)
        # Move the pot from the kitchen counter to the stove

##############################
From agent.py-> find a plan in act()
walk_executor(pot_2069)grab_executor(pot_2069)walk_executor(stove_2065)put_executor(pot_2069, stove_2065)
##############################
From agent.py
walk_executor(pot_2069)
Robot find: Robot is close to the kitchen_counter_230. Robot is close to the pot_2069. 
##############################
From agent.py
grab_executor(pot_2069)
Robot find: Robot is close to the kitchen_counter_230. Robot is close to the pot_2069. Grabbing pot_2069 by right hand. 
##############################
From agent.py
walk_executor(stove_2065)
Robot find: Robot is close to the kitchen_counter_230. Robot is close to the pot_2069. Robot is close to the stove_2065. 
##############################
From agent.py
put_executor(pot_2069, stove_2065)
Robot find: Robot is close to the kitchen_counter_230. Robot is close to the pot_2069. Robot is close to the stove_2065. pot_2069 is close stove_2065. pot_2069 is on stove_2065. stove_2065 is close pot_2069. pot_2069 released by right hand. 
##############################
From agent.py -> evaluate_current_subgoal()
The evaluation result for current subgoal: Yes
The feedback instruction: None
##############################
Goal representation from planning.py

#exp_behavior

behavior find_food_vegetable_2041_around_cupboard_229(food_vegetable:item):
    goal: not unknown(food_vegetable)
    body:
        assert is_food_vegetable(food_vegetable)
        bind cupboard_instance:item where:
            is_cupboard(cupboard_instance) and id[cupboard_instance]==229
        achieve close_char(char,cupboard_instance)
        if can_open(cupboard_instance):
            achieve_once open(cupboard_instance)
            exp(food_vegetable,cupboard_instance)
        else:
            exp(food_vegetable,cupboard_instance)
    eff:
        unknown[food_vegetable]=False
        close[food_vegetable,cupboard_instance]=True
        close[cupboard_instance,food_vegetable]=True
    

behavior find_food_onion_2032_around_walllamp_27(food_onion:item):
    goal: not unknown(food_onion)
    body:
        assert is_food_onion(food_onion)
        bind walllamp_instance:item where:
            is_walllamp(walllamp_instance) and id[walllamp_instance]==27
        achieve close_char(char,walllamp_instance)
        if can_open(walllamp_instance):
            achieve_once open(walllamp_instance)
            exp(food_onion,walllamp_instance)
        else:
            exp(food_onion,walllamp_instance)
    eff:
        unknown[food_onion]=False
        close[food_onion,walllamp_instance]=True
        close[walllamp_instance,food_onion]=True
    

behavior find_milk_2043_around_fridge_289(milk:item):
    goal: not unknown(milk)
    body:
        assert is_milk(milk)
        bind fridge_instance:item where:
            is_fridge(fridge_instance) and id[fridge_instance]==289
        achieve close_char(char,fridge_instance)
        if can_open(fridge_instance):
            achieve_once open(fridge_instance)
            exp(milk,fridge_instance)
        else:
            exp(milk,fridge_instance)
    eff:
        unknown[milk]=False
        close[milk,fridge_instance]=True
        close[fridge_instance,milk]=True
    

behavior find_food_sugar_2039_around_fridge_289(food_sugar:item):
    goal: not unknown(food_sugar)
    body:
        assert is_food_sugar(food_sugar)
        bind fridge_instance:item where:
            is_fridge(fridge_instance) and id[fridge_instance]==289
        achieve close_char(char,fridge_instance)
        if can_open(fridge_instance):
            achieve_once open(fridge_instance)
            exp(food_sugar,fridge_instance)
        else:
            exp(food_sugar,fridge_instance)
    eff:
        unknown[food_sugar]=False
        close[food_sugar,fridge_instance]=True
        close[fridge_instance,food_sugar]=True
    

#exp_behavior_end

#goal_representation
 
def is_vegetables_boiling(pot:item, stove:item):
    # Determine if vegetables are boiling in the pot on the stove
    return is_on(stove) and inside(pot, stove) and dirty(pot)

behavior boil_vegetables_in_pot(pot:item, stove:item):
    body:
        if not inside(pot, stove):
            if not inhand(pot):
                grab(pot)
            walk_to(stove)
            put_on(pot, stove)
        
        if is_off(stove) and has_switch(stove):
            switch_on(stove)
            
        if not dirty(pot):
            get_water(pot)

behavior __goal__():
    body:
        bind stove: item where:
            is_stove(stove)

        bind pot: item where:
            is_pot(pot) and id[pot] == 2069

        if not is_vegetables_boiling(pot, stove):
            boil_vegetables_in_pot(pot, stove)


#goal_representation_end

##############################
From agent.py->reset_sub_goal
 
def is_vegetables_boiling(pot:item, stove:item):
    # Determine if vegetables are boiling in the pot on the stove
    return is_on(stove) and inside(pot, stove) and dirty(pot)

behavior boil_vegetables_in_pot(pot:item, stove:item):
    body:
        if not inside(pot, stove):
            if not inhand(pot):
                grab(pot)
            walk_to(stove)
            put_on(pot, stove)
        
        if is_off(stove) and has_switch(stove):
            switch_on(stove)
            
        if not dirty(pot):
            get_water(pot)

behavior __goal__():
    body:
        bind stove: item where:
            is_stove(stove)

        bind pot: item where:
            is_pot(pot) and id[pot] == 2069

        if not is_vegetables_boiling(pot, stove):
            boil_vegetables_in_pot(pot, stove)


##############################
From agent.py-> find a plan in act()
grab_executor(pot_2069)walk_executor(stove_2065)put_executor(pot_2069, stove_2065)switchon_executor(stove_2065)walk_executor(pot_2069)grab_executor(pot_2069)walk_executor(faucet_43)switchon_executor(faucet_43)switchoff_executor(faucet_43)
##############################
From agent.py
grab_executor(pot_2069)
Robot find: Robot is close to the kitchen_counter_230. Robot is close to the pot_2069. Robot is close to the stove_2065. Grabbing pot_2069 by right hand. 
##############################
From agent.py
walk_executor(stove_2065)
Robot find: Robot is close to the kitchen_counter_230. Robot is close to the pot_2069. Robot is close to the stove_2065. 
##############################
From agent.py
put_executor(pot_2069, stove_2065)
Robot find: Robot is close to the kitchen_counter_230. Robot is close to the pot_2069. Robot is close to the stove_2065. pot_2069 is close stove_2065. pot_2069 is on stove_2065. pot_2069 released by right hand. 
##############################
From agent.py
switchon_executor(stove_2065)
Robot find: Robot is close to the kitchen_counter_230. Robot is close to the pot_2069. Robot is close to the stove_2065. stove_2065 is turned on. 
##############################
From agent.py
walk_executor(pot_2069)
Robot find: Robot is close to the pot_2069. Robot is close to the stove_2065. 
##############################
From agent.py
grab_executor(pot_2069)
Robot find: Robot is close to the pot_2069. Robot is close to the stove_2065. Grabbing pot_2069 by right hand. 
##############################
From agent.py
walk_executor(faucet_43)
Robot find: towel_rack_31, towel_rack_32, towel_rack_34, Robot is close to the pot_2069. Robot is close to the bathroom_counter_41. Robot is close to the faucet_43. 
##############################
From agent.py
switchon_executor(faucet_43)
Robot find: Robot is close to the pot_2069. Robot is close to the bathroom_counter_41. Robot is close to the faucet_43. faucet_43 is turned on. 
##############################
From agent.py
switchoff_executor(faucet_43)
Robot find: Robot is close to the pot_2069. Robot is close to the bathroom_counter_41. Robot is close to the faucet_43. faucet_43 is turned off. 
##############################
From agent.py -> evaluate_current_subgoal()
The evaluation result for current subgoal: No
The feedback instruction: The pot should be filled with water to ensure the vegetables can boil. Make sure the pot, identified as pot_2069, contains water.
##############################
From agent.py
Human Instruction: The pot should be filled with water to ensure the vegetables can boil. Make sure the pot, identified as pot_2069, contains water.

The actions you have taken:
Action 1: Walk to stove_2065.
Action 2: Open stove_2065.
Action 3: look for pot_2069 around stove_2065.
Action 4: Walk to pot_2069.
Action 5: Open pot_2069.
Action 6: Observe around pot_2069 with the question of Identify if the pot is on the stove.
Action 7: Walk to pot_2069.
Action 8: Grab pot_2069.
Action 9: Walk to stove_2065.
Action 10: Put pot_2069 on stove_2065.
Action 11: Grab pot_2069.
Action 12: Walk to stove_2065.
Action 13: Put pot_2069 on stove_2065.
Action 14: Switch on stove_2065.
Action 15: Walk to pot_2069.
Action 16: Grab pot_2069.
Action 17: Walk to faucet_43.
Action 18: Switch on faucet_43.
Action 19: Switch off faucet_43.

##############################
Goal representation from planning.py

#exp_behavior

behavior find_food_vegetable_2041_around_fridge_289(food_vegetable:item):
    goal: not unknown(food_vegetable)
    body:
        assert is_food_vegetable(food_vegetable)
        bind fridge_instance:item where:
            is_fridge(fridge_instance) and id[fridge_instance]==289
        achieve close_char(char,fridge_instance)
        if can_open(fridge_instance):
            achieve_once open(fridge_instance)
            exp(food_vegetable,fridge_instance)
        else:
            exp(food_vegetable,fridge_instance)
    eff:
        unknown[food_vegetable]=False
        close[food_vegetable,fridge_instance]=True
        close[fridge_instance,food_vegetable]=True
    

behavior find_food_potato_2035_around_fridge_289(food_potato:item):
    goal: not unknown(food_potato)
    body:
        assert is_food_potato(food_potato)
        bind fridge_instance:item where:
            is_fridge(fridge_instance) and id[fridge_instance]==289
        achieve close_char(char,fridge_instance)
        if can_open(fridge_instance):
            achieve_once open(fridge_instance)
            exp(food_potato,fridge_instance)
        else:
            exp(food_potato,fridge_instance)
    eff:
        unknown[food_potato]=False
        close[food_potato,fridge_instance]=True
        close[fridge_instance,food_potato]=True
    

behavior find_food_carrot_2014_around_fridge_289(food_carrot:item):
    goal: not unknown(food_carrot)
    body:
        assert is_food_carrot(food_carrot)
        bind fridge_instance:item where:
            is_fridge(fridge_instance) and id[fridge_instance]==289
        achieve close_char(char,fridge_instance)
        if can_open(fridge_instance):
            achieve_once open(fridge_instance)
            exp(food_carrot,fridge_instance)
        else:
            exp(food_carrot,fridge_instance)
    eff:
        unknown[food_carrot]=False
        close[food_carrot,fridge_instance]=True
        close[fridge_instance,food_carrot]=True
    

#exp_behavior_end

#goal_representation

behavior boil_vegetables(pot:item, stove:item):
    body:
        if not is_on(stove):
            switch_on(stove) # Switch on the stove if its off

behavior ensure_pot_is_filled(pot:item, faucet:item):
    body:
        if not has_water(pot):
            walk_to(pot)
            grab(pot)
            walk_to(faucet)
            get_water(pot)
            walk_to(stove)
            put_on(pot, stove) # Ensures the pot is on the stove after filling

behavior __goal__():
    body:
        bind pot: item where:
            is_pot(pot) and id[pot] == 2069
        # Bind pot_2069

        bind stove: item where:
            is_stove(stove) and id[stove] == 2065
        # Bind stove_2065

        bind faucet: item where:
            is_faucet(faucet) and id[faucet] == 43
        # Bind faucet_43

        ensure_pot_is_filled(pot, faucet)
        boil_vegetables(pot, stove)

#goal_representation_end

##############################
Goal representation from planning.py

#exp_behavior

behavior find_food_vegetable_2041_around_fridge_289(food_vegetable:item):
    goal: not unknown(food_vegetable)
    body:
        assert is_food_vegetable(food_vegetable)
        bind fridge_instance:item where:
            is_fridge(fridge_instance) and id[fridge_instance]==289
        achieve close_char(char,fridge_instance)
        if can_open(fridge_instance):
            achieve_once open(fridge_instance)
            exp(food_vegetable,fridge_instance)
        else:
            exp(food_vegetable,fridge_instance)
    eff:
        unknown[food_vegetable]=False
        close[food_vegetable,fridge_instance]=True
        close[fridge_instance,food_vegetable]=True
    

behavior find_food_carrot_2014_around_fridge_289(food_carrot:item):
    goal: not unknown(food_carrot)
    body:
        assert is_food_carrot(food_carrot)
        bind fridge_instance:item where:
            is_fridge(fridge_instance) and id[fridge_instance]==289
        achieve close_char(char,fridge_instance)
        if can_open(fridge_instance):
            achieve_once open(fridge_instance)
            exp(food_carrot,fridge_instance)
        else:
            exp(food_carrot,fridge_instance)
    eff:
        unknown[food_carrot]=False
        close[food_carrot,fridge_instance]=True
        close[fridge_instance,food_carrot]=True
    

#exp_behavior_end

#goal_representation

def is_pot_boiling(pot:item, stove:item):
    # Function to check if the pot is on the stove and the stove is switched on
    return on(pot, stove) and is_on(stove) and has_water(pot)

behavior fill_with_water(pot:item):
    body:
        if not has_water(pot):
            get_water(pot)

behavior place_pot_on_stove(pot: item, stove: item):
    body:
        if not on(pot, stove):
            put_on(pot, stove)

behavior ensure_stove_is_on(stove:item):
    body:
        if is_off(stove):
            switch_on(stove)

behavior boil_vegetables(pot:item, stove:item):
    body:
        ensure_stove_is_on(stove)

behavior __goal__():
    body:
        bind pot: item where:
            is_pot(pot) and id[pot] == 2069
        # Select pot with ID 2069

        bind stove: item where:
            is_stove(stove) and id[stove] == 2065
        # Select stove with ID 2065

        if not is_pot_boiling(pot, stove):
            fill_with_water(pot)
            place_pot_on_stove(pot, stove)

        boil_vegetables(pot, stove)

#goal_representation_end

##############################
From agent.py->reset_sub_goal

def is_pot_boiling(pot:item, stove:item):
    # Function to check if the pot is on the stove and the stove is switched on
    return on(pot, stove) and is_on(stove) and has_water(pot)

behavior fill_with_water(pot:item):
    body:
        if not has_water(pot):
            get_water(pot)

behavior place_pot_on_stove(pot: item, stove: item):
    body:
        if not on(pot, stove):
            put_on(pot, stove)

behavior ensure_stove_is_on(stove:item):
    body:
        if is_off(stove):
            switch_on(stove)

behavior boil_vegetables(pot:item, stove:item):
    body:
        ensure_stove_is_on(stove)

behavior __goal__():
    body:
        bind pot: item where:
            is_pot(pot) and id[pot] == 2069
        # Select pot with ID 2069

        bind stove: item where:
            is_stove(stove) and id[stove] == 2065
        # Select stove with ID 2065

        if not is_pot_boiling(pot, stove):
            fill_with_water(pot)
            place_pot_on_stove(pot, stove)

        boil_vegetables(pot, stove)

##############################
From agent.py-> find a plan in act()
walk_executor(stove_2065)put_executor(pot_2069, stove_2065)
##############################
From agent.py
walk_executor(stove_2065)
Robot find: Robot is close to the pot_2069. Robot is close to the stove_2065. Robot is close to the kitchen_counter_230. 
##############################
From agent.py
put_executor(pot_2069, stove_2065)
Robot find: Robot is close to the pot_2069. Robot is close to the stove_2065. Robot is close to the kitchen_counter_230. pot_2069 is close stove_2065. pot_2069 is on stove_2065. pot_2069 released by right hand. 
##############################
From agent.py -> evaluate_current_subgoal()
The evaluation result for current subgoal: No
The feedback instruction: The pot, identified as pot_2069, should be filled with water to ensure the vegetables can boil. Make sure to fill the pot with water before placing it back on the stove.
##############################
From agent.py
Human Instruction: The pot, identified as pot_2069, should be filled with water to ensure the vegetables can boil. Make sure to fill the pot with water before placing it back on the stove.

The actions you have taken:
Action 1: Walk to stove_2065.
Action 2: Open stove_2065.
Action 3: look for pot_2069 around stove_2065.
Action 4: Walk to pot_2069.
Action 5: Open pot_2069.
Action 6: Observe around pot_2069 with the question of Identify if the pot is on the stove.
Action 7: Walk to pot_2069.
Action 8: Grab pot_2069.
Action 9: Walk to stove_2065.
Action 10: Put pot_2069 on stove_2065.
Action 11: Grab pot_2069.
Action 12: Walk to stove_2065.
Action 13: Put pot_2069 on stove_2065.
Action 14: Switch on stove_2065.
Action 15: Walk to pot_2069.
Action 16: Grab pot_2069.
Action 17: Walk to faucet_43.
Action 18: Switch on faucet_43.
Action 19: Switch off faucet_43.
Action 20: Walk to stove_2065.
Action 21: Put pot_2069 on stove_2065.

##############################
Goal representation from planning.py

#exp_behavior

behavior find_food_vegetable_2041_around_fridge_289(food_vegetable:item):
    goal: not unknown(food_vegetable)
    body:
        assert is_food_vegetable(food_vegetable)
        bind fridge_instance:item where:
            is_fridge(fridge_instance) and id[fridge_instance]==289
        achieve close_char(char,fridge_instance)
        if can_open(fridge_instance):
            achieve_once open(fridge_instance)
            exp(food_vegetable,fridge_instance)
        else:
            exp(food_vegetable,fridge_instance)
    eff:
        unknown[food_vegetable]=False
        close[food_vegetable,fridge_instance]=True
        close[fridge_instance,food_vegetable]=True
    

behavior find_food_carrot_2014_around_fridge_289(food_carrot:item):
    goal: not unknown(food_carrot)
    body:
        assert is_food_carrot(food_carrot)
        bind fridge_instance:item where:
            is_fridge(fridge_instance) and id[fridge_instance]==289
        achieve close_char(char,fridge_instance)
        if can_open(fridge_instance):
            achieve_once open(fridge_instance)
            exp(food_carrot,fridge_instance)
        else:
            exp(food_carrot,fridge_instance)
    eff:
        unknown[food_carrot]=False
        close[food_carrot,fridge_instance]=True
        close[fridge_instance,food_carrot]=True
    

#exp_behavior_end

#goal_representation
 
behavior ensure_pot_has_water(pot:item):
    body:
        if not has_water(pot):
            get_water(pot)

behavior place_pot_on_stove(pot:item, stove:item):
    body:
        if not on(pot, stove):
            put_on(pot, stove)

behavior boil_vegetables(pot:item, stove:item):
    body:
        if is_off(stove):
            switch_on(stove)
        walk_to(pot)
        grab(pot)
        walk_to(faucet_43)
        ensure_pot_has_water(pot)
        walk_to(stove)
        place_pot_on_stove(pot, stove)

behavior __goal__():
    body:
        bind pot: item where:
            is_pot(pot) and id[pot] == 2069
        # Select pot_2069

        bind stove: item where:
            is_stove(stove) and id[stove] == 2065
        # Select stove_2065

        boil_vegetables(pot, stove)

#goal_representation_end

##############################
Goal representation from planning.py

#exp_behavior

behavior find_food_vegetable_2041_around_cupboard_229(food_vegetable:item):
    goal: not unknown(food_vegetable)
    body:
        assert is_food_vegetable(food_vegetable)
        bind cupboard_instance:item where:
            is_cupboard(cupboard_instance) and id[cupboard_instance]==229
        achieve close_char(char,cupboard_instance)
        if can_open(cupboard_instance):
            achieve_once open(cupboard_instance)
            exp(food_vegetable,cupboard_instance)
        else:
            exp(food_vegetable,cupboard_instance)
    eff:
        unknown[food_vegetable]=False
        close[food_vegetable,cupboard_instance]=True
        close[cupboard_instance,food_vegetable]=True
    

behavior find_food_carrot_2014_around_fridge_289(food_carrot:item):
    goal: not unknown(food_carrot)
    body:
        assert is_food_carrot(food_carrot)
        bind fridge_instance:item where:
            is_fridge(fridge_instance) and id[fridge_instance]==289
        achieve close_char(char,fridge_instance)
        if can_open(fridge_instance):
            achieve_once open(fridge_instance)
            exp(food_carrot,fridge_instance)
        else:
            exp(food_carrot,fridge_instance)
    eff:
        unknown[food_carrot]=False
        close[food_carrot,fridge_instance]=True
        close[fridge_instance,food_carrot]=True
    

#exp_behavior_end

#goal_representation
 
behavior boil_vegetables_in_pot(pot: item, stove: item):
    body:
        if not is_on(stove):
            switch_on(stove)
            # Turn on the stove to boil vegetables
        
        if not inhand(pot) and not on(pot, stove):
            walk_to(pot)
            grab(pot)
        
        if not has_water(pot):
            walk_to(faucet_43)
            switch_on(faucet_43)
            get_water(pot)
            switch_off(faucet_43)
        
        if inhand(pot):
            walk_to(stove)
            put_on(pot, stove)

behavior __goal__():
    body:
        bind stove: item where:
            is_stove(stove) and id[stove] == 2065
        
        bind pot: item where:
            is_pot(pot) and id[pot] == 2069
        
        boil_vegetables_in_pot(pot, stove)
 
#goal_representation_end

##############################
Goal representation from planning.py

#exp_behavior

behavior find_food_vegetable_2041_around_fridge_289(food_vegetable:item):
    goal: not unknown(food_vegetable)
    body:
        assert is_food_vegetable(food_vegetable)
        bind fridge_instance:item where:
            is_fridge(fridge_instance) and id[fridge_instance]==289
        achieve close_char(char,fridge_instance)
        if can_open(fridge_instance):
            achieve_once open(fridge_instance)
            exp(food_vegetable,fridge_instance)
        else:
            exp(food_vegetable,fridge_instance)
    eff:
        unknown[food_vegetable]=False
        close[food_vegetable,fridge_instance]=True
        close[fridge_instance,food_vegetable]=True
    

#exp_behavior_end

#goal_representation
 
behavior fill_pot_with_water(pot: item, faucet: item):
    body:
        if not has_water(pot):
            walk_to(faucet)
            get_water(pot)

behavior boil_vegetables(pot: item, stove: item):
    body:
        if not on(pot, stove):
            put_on(pot, stove)
        if is_off(stove):
            switch_on(stove)

behavior __goal__():
    body:
        bind pot: item where:
            is_pot(pot) and id[pot] == 2069
        bind stove: item where:
            is_stove(stove) and id[stove] == 2065
        bind faucet: item where:
            is_faucet(faucet) and id[faucet] == 43
        
        fill_pot_with_water(pot, faucet)
        boil_vegetables(pot, stove)

#goal_representation_end

##############################
Goal representation from planning.py

#exp_behavior

behavior find_food_vegetable_2041_around_cupboard_229(food_vegetable:item):
    goal: not unknown(food_vegetable)
    body:
        assert is_food_vegetable(food_vegetable)
        bind cupboard_instance:item where:
            is_cupboard(cupboard_instance) and id[cupboard_instance]==229
        achieve close_char(char,cupboard_instance)
        if can_open(cupboard_instance):
            achieve_once open(cupboard_instance)
            exp(food_vegetable,cupboard_instance)
        else:
            exp(food_vegetable,cupboard_instance)
    eff:
        unknown[food_vegetable]=False
        close[food_vegetable,cupboard_instance]=True
        close[cupboard_instance,food_vegetable]=True
    

#exp_behavior_end

#goal_representation
 
behavior boil_vegetables_in_pot(pot:item, stove:item):
    body:
        if not has_water(pot):
            get_water(pot)
            # Ensure the pot has water for boiling

        if not on(pot, stove):
            put_on(pot, stove)
            # Put the pot on the stove for boiling

        if is_off(stove):
            switch_on(stove)
            # Turn on the stove to start boiling the vegetables

behavior __goal__():
    body:
        bind pot: item where:
            is_pot(pot) and id[pot] == 2069
        # Select pot_2069 for boiling vegetables

        bind stove: item where:
            is_stove(stove) and id[stove] == 2065
        # Select stove_2065 for boiling

        boil_vegetables_in_pot(pot, stove)

#goal_representation_end

##############################
Goal representation from planning.py

#exp_behavior

behavior find_food_vegetable_2041_around_fridge_289(food_vegetable:item):
    goal: not unknown(food_vegetable)
    body:
        assert is_food_vegetable(food_vegetable)
        bind fridge_instance:item where:
            is_fridge(fridge_instance) and id[fridge_instance]==289
        achieve close_char(char,fridge_instance)
        if can_open(fridge_instance):
            achieve_once open(fridge_instance)
            exp(food_vegetable,fridge_instance)
        else:
            exp(food_vegetable,fridge_instance)
    eff:
        unknown[food_vegetable]=False
        close[food_vegetable,fridge_instance]=True
        close[fridge_instance,food_vegetable]=True
    

behavior find_food_carrot_2014_around_fridge_289(food_carrot:item):
    goal: not unknown(food_carrot)
    body:
        assert is_food_carrot(food_carrot)
        bind fridge_instance:item where:
            is_fridge(fridge_instance) and id[fridge_instance]==289
        achieve close_char(char,fridge_instance)
        if can_open(fridge_instance):
            achieve_once open(fridge_instance)
            exp(food_carrot,fridge_instance)
        else:
            exp(food_carrot,fridge_instance)
    eff:
        unknown[food_carrot]=False
        close[food_carrot,fridge_instance]=True
        close[fridge_instance,food_carrot]=True
    

#exp_behavior_end

#goal_representation
behavior boil_vegetables(pot: item, stove: item):
    body:
        if not has_water(pot):
            walk_to(pot)
            grab(pot)
            walk_to(faucet_43)
            get_water(pot)
            # Fill the pot with water
        if not on(pot, stove):
            put_on(pot, stove)
            # Place the pot back on the stove
        if is_off(stove):
            switch_on(stove)
            # Turn on the stove to start boiling the vegetables

behavior __goal__():
    body:
        bind pot: item where:
            is_pot(pot) and id[pot] == 2069
        # Select the pot with ID 2069

        bind stove: item where:
            is_stove(stove) and id[stove] == 2065
        # Select the stove with ID 2065

        boil_vegetables(pot, stove)
        # Start the boiling process for the vegetables in the pot on the stove
#goal_representation_end

##############################
Goal representation from planning.py

#exp_behavior

behavior find_food_vegetable_2041_around_cupboard_229(food_vegetable:item):
    goal: not unknown(food_vegetable)
    body:
        assert is_food_vegetable(food_vegetable)
        bind cupboard_instance:item where:
            is_cupboard(cupboard_instance) and id[cupboard_instance]==229
        achieve close_char(char,cupboard_instance)
        if can_open(cupboard_instance):
            achieve_once open(cupboard_instance)
            exp(food_vegetable,cupboard_instance)
        else:
            exp(food_vegetable,cupboard_instance)
    eff:
        unknown[food_vegetable]=False
        close[food_vegetable,cupboard_instance]=True
        close[cupboard_instance,food_vegetable]=True
    

behavior find_food_onion_2032_around_fridge_289(food_onion:item):
    goal: not unknown(food_onion)
    body:
        assert is_food_onion(food_onion)
        bind fridge_instance:item where:
            is_fridge(fridge_instance) and id[fridge_instance]==289
        achieve close_char(char,fridge_instance)
        if can_open(fridge_instance):
            achieve_once open(fridge_instance)
            exp(food_onion,fridge_instance)
        else:
            exp(food_onion,fridge_instance)
    eff:
        unknown[food_onion]=False
        close[food_onion,fridge_instance]=True
        close[fridge_instance,food_onion]=True
    

behavior find_food_potato_2035_around_fridge_289(food_potato:item):
    goal: not unknown(food_potato)
    body:
        assert is_food_potato(food_potato)
        bind fridge_instance:item where:
            is_fridge(fridge_instance) and id[fridge_instance]==289
        achieve close_char(char,fridge_instance)
        if can_open(fridge_instance):
            achieve_once open(fridge_instance)
            exp(food_potato,fridge_instance)
        else:
            exp(food_potato,fridge_instance)
    eff:
        unknown[food_potato]=False
        close[food_potato,fridge_instance]=True
        close[fridge_instance,food_potato]=True
    

behavior find_food_carrot_2014_around_fridge_289(food_carrot:item):
    goal: not unknown(food_carrot)
    body:
        assert is_food_carrot(food_carrot)
        bind fridge_instance:item where:
            is_fridge(fridge_instance) and id[fridge_instance]==289
        achieve close_char(char,fridge_instance)
        if can_open(fridge_instance):
            achieve_once open(fridge_instance)
            exp(food_carrot,fridge_instance)
        else:
            exp(food_carrot,fridge_instance)
    eff:
        unknown[food_carrot]=False
        close[food_carrot,fridge_instance]=True
        close[fridge_instance,food_carrot]=True
    

#exp_behavior_end

#goal_representation
 
def is_vegetables_boiled_adequately(pot:item):
    # Check if the pot has water and is on the stove
    return has_water(pot) and on(pot, stove)

def is_pot_on_stove_with_water(stove: item, pot: item):
    # Function to check if there is a pot with water on the stove
    return exists pot: item : (is_pot(pot) and has_water(pot) and on(pot, stove))

behavior fill_pot_with_water(pot: item, faucet: item):
    body:
        if not has_water(pot):
            walk_to(faucet)
            walk_to(pot)
            if not inhand(pot):
                grab(pot)
            get_water(pot)

behavior place_pot_on_stove(pot: item, stove: item):
    body:
        if not on(pot, stove):
            put_on(pot, stove)

behavior __goal__():
    body:
        bind stove: item where:
            is_stove(stove) and id[stove] == 2065
        
        bind faucet: item where:
            is_faucet(faucet) and id[faucet] == 43
        
        bind pot: item where:
            is_pot(pot) and id[pot] == 2069

        # Fill the pot with water if it doesnt have any 
        fill_pot_with_water(pot, faucet)

        # Ensure the pot is on the stove
        place_pot_on_stove(pot, stove)

        # Boil the water if the stove is currently off
        if not is_vegetables_boiled_adequately(pot):
            if is_off(stove):
                switch_on(stove)

#goal_representation_end

##############################
VH_pipeline: Fail to generate a valid plan
##############################
From agent.py -> query_LLM_human
Record from func query_LLM_human in agent.py
Question: Can you teach me how to "2. boil the vegetables in the identified pot." ?
Answer: Clean the vegetables first. Fill a pot with water. Put the pot on the stove. Turn on the stove. Put vegetables in the pot.
Re-decompose: True

##############################
From agent.py
Reset goals: The sub-goals are: 
['1. Clean the vegetables.', '2. Fill the identified pot with water and put it on the stove.', '3. Turn on the stove.', '4. Put the vegetables in the pot.']
##############################
Goal representation from planning.py

#exp_behavior

behavior find_food_vegetable_2041_around_fridge_289(food_vegetable:item):
    goal: not unknown(food_vegetable)
    body:
        assert is_food_vegetable(food_vegetable)
        bind fridge_instance:item where:
            is_fridge(fridge_instance) and id[fridge_instance]==289
        achieve close_char(char,fridge_instance)
        if can_open(fridge_instance):
            achieve_once open(fridge_instance)
            exp(food_vegetable,fridge_instance)
        else:
            exp(food_vegetable,fridge_instance)
    eff:
        unknown[food_vegetable]=False
        close[food_vegetable,fridge_instance]=True
        close[fridge_instance,food_vegetable]=True
    

behavior find_food_onion_2032_around_fridge_289(food_onion:item):
    goal: not unknown(food_onion)
    body:
        assert is_food_onion(food_onion)
        bind fridge_instance:item where:
            is_fridge(fridge_instance) and id[fridge_instance]==289
        achieve close_char(char,fridge_instance)
        if can_open(fridge_instance):
            achieve_once open(fridge_instance)
            exp(food_onion,fridge_instance)
        else:
            exp(food_onion,fridge_instance)
    eff:
        unknown[food_onion]=False
        close[food_onion,fridge_instance]=True
        close[fridge_instance,food_onion]=True
    

behavior find_food_potato_2035_around_fridge_289(food_potato:item):
    goal: not unknown(food_potato)
    body:
        assert is_food_potato(food_potato)
        bind fridge_instance:item where:
            is_fridge(fridge_instance) and id[fridge_instance]==289
        achieve close_char(char,fridge_instance)
        if can_open(fridge_instance):
            achieve_once open(fridge_instance)
            exp(food_potato,fridge_instance)
        else:
            exp(food_potato,fridge_instance)
    eff:
        unknown[food_potato]=False
        close[food_potato,fridge_instance]=True
        close[fridge_instance,food_potato]=True
    

behavior find_food_carrot_2014_around_fridge_289(food_carrot:item):
    goal: not unknown(food_carrot)
    body:
        assert is_food_carrot(food_carrot)
        bind fridge_instance:item where:
            is_fridge(fridge_instance) and id[fridge_instance]==289
        achieve close_char(char,fridge_instance)
        if can_open(fridge_instance):
            achieve_once open(fridge_instance)
            exp(food_carrot,fridge_instance)
        else:
            exp(food_carrot,fridge_instance)
    eff:
        unknown[food_carrot]=False
        close[food_carrot,fridge_instance]=True
        close[fridge_instance,food_carrot]=True
    

#exp_behavior_end

#goal_representation
 
def are_vegetables_clean(vegetable: item):
    # Function to determine if a vegetable is clean
    return clean(vegetable)

behavior clean_vegetables(vegetable: item):
    body:
        if dirty(vegetable):
            wash(vegetable)
            # Wash the vegetable to ensure it is clean

behavior __goal__():
    body:
        foreach vegetable: item:
            if is_food_vegetable(vegetable) and not are_vegetables_clean(vegetable):
                walk_to(vegetable)
                # Move close to the vegetable that needs cleaning
                clean_vegetables(vegetable)
                # Clean the vegetable if it is dirty

#goal_representation_end

##############################
From agent.py->reset_sub_goal
 
def are_vegetables_clean(vegetable: item):
    # Function to determine if a vegetable is clean
    return clean(vegetable)

behavior clean_vegetables(vegetable: item):
    body:
        if dirty(vegetable):
            wash(vegetable)
            # Wash the vegetable to ensure it is clean

behavior __goal__():
    body:
        foreach vegetable: item:
            if is_food_vegetable(vegetable) and not are_vegetables_clean(vegetable):
                walk_to(vegetable)
                # Move close to the vegetable that needs cleaning
                clean_vegetables(vegetable)
                # Clean the vegetable if it is dirty

##############################
From agent.py-> find a plan in act()
walk_executor(fridge_289)switchoff_executor(fridge_289)open_executor(fridge_289)exp(food_vegetable_2041, fridge_289)walk_executor(food_vegetable_2041)
##############################
From agent.py
walk_executor(fridge_289)
Robot find: Robot is close to the fridge_289. 
##############################
From agent.py
switchoff_executor(fridge_289)
Robot find: Robot is close to the fridge_289. fridge_289 is turned off. 
##############################
From agent.py
open_executor(fridge_289)
Robot find: sauce_2078, food_steak_2008, food_apple_2009, food_bacon_2010, food_banana_2011, food_bread_2012, food_cake_2013, food_carrot_2014, food_cereal_2015, food_cheese_2016, food_chicken_2017, food_dessert_2018, food_donut_2019, food_egg_2020, food_fish_2021, food_food_2022, food_fruit_2023, food_hamburger_2024, food_ice_cream_2025, food_jam_2026, food_kiwi_2027, food_lemon_2028, food_noodles_2029, food_oatmeal_2030, food_orange_2031, food_onion_2032, food_peanut_butter_2033, food_pizza_2034, food_potato_2035, food_rice_2036, food_salt_2037, food_snack_2038, food_sugar_2039, food_turkey_2040, food_vegetable_2041, dry_pasta_2042, milk_2043, Robot is close to the sauce_2078. Robot is close to the fridge_289. Robot is close to the food_steak_2008. Robot is close to the food_apple_2009. Robot is close to the food_bacon_2010. Robot is close to the food_banana_2011. Robot is close to the food_bread_2012. Robot is close to the food_cake_2013. Robot is close to the food_carrot_2014. Robot is close to the food_cereal_2015. Robot is close to the food_cheese_2016. Robot is close to the food_chicken_2017. Robot is close to the food_dessert_2018. Robot is close to the food_donut_2019. Robot is close to the food_egg_2020. Robot is close to the food_fish_2021. Robot is close to the food_food_2022. Robot is close to the food_fruit_2023. Robot is close to the food_hamburger_2024. Robot is close to the food_ice_cream_2025. Robot is close to the food_jam_2026. Robot is close to the food_kiwi_2027. Robot is close to the food_lemon_2028. Robot is close to the food_noodles_2029. Robot is close to the food_oatmeal_2030. Robot is close to the food_orange_2031. Robot is close to the food_onion_2032. Robot is close to the food_peanut_butter_2033. Robot is close to the food_pizza_2034. Robot is close to the food_potato_2035. Robot is close to the food_rice_2036. Robot is close to the food_salt_2037. Robot is close to the food_snack_2038. Robot is close to the food_sugar_2039. Robot is close to the food_turkey_2040. Robot is close to the food_vegetable_2041. Robot is close to the dry_pasta_2042. Robot is close to the milk_2043. fridge_289 is opened. 
##############################
From agent.py
exp(food_vegetable_2041, fridge_289)
Find food_vegetable_2041. 
##############################
From agent.py-> find a plan in act()
walk_executor(food_vegetable_2041)grab_executor(food_vegetable_2041)walk_executor(faucet_43)switchon_executor(faucet_43)wash_executor(food_vegetable_2041)switchoff_executor(faucet_43)
##############################
From agent.py
walk_executor(food_vegetable_2041)
Robot find: Robot is close to the fridge_289. Robot is close to the food_vegetable_2041. 
##############################
From agent.py
grab_executor(food_vegetable_2041)
Robot find: Robot is close to the fridge_289. Robot is close to the food_vegetable_2041. Grabbing food_vegetable_2041 by right hand. 
##############################
From agent.py
walk_executor(faucet_43)
Robot find: Robot is close to the food_vegetable_2041. Robot is close to the bathroom_counter_41. Robot is close to the faucet_43. 
##############################
From agent.py
switchon_executor(faucet_43)
Robot find: Robot is close to the food_vegetable_2041. Robot is close to the bathroom_counter_41. Robot is close to the faucet_43. faucet_43 is turned on. 
##############################
From agent.py
wash_executor(food_vegetable_2041)
Robot find: Robot is close to the food_vegetable_2041. Robot is close to the bathroom_counter_41. Robot is close to the faucet_43. food_vegetable_2041 is cleaned. 
##############################
From agent.py
switchoff_executor(faucet_43)
Robot find: Robot is close to the food_vegetable_2041. Robot is close to the bathroom_counter_41. Robot is close to the faucet_43. faucet_43 is turned off. 
##############################
From agent.py -> evaluate_current_subgoal()
The evaluation result for current subgoal: Yes
The feedback instruction: None
##############################
Goal representation from planning.py

#exp_behavior

behavior find_wall_clock_249_around_doorjamb_346(wall_clock:item):
    goal: not unknown(wall_clock)
    body:
        assert is_wall_clock(wall_clock)
        bind doorjamb_instance:item where:
            is_doorjamb(doorjamb_instance) and id[doorjamb_instance]==346
        achieve close_char(char,doorjamb_instance)
        if can_open(doorjamb_instance):
            achieve_once open(doorjamb_instance)
            exp(wall_clock,doorjamb_instance)
        else:
            exp(wall_clock,doorjamb_instance)
    eff:
        unknown[wall_clock]=False
        close[wall_clock,doorjamb_instance]=True
        close[doorjamb_instance,wall_clock]=True
    

behavior find_mouse_413_around_mousepad_414(mouse:item):
    goal: not unknown(mouse)
    body:
        assert is_mouse(mouse)
        bind mousepad_instance:item where:
            is_mousepad(mousepad_instance) and id[mousepad_instance]==414
        achieve close_char(char,mousepad_instance)
        if can_open(mousepad_instance):
            achieve_once open(mousepad_instance)
            exp(mouse,mousepad_instance)
        else:
            exp(mouse,mousepad_instance)
    eff:
        unknown[mouse]=False
        close[mouse,mousepad_instance]=True
        close[mousepad_instance,mouse]=True
    

#exp_behavior_end

#goal_representation
 
def is_pot_full_of_water(pot: item):
    # Function to check if the pot is filled with water
    return has_water(pot)

def is_stove_with_pot_on_it(stove: item, pot: item):
    # Function to check if a specified pot is on the stove
    return on(pot, stove)

behavior fill_pot_with_water_and_put_on_stove(pot: item, stove: item):
    body:
        if not inhand(pot):
            grab(pot)
            # Ensure the pot is in hand to be filled with water
        if not is_pot_full_of_water(pot):
            get_water(pot)
            # Fill the pot with water if it is not already full
        if not is_stove_with_pot_on_it(stove, pot):
            walk_to(stove)
            put_on(pot, stove)
            # Put the pot on the stove

behavior __goal__():
    body:
        bind pot: item where:
            is_pot(pot) and id[pot] == 2069
        # Select pot_2069

        bind stove: item where:
            is_stove(stove) and id[stove] == 2065
        # Select stove_2065

        fill_pot_with_water_and_put_on_stove(pot, stove)

#goal_representation_end

##############################
From agent.py->reset_sub_goal
 
def is_pot_full_of_water(pot: item):
    # Function to check if the pot is filled with water
    return has_water(pot)

def is_stove_with_pot_on_it(stove: item, pot: item):
    # Function to check if a specified pot is on the stove
    return on(pot, stove)

behavior fill_pot_with_water_and_put_on_stove(pot: item, stove: item):
    body:
        if not inhand(pot):
            grab(pot)
            # Ensure the pot is in hand to be filled with water
        if not is_pot_full_of_water(pot):
            get_water(pot)
            # Fill the pot with water if it is not already full
        if not is_stove_with_pot_on_it(stove, pot):
            walk_to(stove)
            put_on(pot, stove)
            # Put the pot on the stove

behavior __goal__():
    body:
        bind pot: item where:
            is_pot(pot) and id[pot] == 2069
        # Select pot_2069

        bind stove: item where:
            is_stove(stove) and id[stove] == 2065
        # Select stove_2065

        fill_pot_with_water_and_put_on_stove(pot, stove)

##############################
From agent.py-> find a plan in act()
walk_executor(pot_2069)grab_executor(pot_2069)walk_executor(stove_2065)put_executor(pot_2069, stove_2065)
##############################
From agent.py
walk_executor(pot_2069)
Robot find: Robot is close to the food_vegetable_2041. Robot is close to the stove_2065. Robot is close to the pot_2069. 
##############################
From agent.py
grab_executor(pot_2069)
Robot find: Robot is close to the food_vegetable_2041. Robot is close to the stove_2065. Robot is close to the pot_2069. Grabbing pot_2069 by left hand. 
##############################
From agent.py
walk_executor(stove_2065)
Robot find: Robot is close to the food_vegetable_2041. Robot is close to the stove_2065. Robot is close to the pot_2069. Robot is close to the kitchen_counter_230. 
##############################
From agent.py
put_executor(pot_2069, stove_2065)
Robot find: Robot is close to the food_vegetable_2041. Robot is close to the stove_2065. Robot is close to the pot_2069. Robot is close to the kitchen_counter_230. pot_2069 is close stove_2065. pot_2069 is on stove_2065. pot_2069 released by left hand. 
##############################
From agent.py -> evaluate_current_subgoal()
The evaluation result for current subgoal: No
The feedback instruction: The pot_2069 needs to be filled with water. Ensure the pot is actually filled at the faucet before placing it on the stove.
##############################
From agent.py
Human Instruction: The pot_2069 needs to be filled with water. Ensure the pot is actually filled at the faucet before placing it on the stove.

The actions you have taken:
Action 1: Walk to stove_2065.
Action 2: Open stove_2065.
Action 3: look for pot_2069 around stove_2065.
Action 4: Walk to pot_2069.
Action 5: Open pot_2069.
Action 6: Observe around pot_2069 with the question of Identify if the pot is on the stove.
Action 7: Walk to pot_2069.
Action 8: Grab pot_2069.
Action 9: Walk to stove_2065.
Action 10: Put pot_2069 on stove_2065.
Action 11: Grab pot_2069.
Action 12: Walk to stove_2065.
Action 13: Put pot_2069 on stove_2065.
Action 14: Switch on stove_2065.
Action 15: Walk to pot_2069.
Action 16: Grab pot_2069.
Action 17: Walk to faucet_43.
Action 18: Switch on faucet_43.
Action 19: Switch off faucet_43.
Action 20: Walk to stove_2065.
Action 21: Put pot_2069 on stove_2065.
Action 22: Walk to fridge_289.
Action 23: Switch off fridge_289.
Action 24: Open fridge_289.
Action 25: look for food_vegetable_2041 around fridge_289.
Action 26: Walk to food_vegetable_2041.
Action 27: Grab food_vegetable_2041.
Action 28: Walk to faucet_43.
Action 29: Switch on faucet_43.
Action 30: Wash food_vegetable_2041.
Action 31: Switch off faucet_43.
Action 32: Walk to pot_2069.
Action 33: Grab pot_2069.
Action 34: Walk to stove_2065.
Action 35: Put pot_2069 on stove_2065.

##############################
Goal representation from planning.py

#exp_behavior

behavior find_wall_clock_249_around_ceilinglamp_223(wall_clock:item):
    goal: not unknown(wall_clock)
    body:
        assert is_wall_clock(wall_clock)
        bind ceilinglamp_instance:item where:
            is_ceilinglamp(ceilinglamp_instance) and id[ceilinglamp_instance]==223
        achieve close_char(char,ceilinglamp_instance)
        if can_open(ceilinglamp_instance):
            achieve_once open(ceilinglamp_instance)
            exp(wall_clock,ceilinglamp_instance)
        else:
            exp(wall_clock,ceilinglamp_instance)
    eff:
        unknown[wall_clock]=False
        close[wall_clock,ceilinglamp_instance]=True
        close[ceilinglamp_instance,wall_clock]=True
    

behavior find_soap_2053_around_bathroom_cabinet_40(soap:item):
    goal: not unknown(soap)
    body:
        assert is_soap(soap)
        bind bathroom_cabinet_instance:item where:
            is_bathroom_cabinet(bathroom_cabinet_instance) and id[bathroom_cabinet_instance]==40
        achieve close_char(char,bathroom_cabinet_instance)
        if can_open(bathroom_cabinet_instance):
            achieve_once open(bathroom_cabinet_instance)
            exp(soap,bathroom_cabinet_instance)
        else:
            exp(soap,bathroom_cabinet_instance)
    eff:
        unknown[soap]=False
        close[soap,bathroom_cabinet_instance]=True
        close[bathroom_cabinet_instance,soap]=True
    

#exp_behavior_end

#goal_representation
 
def has_filled_pot(pot: item):
    # Check if the pot has been filled with water
    return has_water(pot)

behavior fill_pot_and_place_on_stove(pot: item, stove: item):
    body:
        if not has_water(pot):
            get_water(pot) # Fill the pot with water
        if not on(pot, stove):
            put_on(pot, stove) # Place the pot on the stove

behavior __goal__():
    body:
        bind pot: item where:
            is_pot(pot) and id[pot] == 2069
        # Select pot_2069
        
        bind stove: item where:
            is_stove(stove) and id[stove] == 2065
        # Select stove_2065

        fill_pot_and_place_on_stove(pot, stove)

#goal_representation_end

##############################
Goal representation from planning.py

#exp_behavior

behavior find_wall_clock_249_around_doorjamb_346(wall_clock:item):
    goal: not unknown(wall_clock)
    body:
        assert is_wall_clock(wall_clock)
        bind doorjamb_instance:item where:
            is_doorjamb(doorjamb_instance) and id[doorjamb_instance]==346
        achieve close_char(char,doorjamb_instance)
        if can_open(doorjamb_instance):
            achieve_once open(doorjamb_instance)
            exp(wall_clock,doorjamb_instance)
        else:
            exp(wall_clock,doorjamb_instance)
    eff:
        unknown[wall_clock]=False
        close[wall_clock,doorjamb_instance]=True
        close[doorjamb_instance,wall_clock]=True
    

#exp_behavior_end

#goal_representation
behavior fill_pot_with_water(pot:item, faucet:item):
    body:
        if not has_water(pot):
            walk_to(faucet)
            get_water(pot)

behavior place_pot_on_stove(pot:item, stove:item):
    body:
        walk_to(stove)
        if not on(pot, stove):
            put_on(pot, stove)

behavior __goal__():
    body:
        bind pot: item where:
            is_pot(pot) and id[pot] == 2069
        # Select pot_2069

        bind stove: item where:
            is_stove(stove) and id[stove] == 2065
        # Select stove_2065

        bind faucet: item where:
            is_faucet(faucet) and id[faucet] == 43
        # Select faucet_43

        walk_to(pot)
        grab(pot)
        fill_pot_with_water(pot, faucet)
        place_pot_on_stove(pot, stove)
#goal_representation_end

##############################
From agent.py->reset_sub_goal
behavior fill_pot_with_water(pot:item, faucet:item):
    body:
        if not has_water(pot):
            walk_to(faucet)
            get_water(pot)

behavior place_pot_on_stove(pot:item, stove:item):
    body:
        walk_to(stove)
        if not on(pot, stove):
            put_on(pot, stove)

behavior __goal__():
    body:
        bind pot: item where:
            is_pot(pot) and id[pot] == 2069
        # Select pot_2069

        bind stove: item where:
            is_stove(stove) and id[stove] == 2065
        # Select stove_2065

        bind faucet: item where:
            is_faucet(faucet) and id[faucet] == 43
        # Select faucet_43

        walk_to(pot)
        grab(pot)
        fill_pot_with_water(pot, faucet)
        place_pot_on_stove(pot, stove)
##############################
From agent.py-> find a plan in act()
walk_executor(pot_2069)grab_executor(pot_2069)walk_executor(stove_2065)put_executor(pot_2069, stove_2065)
##############################
From agent.py
walk_executor(pot_2069)
Robot find: Robot is close to the food_vegetable_2041. Robot is close to the stove_2065. Robot is close to the pot_2069. 
##############################
From agent.py
grab_executor(pot_2069)
Robot find: Robot is close to the food_vegetable_2041. Robot is close to the stove_2065. Robot is close to the pot_2069. Grabbing pot_2069 by left hand. 
##############################
From agent.py
walk_executor(stove_2065)
Robot find: Robot is close to the food_vegetable_2041. Robot is close to the stove_2065. Robot is close to the pot_2069. Robot is close to the kitchen_counter_230. 
##############################
From agent.py
put_executor(pot_2069, stove_2065)
Robot find: Robot is close to the food_vegetable_2041. Robot is close to the stove_2065. Robot is close to the pot_2069. Robot is close to the kitchen_counter_230. pot_2069 is close stove_2065. pot_2069 is on stove_2065. pot_2069 released by left hand. 
##############################
From agent.py -> evaluate_current_subgoal()
The evaluation result for current subgoal: No
The feedback instruction: The robot needs to ensure that the pot_2069 is filled with water. Though the actions include turning on and off faucet_43, there is no explicit action to indicate that water was filled into the pot. You need to confirm that pot_2069 receives water before placing it back on stove_2065.
##############################
From agent.py
Human Instruction: The robot needs to ensure that the pot_2069 is filled with water. Though the actions include turning on and off faucet_43, there is no explicit action to indicate that water was filled into the pot. You need to confirm that pot_2069 receives water before placing it back on stove_2065.

The actions you have taken:
Action 1: Walk to stove_2065.
Action 2: Open stove_2065.
Action 3: look for pot_2069 around stove_2065.
Action 4: Walk to pot_2069.
Action 5: Open pot_2069.
Action 6: Observe around pot_2069 with the question of Identify if the pot is on the stove.
Action 7: Walk to pot_2069.
Action 8: Grab pot_2069.
Action 9: Walk to stove_2065.
Action 10: Put pot_2069 on stove_2065.
Action 11: Grab pot_2069.
Action 12: Walk to stove_2065.
Action 13: Put pot_2069 on stove_2065.
Action 14: Switch on stove_2065.
Action 15: Walk to pot_2069.
Action 16: Grab pot_2069.
Action 17: Walk to faucet_43.
Action 18: Switch on faucet_43.
Action 19: Switch off faucet_43.
Action 20: Walk to stove_2065.
Action 21: Put pot_2069 on stove_2065.
Action 22: Walk to fridge_289.
Action 23: Switch off fridge_289.
Action 24: Open fridge_289.
Action 25: look for food_vegetable_2041 around fridge_289.
Action 26: Walk to food_vegetable_2041.
Action 27: Grab food_vegetable_2041.
Action 28: Walk to faucet_43.
Action 29: Switch on faucet_43.
Action 30: Wash food_vegetable_2041.
Action 31: Switch off faucet_43.
Action 32: Walk to pot_2069.
Action 33: Grab pot_2069.
Action 34: Walk to stove_2065.
Action 35: Put pot_2069 on stove_2065.
Action 36: Walk to pot_2069.
Action 37: Grab pot_2069.
Action 38: Walk to stove_2065.
Action 39: Put pot_2069 on stove_2065.

##############################
Goal representation from planning.py

#exp_behavior

behavior find_wall_clock_249_around_doorjamb_346(wall_clock:item):
    goal: not unknown(wall_clock)
    body:
        assert is_wall_clock(wall_clock)
        bind doorjamb_instance:item where:
            is_doorjamb(doorjamb_instance) and id[doorjamb_instance]==346
        achieve close_char(char,doorjamb_instance)
        if can_open(doorjamb_instance):
            achieve_once open(doorjamb_instance)
            exp(wall_clock,doorjamb_instance)
        else:
            exp(wall_clock,doorjamb_instance)
    eff:
        unknown[wall_clock]=False
        close[wall_clock,doorjamb_instance]=True
        close[doorjamb_instance,wall_clock]=True
    

behavior find_mouse_413_around_mousepad_167(mouse:item):
    goal: not unknown(mouse)
    body:
        assert is_mouse(mouse)
        bind mousepad_instance:item where:
            is_mousepad(mousepad_instance) and id[mousepad_instance]==167
        achieve close_char(char,mousepad_instance)
        if can_open(mousepad_instance):
            achieve_once open(mousepad_instance)
            exp(mouse,mousepad_instance)
        else:
            exp(mouse,mousepad_instance)
    eff:
        unknown[mouse]=False
        close[mouse,mousepad_instance]=True
        close[mousepad_instance,mouse]=True
    

#exp_behavior_end

#goal_representation
 
def is_pot_filled_with_water(pot: item):
    # Function to check if the pot is filled with water
    return has_water(pot)

behavior fill_pot_with_water(pot: item):
    body:
        if not has_water(pot):
            walk_to(pot)
            grab(pot)
            bind faucet: item where:
                is_faucet(faucet)
            walk_to(faucet)
            switch_on(faucet)
            get_water(pot)
            switch_off(faucet)

behavior place_pot_on_stove(pot: item, stove: item):
    body:
        walk_to(stove)
        put_on(pot, stove)

behavior __goal__():
    body:
        bind pot: item where:
            is_pot(pot) and id[pot] == 2069
        # Bind to the specific pot with ID 2069

        bind stove: item where:
            is_stove(stove) and id[stove] == 2065
        # Bind to the specific stove with ID 2065

        if not is_pot_filled_with_water(pot):
            fill_pot_with_water(pot)

        place_pot_on_stove(pot, stove)

#goal_representation_end

##############################
From agent.py->reset_sub_goal
 
def is_pot_filled_with_water(pot: item):
    # Function to check if the pot is filled with water
    return has_water(pot)

behavior fill_pot_with_water(pot: item):
    body:
        if not has_water(pot):
            walk_to(pot)
            grab(pot)
            bind faucet: item where:
                is_faucet(faucet)
            walk_to(faucet)
            switch_on(faucet)
            get_water(pot)
            switch_off(faucet)

behavior place_pot_on_stove(pot: item, stove: item):
    body:
        walk_to(stove)
        put_on(pot, stove)

behavior __goal__():
    body:
        bind pot: item where:
            is_pot(pot) and id[pot] == 2069
        # Bind to the specific pot with ID 2069

        bind stove: item where:
            is_stove(stove) and id[stove] == 2065
        # Bind to the specific stove with ID 2065

        if not is_pot_filled_with_water(pot):
            fill_pot_with_water(pot)

        place_pot_on_stove(pot, stove)

##############################
From agent.py-> find a plan in act()
walk_executor(stove_2065)grab_executor(pot_2069)put_executor(pot_2069, stove_2065)
##############################
From agent.py
walk_executor(stove_2065)
Robot find: Robot is close to the food_vegetable_2041. Robot is close to the stove_2065. Robot is close to the kitchen_counter_230. 
##############################
From agent.py
grab_executor(pot_2069)
Robot find: Robot is close to the food_vegetable_2041. Robot is close to the stove_2065. Robot is close to the kitchen_counter_230. Robot is close to the pot_2069. Grabbing pot_2069 by left hand. 
##############################
From agent.py
put_executor(pot_2069, stove_2065)
Robot find: Robot is close to the food_vegetable_2041. Robot is close to the stove_2065. Robot is close to the kitchen_counter_230. Robot is close to the pot_2069. pot_2069 is close stove_2065. pot_2069 is on stove_2065. pot_2069 released by left hand. 
##############################
From agent.py -> evaluate_current_subgoal()
The evaluation result for current subgoal: No
The feedback instruction: You need to ensure the pot is filled with water. Currently, the actions show that the faucet was turned on and off, but there is no explicit action indicating water was filled into the pot before placing it on the stove. Please perform the necessary actions to fill the pot with water.
##############################
Goal representation from planning.py

#exp_behavior

behavior find_wall_clock_249_around_closetdrawer_143(wall_clock:item):
    goal: not unknown(wall_clock)
    body:
        assert is_wall_clock(wall_clock)
        bind closetdrawer_instance:item where:
            is_closetdrawer(closetdrawer_instance) and id[closetdrawer_instance]==143
        achieve close_char(char,closetdrawer_instance)
        if can_open(closetdrawer_instance):
            achieve_once open(closetdrawer_instance)
            exp(wall_clock,closetdrawer_instance)
        else:
            exp(wall_clock,closetdrawer_instance)
    eff:
        unknown[wall_clock]=False
        close[wall_clock,closetdrawer_instance]=True
        close[closetdrawer_instance,wall_clock]=True
    

behavior find_soap_2053_around_bathroom_cabinet_40(soap:item):
    goal: not unknown(soap)
    body:
        assert is_soap(soap)
        bind bathroom_cabinet_instance:item where:
            is_bathroom_cabinet(bathroom_cabinet_instance) and id[bathroom_cabinet_instance]==40
        achieve close_char(char,bathroom_cabinet_instance)
        if can_open(bathroom_cabinet_instance):
            achieve_once open(bathroom_cabinet_instance)
            exp(soap,bathroom_cabinet_instance)
        else:
            exp(soap,bathroom_cabinet_instance)
    eff:
        unknown[soap]=False
        close[soap,bathroom_cabinet_instance]=True
        close[bathroom_cabinet_instance,soap]=True
    

behavior find_mouse_413_around_mousepad_167(mouse:item):
    goal: not unknown(mouse)
    body:
        assert is_mouse(mouse)
        bind mousepad_instance:item where:
            is_mousepad(mousepad_instance) and id[mousepad_instance]==167
        achieve close_char(char,mousepad_instance)
        if can_open(mousepad_instance):
            achieve_once open(mousepad_instance)
            exp(mouse,mousepad_instance)
        else:
            exp(mouse,mousepad_instance)
    eff:
        unknown[mouse]=False
        close[mouse,mousepad_instance]=True
        close[mousepad_instance,mouse]=True
    

#exp_behavior_end

#goal_representation
 
def is_pot_with_water_on_stove(pot: item, stove: item):
    # Check if the pot is filled with water and is already on the stove
    return has_water(pot) and on(pot, stove)

behavior place_pot_on_stove(pot: item, stove: item):
    body:
        if not on(pot, stove):
            if not inhand(pot):
                grab(pot)
            put_on(pot, stove)

behavior ensure_pot_has_water(pot: item, faucet: item):
    body:
        if not has_water(pot):
            walk_to(faucet)
            switch_on(faucet)
            get_water(pot)
            switch_off(faucet)

behavior turn_on_stove(stove: item):
    body:
        if is_off(stove) and has_switch(stove):
            switch_on(stove)

behavior __goal__():
    body:
        bind pot: item where:
            is_pot(pot) and id[pot] == 2069
        # Bind to pot_2069

        bind stove: item where:
            is_stove(stove) and id[stove] == 2065
        # Bind to stove_2065

        if not is_pot_with_water_on_stove(pot, stove):
            bind faucet: item where:
                is_faucet(faucet)
            # Bind a faucet to fill the pot with water

            ensure_pot_has_water(pot, faucet)
            walk_to(stove)
            place_pot_on_stove(pot, stove)

        turn_on_stove(stove)

#goal_representation_end

##############################
Goal representation from planning.py

#exp_behavior

behavior find_bowl_2072_around_table_226(bowl:item):
    goal: not unknown(bowl)
    body:
        assert is_bowl(bowl)
        bind table_instance:item where:
            is_table(table_instance) and id[table_instance]==226
        achieve close_char(char,table_instance)
        if can_open(table_instance):
            achieve_once open(table_instance)
            exp(bowl,table_instance)
        else:
            exp(bowl,table_instance)
    eff:
        unknown[bowl]=False
        close[bowl,table_instance]=True
        close[table_instance,bowl]=True
    

behavior find_plate_1000_around_dishwasher_1001(plate:item):
    goal: not unknown(plate)
    body:
        assert is_plate(plate)
        bind dishwasher_instance:item where:
            is_dishwasher(dishwasher_instance) and id[dishwasher_instance]==1001
        achieve close_char(char,dishwasher_instance)
        if can_open(dishwasher_instance):
            achieve_once open(dishwasher_instance)
            exp(plate,dishwasher_instance)
        else:
            exp(plate,dishwasher_instance)
    eff:
        unknown[plate]=False
        close[plate,dishwasher_instance]=True
        close[dishwasher_instance,plate]=True
    

#exp_behavior_end

#goal_representation
 
behavior __goal__():
    body:
        bind stove: item where:
            is_stove(stove) and id[stove]==2065
        # Select stove_2065
        
        walk_to(stove)
        # Move to the stove
        
        if is_off(stove):
            switch_on(stove)
            # Turn on the stove if it is off

#goal_representation_end

##############################
From agent.py->reset_sub_goal
 
behavior __goal__():
    body:
        bind stove: item where:
            is_stove(stove) and id[stove]==2065
        # Select stove_2065
        
        walk_to(stove)
        # Move to the stove
        
        if is_off(stove):
            switch_on(stove)
            # Turn on the stove if it is off

##############################
From agent.py-> find a plan in act()
walk_executor(stove_2065)
##############################
From agent.py
walk_executor(stove_2065)
Robot find: Robot is close to the food_vegetable_2041. Robot is close to the stove_2065. Robot is close to the kitchen_counter_230. 
##############################
From agent.py -> evaluate_current_subgoal()
The evaluation result for current subgoal: Yes
The feedback instruction: None
##############################
Goal representation from planning.py

#exp_behavior

behavior find_iron_2089_around_ironing_board_2074(iron:item):
    goal: not unknown(iron)
    body:
        assert is_iron(iron)
        bind ironing_board_instance:item where:
            is_ironing_board(ironing_board_instance) and id[ironing_board_instance]==2074
        achieve close_char(char,ironing_board_instance)
        if can_open(ironing_board_instance):
            achieve_once open(ironing_board_instance)
            exp(iron,ironing_board_instance)
        else:
            exp(iron,ironing_board_instance)
    eff:
        unknown[iron]=False
        close[iron,ironing_board_instance]=True
        close[ironing_board_instance,iron]=True
    

behavior find_soap_2054_around_bathroom_cabinet_40(soap:item):
    goal: not unknown(soap)
    body:
        assert is_soap(soap)
        bind bathroom_cabinet_instance:item where:
            is_bathroom_cabinet(bathroom_cabinet_instance) and id[bathroom_cabinet_instance]==40
        achieve close_char(char,bathroom_cabinet_instance)
        if can_open(bathroom_cabinet_instance):
            achieve_once open(bathroom_cabinet_instance)
            exp(soap,bathroom_cabinet_instance)
        else:
            exp(soap,bathroom_cabinet_instance)
    eff:
        unknown[soap]=False
        close[soap,bathroom_cabinet_instance]=True
        close[bathroom_cabinet_instance,soap]=True
    

behavior find_mouse_166_around_mousepad_167(mouse:item):
    goal: not unknown(mouse)
    body:
        assert is_mouse(mouse)
        bind mousepad_instance:item where:
            is_mousepad(mousepad_instance) and id[mousepad_instance]==167
        achieve close_char(char,mousepad_instance)
        if can_open(mousepad_instance):
            achieve_once open(mousepad_instance)
            exp(mouse,mousepad_instance)
        else:
            exp(mouse,mousepad_instance)
    eff:
        unknown[mouse]=False
        close[mouse,mousepad_instance]=True
        close[mousepad_instance,mouse]=True
    

#exp_behavior_end

#goal_representation
 
behavior put_vegetables_in_pot(vegetables: item, pot: item):
    body:
        if not inhand(vegetables):
            grab(vegetables)
        if not on(vegetables, pot):
            put_inside(vegetables, pot)

behavior __goal__():
    body:
        bind vegetables: item where:
            is_food_vegetable(vegetables) and id[vegetables] == 2041
        # Select the vegetables with ID 2041

        bind pot: item where:
            is_pot(pot) and id[pot] == 2069
        # Select the pot with ID 2069

        put_vegetables_in_pot(vegetables, pot)
        # Put the vegetables in the pot

#goal_representation_end

##############################
From agent.py->reset_sub_goal
 
behavior put_vegetables_in_pot(vegetables: item, pot: item):
    body:
        if not inhand(vegetables):
            grab(vegetables)
        if not on(vegetables, pot):
            put_inside(vegetables, pot)

behavior __goal__():
    body:
        bind vegetables: item where:
            is_food_vegetable(vegetables) and id[vegetables] == 2041
        # Select the vegetables with ID 2041

        bind pot: item where:
            is_pot(pot) and id[pot] == 2069
        # Select the pot with ID 2069

        put_vegetables_in_pot(vegetables, pot)
        # Put the vegetables in the pot

##############################
From agent.py-> find a plan in act()
walk_executor(pot_2069)putin_executor(food_vegetable_2041, pot_2069)
##############################
From agent.py
walk_executor(pot_2069)
Robot find: Robot is close to the food_vegetable_2041. Robot is close to the stove_2065. Robot is close to the pot_2069. 
##############################
From agent.py
putin_executor(food_vegetable_2041, pot_2069)
Robot find: Robot is close to the food_vegetable_2041. Robot is close to the stove_2065. Robot is close to the pot_2069. food_vegetable_2041 is inside pot_2069. food_vegetable_2041 is close pot_2069. pot_2069 is close food_vegetable_2041. food_vegetable_2041 released by right hand. 
##############################
From agent.py -> evaluate_current_subgoal()
The evaluation result for current subgoal: Yes
The feedback instruction: None
##############################
Task Summary:
Task Goal:
Boil vegetables with a pot on the stove.
Action History:
['walk_executor(stove_2065)', 'open_executor(stove_2065)', 'walk_executor(pot_2069)', 'open_executor(pot_2069)', 'walk_executor(pot_2069)', 'grab_executor(pot_2069)', 'walk_executor(stove_2065)', 'put_executor(pot_2069, stove_2065)', 'grab_executor(pot_2069)', 'walk_executor(stove_2065)', 'put_executor(pot_2069, stove_2065)', 'switchon_executor(stove_2065)', 'walk_executor(pot_2069)', 'grab_executor(pot_2069)', 'walk_executor(faucet_43)', 'switchon_executor(faucet_43)', 'switchoff_executor(faucet_43)', 'walk_executor(stove_2065)', 'put_executor(pot_2069, stove_2065)', 'walk_executor(fridge_289)', 'switchoff_executor(fridge_289)', 'open_executor(fridge_289)', 'walk_executor(food_vegetable_2041)', 'grab_executor(food_vegetable_2041)', 'walk_executor(faucet_43)', 'switchon_executor(faucet_43)', 'wash_executor(food_vegetable_2041)', 'switchoff_executor(faucet_43)', 'walk_executor(pot_2069)', 'grab_executor(pot_2069)', 'walk_executor(stove_2065)', 'put_executor(pot_2069, stove_2065)', 'walk_executor(pot_2069)', 'grab_executor(pot_2069)', 'walk_executor(stove_2065)', 'put_executor(pot_2069, stove_2065)', 'walk_executor(stove_2065)', 'grab_executor(pot_2069)', 'put_executor(pot_2069, stove_2065)', 'walk_executor(stove_2065)', 'walk_executor(pot_2069)', 'putin_executor(food_vegetable_2041, pot_2069)']
Time info:
Time consume: 1095 seconds
Exp_helper query times: 0
Guidance query times: 1
library scale: 58
goal generate times: 19
goal correct times: 0
action_num: 42

Task complete rate:
1
Scene_id: 0
##############################
