From agent.py
Reset goals: The sub-goals are: 
['1. Go to each room and check if there is a light on.', '2. Turn on a light in rooms where the lights are off.']
##############################
Goal representation from planning.py

#exp_behavior

#exp_behavior_end

#goal_representation
 
def has_light_on_in_room(room:item):
    # Function to check if there is at least one light turned on in a specified room
    symbol light_on=exists l: item : (is_light(l) and inside(l, room) and is_on(l))
    return light_on

behavior check_and_turn_on_light(l:item):
    body:
        if not is_on(l):
            achieve_once is_on(l)

behavior __goal__():
    body:
        foreach room: item:
        # Iterate over each room in the environment to ensure there is a light on in each one
            if not visited(room):
                observe(room, "Check for a light in the room")
                foreach l: item:
                    if is_light(l) and inside(l, room):
                        check_and_turn_on_light(l)
            elif not has_light_on_in_room(room):
                # In case inspecting is performed by observation
                foreach l: item:
                    if is_light(l) and inside(l, room):
                        check_and_turn_on_light(l)

#goal_representation_end

##############################
Inner TransformationError Debug
Unexpected token Token('NOT', 'not') at line 5735, column 18.
Expected one of: 
	* OR
	* __ANON_3
	* __ANON_0
	* AND
	* PLUS
	* LESS_EQ
	* PERCENT
	* FLOORDIV
	* GREATER_EQ
	* __ANON_5
	* __ANON_1
	* _NEWLINE
	* SLASH
	* MINUS
	* IF
	* __ANON_2
	* RSHIFT
	* __ANON_7
	* AT
	* LESSTHAN
	* AMPERSAND
	* COMMA
	* __ANON_4
	* LSHIFT
	* SEMICOLON
	* VBAR
	* NOT_EQ
	* __ANON_8
	* STAR
	* EQUAL
	* __ANON_6
	* CIRCUMFLEX
	* DOUBLE_EQUAL
	* MORETHAN

##############################
Goal representation after debugging in planning.py
#exp_behavior

behavior find_laser_pointer_2025_around_light_258(laser_pointer:item):
    goal: not unknown(laser_pointer)
    body:
        assert is_laser_pointer(laser_pointer)
        bind light_instance:item where:
            is_light(light_instance) and id[light_instance]==258
        achieve close_char(char,light_instance)
        if can_open(light_instance):
            achieve_once open(light_instance)
            exp(laser_pointer,light_instance)
        else:
            exp(laser_pointer,light_instance)
    eff:
        unknown[laser_pointer]=False
        close[laser_pointer,light_instance]=True
        close[light_instance,laser_pointer]=True
    

behavior find_remote_control_2081_around_desk_261(remote_control:item):
    goal: not unknown(remote_control)
    body:
        assert is_remote_control(remote_control)
        bind desk_instance:item where:
            is_desk(desk_instance) and id[desk_instance]==261
        achieve close_char(char,desk_instance)
        if can_open(desk_instance):
            achieve_once open(desk_instance)
            exp(remote_control,desk_instance)
        else:
            exp(remote_control,desk_instance)
    eff:
        unknown[remote_control]=False
        close[remote_control,desk_instance]=True
        close[desk_instance,remote_control]=True
    

#goal_representation
 
def has_light_on_in_room(room:item):
    # Function to check if there is at least one light turned on in a specified room
    symbol light_on = exists l: item : (is_light(l) and inside(l, room) and is_on(l))
    return light_on

behavior check_and_turn_on_light(l:item):
    body:
        if not is_on(l):
            achieve_once is_on(l)

behavior __goal__():
    body:
        foreach room: item:
        # Iterate over each room in the environment to ensure there is a light on in each one
            if not visited(room):
                observe(room, "Check for a light in the room")
                foreach l: item:
                    if is_light(l) and inside(l, room):
                        check_and_turn_on_light(l)
            else:
                if not has_light_on_in_room(room):
                    # In case inspecting is performed by observation
                    foreach l: item:
                        if is_light(l) and inside(l, room):
                            check_and_turn_on_light(l)

#goal_representation_end

##############################
Error is:
'NoneType' object is not iterable
##############################
Goal representation from planning.py

#exp_behavior

behavior find_laser_pointer_2025_around_light_217(laser_pointer:item):
    goal: not unknown(laser_pointer)
    body:
        assert is_laser_pointer(laser_pointer)
        bind light_instance:item where:
            is_light(light_instance) and id[light_instance]==217
        achieve close_char(char,light_instance)
        if can_open(light_instance):
            achieve_once open(light_instance)
            exp(laser_pointer,light_instance)
        else:
            exp(laser_pointer,light_instance)
    eff:
        unknown[laser_pointer]=False
        close[laser_pointer,light_instance]=True
        close[light_instance,laser_pointer]=True
    

behavior find_remote_control_2081_around_desk_261(remote_control:item):
    goal: not unknown(remote_control)
    body:
        assert is_remote_control(remote_control)
        bind desk_instance:item where:
            is_desk(desk_instance) and id[desk_instance]==261
        achieve close_char(char,desk_instance)
        if can_open(desk_instance):
            achieve_once open(desk_instance)
            exp(remote_control,desk_instance)
        else:
            exp(remote_control,desk_instance)
    eff:
        unknown[remote_control]=False
        close[remote_control,desk_instance]=True
        close[desk_instance,remote_control]=True
    

#exp_behavior_end

#goal_representation
 
def has_light_on(room:item):
    # Function to check if there is at least one light on in the specified room
    symbol light_on=exists l: item : (is_light(l) and inside(l, room) and is_on(l))
    return light_on

behavior __goal__():
    body:
        foreach room: item:
            if not visited(room):
                # Check all unvisited rooms
                if not has_light_on(room):
                    # If no light is found to be on in the room
                    observe(room, "Check if there is any light on in the room")
                    # Observe whether there is a light on in the room

#goal_representation_end

##############################
Error is:
'NoneType' object is not iterable
##############################
Goal representation from planning.py

#exp_behavior

behavior find_iron_2117_around_ironing_board_2099(iron:item):
    goal: not unknown(iron)
    body:
        assert is_iron(iron)
        bind ironing_board_instance:item where:
            is_ironing_board(ironing_board_instance) and id[ironing_board_instance]==2099
        achieve close_char(char,ironing_board_instance)
        if can_open(ironing_board_instance):
            achieve_once open(ironing_board_instance)
            exp(iron,ironing_board_instance)
        else:
            exp(iron,ironing_board_instance)
    eff:
        unknown[iron]=False
        close[iron,ironing_board_instance]=True
        close[ironing_board_instance,iron]=True
    

behavior find_vacuum_cleaner_2094_around_light_258(vacuum_cleaner:item):
    goal: not unknown(vacuum_cleaner)
    body:
        assert is_vacuum_cleaner(vacuum_cleaner)
        bind light_instance:item where:
            is_light(light_instance) and id[light_instance]==258
        achieve close_char(char,light_instance)
        if can_open(light_instance):
            achieve_once open(light_instance)
            exp(vacuum_cleaner,light_instance)
        else:
            exp(vacuum_cleaner,light_instance)
    eff:
        unknown[vacuum_cleaner]=False
        close[vacuum_cleaner,light_instance]=True
        close[light_instance,vacuum_cleaner]=True
    

#exp_behavior_end

#goal_representation
 
def has_light_on(room:item):
    # Function to check if there is a light on in the specified room
    symbol has_light_on= exists light: item : (is_light(light) and is_on(light) and inside(light, room))
    return has_light_on

behavior check_light_in_room(light: item):
    body:
        if not is_on(light):
            achieve_once is_on(light)
        achieve visited(light)

behavior __goal__():
    body:
        # Iterate over all rooms to ensure there is a light on in each
        foreach room: item:
            if not has_light_on(room):
                foreach light: item:
                    if is_light(light) and inside(light, room):
                        check_light_in_room(light)

#goal_representation_end

##############################
From agent.py->reset_goal
 
def has_light_on(room:item):
    # Function to check if there is a light on in the specified room
    symbol has_light_on= exists light: item : (is_light(light) and is_on(light) and inside(light, room))
    return has_light_on

behavior check_light_in_room(light: item):
    body:
        if not is_on(light):
            achieve_once is_on(light)
        achieve visited(light)

behavior __goal__():
    body:
        # Iterate over all rooms to ensure there is a light on in each
        foreach room: item:
            if not has_light_on(room):
                foreach light: item:
                    if is_light(light) and inside(light, room):
                        check_light_in_room(light)

##############################
From agent.py-> find a plan in act()
walk_executor(light_49)switchon_executor(light_49)obs(light_49, look around this place)walk_executor(light_217)switchon_executor(light_217)obs(light_217, look around this place)walk_executor(light_258)switchon_executor(light_258)obs(light_258, look around this place)walk_executor(light_325)switchon_executor(light_325)obs(light_325, look around this place)walk_executor(light_384)switchon_executor(light_384)obs(light_384, look around this place)
##############################
From agent.py
walk_executor(light_49)
Robot find: phone_47, Robot is close to the light_49. 
##############################
From agent.py
switchon_executor(light_49)
Robot find: Robot is close to the light_49. light_49 is turned on. 
##############################
From agent.py
obs(light_49, look around this place)
Get this information:  light_49 is inside dining_room_1. light_49 is close to wall_3. light_49 is close to wall_5. light_49 is close to wall_268. light_49 is close to floor_13. light_49 is close to floor_14. light_49 is close to floor_12. light_49 is close to floor_277. light_49 is close to ceiling_25. light_49 is close to ceiling_26. light_49 is close to doorjamb_37. light_49 is close to floor_166. light_49 is close to wall_171. light_49 is close to toilet_302. light_49 is close to phone_47. light_49 is close to powersocket_48. light_49 is close to ceiling_176. light_49 is close to walllamp_183. light_49 is close to light_217. light_49 is close to powersocket_218. light_49 is close to character_219. light_49 is CLEAN. light_49 is ON. light_49 is PLUGGED_IN. light_49 is CLOSED.
##############################
From agent.py
walk_executor(light_217)
Robot find: Robot is close to the light_217. 
##############################
From agent.py
switchon_executor(light_217)
Robot find: Robot is close to the light_217. light_217 is turned on. 
##############################
From agent.py
obs(light_217, look around this place)
Get this information:  light_217 is close to wall_3. light_217 is close to ceiling_26. light_217 is close to doorjamb_37. light_217 is close to floor_166. light_217 is close to floor_167. light_217 is close to wall_6. light_217 is close to wall_171. light_217 is close to wall_172. light_217 is close to floor_14. light_217 is close to phone_47. light_217 is close to powersocket_48. light_217 is close to light_49. light_217 is close to ceiling_176. light_217 is close to ceiling_177. light_217 is close to floor_15. light_217 is close to powersocket_218. light_217 is close to ceiling_27. light_217 is close to bookshelf_189. light_217 is close to character_219. light_217 is inside home_office_161. light_217 is facing television_216. light_217 is CLEAN. light_217 is ON. light_217 is PLUGGED_IN. light_217 is CLOSED.
##############################
From agent.py
walk_executor(light_258)
Robot find: drawing_238, Robot is close to the light_258. 
##############################
From agent.py
switchon_executor(light_258)
Robot find: Robot is close to the light_258. light_258 is turned on. 
##############################
From agent.py
obs(light_258, look around this place)
Get this information:  light_258 is close to couch_192. light_258 is close to floor_224. light_258 is close to pillow_195. light_258 is close to drawing_196. light_258 is close to ceiling_228. light_258 is close to floor_165. light_258 is close to floor_164. light_258 is close to wall_232. light_258 is close to door_234. light_258 is close to wall_170. light_258 is close to wall_174. light_258 is close to drawing_238. light_258 is close to ceiling_179. light_258 is close to ceiling_180. light_258 is close to doorjamb_182. light_258 is close to character_219. light_258 is facing drawing_238. light_258 is inside bedroom_220. light_258 is CLEAN. light_258 is ON. light_258 is PLUGGED_IN. light_258 is CLOSED.
##############################
From agent.py
walk_executor(light_325)
Robot find: drawing_296, mat_292, Robot is close to the light_325. 
##############################
From agent.py
switchon_executor(light_325)
Robot find: Robot is close to the light_325. light_325 is turned on. 
##############################
From agent.py
obs(light_325, look around this place)
Get this information:  light_325 is inside bathroom_265. light_325 is close to ceiling_355. light_325 is close to mat_292. light_325 is close to drawing_296. light_325 is close to floor_332. light_325 is close to wall_269. light_325 is close to wall_271. light_325 is close to floor_272. light_325 is close to floor_337. light_325 is close to floor_273. light_325 is close to wall_339. light_325 is close to floor_276. light_325 is close to ceiling_279. light_325 is close to ceiling_280. light_325 is close to wall_345. light_325 is close to doorjamb_285. light_325 is close to ceiling_350. light_325 is close to door_286. light_325 is close to character_219. light_325 is CLEAN. light_325 is ON. light_325 is PLUGGED_IN. light_325 is CLOSED.
##############################
From agent.py
walk_executor(light_384)
Robot find: drawing_387, Robot is close to the light_384. 
##############################
From agent.py
switchon_executor(light_384)
Robot find: Robot is close to the light_384. light_384 is turned on. 
##############################
From agent.py
obs(light_384, look around this place)
Get this information:  light_384 is close to drawing_387. light_384 is close to tvstand_135. light_384 is close to wall_9. light_384 is close to wall_10. light_384 is close to floor_18. light_384 is close to floor_19. light_384 is close to ceiling_30. light_384 is close to ceiling_31. light_384 is close to door_38. light_384 is close to floor_335. light_384 is close to floor_336. light_384 is close to wall_343. light_384 is close to wall_344. light_384 is close to ceiling_353. light_384 is close to ceiling_354. light_384 is close to doorjamb_356. light_384 is close to orchid_117. light_384 is close to drawing_118. light_384 is close to desk_375. light_384 is close to mousepad_381. light_384 is close to character_219. light_384 is inside bedroom_327. light_384 is CLEAN. light_384 is ON. light_384 is PLUGGED_IN. light_384 is CLOSED.
##############################
From agent.py -> evaluate_current_subgoal()
The evaluation result for current subgoal: Yes
The feedback instruction: None
##############################
Goal representation from planning.py

#exp_behavior

#exp_behavior_end

#goal_representation
 
def is_light_off(room:item):
    # Function to check if there is no light turned on in the room
    symbol all_off = not exists l: item : (is_light(l) and inside(l, room) and is_on(l))
    return all_off

behavior turn_on_light(l:item):
    body:
        achieve is_on(l)
        # Turn on the light as needed

behavior __goal__():
    body:
        foreach room: item:
            if is_light_off(room):
                # Check all rooms for lights that are off
                foreach l: item:
                    if is_light(l) and inside(l, room) and is_off(l):
                        turn_on_light(l)
                        # Turn on light if its inside a room and currently turned off

#goal_representation_end

##############################
Inner TransformationError Debug
Unexpected token Token('VARNAME', 'l') at line 5736, column 33.
Expected one of: 
	* SEMICOLON
	* _NEWLINE

##############################
Goal representation after debugging in planning.py
#exp_behavior

#goal_representation
 
def is_light_off(room:item):
    # Function to check if there is no light turned on in the room
    symbol all_off = not exists l: item : (is_light(l) and inside(l, room) and is_on(l))
    return all_off

behavior turn_on_light(l:item):
    body:
        achieve is_on(l)
        # Turn on the light as needed

behavior __goal__():
    body:
        foreach room: item:
            if is_light_off(room):
                # Check all rooms for lights that are off
                foreach l: item:
                    if is_light(l) and inside(l, room) and is_off(l):
                        turn_on_light(l)
                        # Turn on light if its inside a room and currently turned off

#goal_representation_end

##############################
Inner TransformationError Debug
Unexpected token Token('VARNAME', 'l') at line 5736, column 33.
Expected one of: 
	* SEMICOLON
	* _NEWLINE

##############################
Goal representation after debugging in planning.py
#exp_behavior

#goal_representation
 
def is_light_off(room:item):
    # Function to check if there is no light turned on in the room
    symbol all_off = not exists l: item : (is_light(l) and inside(l, room) and is_on(l))
    return all_off

behavior turn_on_light(l:item):
    body:
        achieve is_on(l)
        # Turn on the light as needed

behavior __goal__():
    body:
        foreach room: item:
            if is_light_off(room):
                # Check all rooms for lights that are off
                foreach l: item:
                    if is_light(l) and inside(l, room) and is_off(l):
                        turn_on_light(l)
                        # Turn on light if its inside a room and currently turned off

#goal_representation_end

##############################
Goal representation from planning.py

#exp_behavior

behavior find_laser_pointer_2025_around_desk_261(laser_pointer:item):
    goal: not unknown(laser_pointer)
    body:
        assert is_laser_pointer(laser_pointer)
        bind desk_instance:item where:
            is_desk(desk_instance) and id[desk_instance]==261
        achieve close_char(char,desk_instance)
        if can_open(desk_instance):
            achieve_once open(desk_instance)
            exp(laser_pointer,desk_instance)
        else:
            exp(laser_pointer,desk_instance)
    eff:
        unknown[laser_pointer]=False
        close[laser_pointer,desk_instance]=True
        close[desk_instance,laser_pointer]=True
    

#exp_behavior_end

#goal_representation
 
def is_light_on_in_all_rooms():
    symbol all_rooms_have_lights_on = not exists room: item : (is_room(room) and not exists light: item : (is_light(light) and inside(light, room) and is_on(light)))
    return all_rooms_have_lights_on

behavior turn_on_light_in_room(room: item):
    body:
        foreach light: item:
            if is_light(light) and inside(light, room) and not is_on(light):
                achieve_once is_on(light)

behavior __goal__():
    body:
        if not is_light_on_in_all_rooms():
            foreach room: item:
                if is_room(room):
                    turn_on_light_in_room(room)

#goal_representation_end

##############################
Inner TransformationError Debug
Unexpected token Token('VARNAME', 'room') at line 5753, column 50.
Expected one of: 
	* SEMICOLON
	* _NEWLINE

##############################
Goal representation after debugging in planning.py
#exp_behavior

behavior find_laser_pointer_2025_around_desk_261(laser_pointer:item):
    goal: not unknown(laser_pointer)
    body:
        assert is_laser_pointer(laser_pointer)
        bind desk_instance:item where:
            is_desk(desk_instance) and id[desk_instance]==261
        achieve close_char(char,desk_instance)
        if can_open(desk_instance):
            achieve_once open(desk_instance)
            exp(laser_pointer,desk_instance)
        else:
            exp(laser_pointer,desk_instance)
    eff:
        unknown[laser_pointer]=False
        close[laser_pointer,desk_instance]=True
        close[desk_instance,laser_pointer]=True
    

behavior find_glue_2013_around_bathroom_counter_306(glue:item):
    goal: not unknown(glue)
    body:
        assert is_glue(glue)
        bind bathroom_counter_instance:item where:
            is_bathroom_counter(bathroom_counter_instance) and id[bathroom_counter_instance]==306
        achieve close_char(char,bathroom_counter_instance)
        if can_open(bathroom_counter_instance):
            achieve_once open(bathroom_counter_instance)
            exp(glue,bathroom_counter_instance)
        else:
            exp(glue,bathroom_counter_instance)
    eff:
        unknown[glue]=False
        close[glue,bathroom_counter_instance]=True
        close[bathroom_counter_instance,glue]=True
    

#goal_representation
def is_light_on_in_all_rooms():
    symbol all_rooms_have_lights_on=not exists room: item : (is_room(room) and not exists light: item : (is_light(light) and inside(light, room) and is_on(light)))
    return all_rooms_have_lights_on

behavior turn_on_light_in_room(room: item):
    body:
        foreach light: item:
            if is_light(light) and inside(light, room) and not is_on(light):
                achieve_once is_on(light)

behavior __goal__():
    body:
        if not is_light_on_in_all_rooms():
            foreach room: item:
                if is_room(room):
                    turn_on_light_in_room(room)
#goal_representation_end

##############################
Inner TransformationError Debug
Unexpected token Token('VARNAME', 'room') at line 5770, column 48.
Expected one of: 
	* SEMICOLON
	* _NEWLINE

##############################
Goal representation after debugging in planning.py
#exp_behavior

behavior find_laser_pointer_2025_around_nightstand_262(laser_pointer:item):
    goal: not unknown(laser_pointer)
    body:
        assert is_laser_pointer(laser_pointer)
        bind nightstand_instance:item where:
            is_nightstand(nightstand_instance) and id[nightstand_instance]==262
        achieve close_char(char,nightstand_instance)
        if can_open(nightstand_instance):
            achieve_once open(nightstand_instance)
            exp(laser_pointer,nightstand_instance)
        else:
            exp(laser_pointer,nightstand_instance)
    eff:
        unknown[laser_pointer]=False
        close[laser_pointer,nightstand_instance]=True
        close[nightstand_instance,laser_pointer]=True
    

behavior find_cd_player_2084_around_bed_376(cd_player:item):
    goal: not unknown(cd_player)
    body:
        assert is_cd_player(cd_player)
        bind bed_instance:item where:
            is_bed(bed_instance) and id[bed_instance]==376
        achieve close_char(char,bed_instance)
        if can_open(bed_instance):
            achieve_once open(bed_instance)
            exp(cd_player,bed_instance)
        else:
            exp(cd_player,bed_instance)
    eff:
        unknown[cd_player]=False
        close[cd_player,bed_instance]=True
        close[bed_instance,cd_player]=True
    

behavior find_remote_control_2081_around_television_216(remote_control:item):
    goal: not unknown(remote_control)
    body:
        assert is_remote_control(remote_control)
        bind television_instance:item where:
            is_television(television_instance) and id[television_instance]==216
        achieve close_char(char,television_instance)
        if can_open(television_instance):
            achieve_once open(television_instance)
            exp(remote_control,television_instance)
        else:
            exp(remote_control,television_instance)
    eff:
        unknown[remote_control]=False
        close[remote_control,television_instance]=True
        close[television_instance,remote_control]=True
    

#goal_representation
 
def is_light_on_in_all_rooms():
    symbol all_rooms_have_lights_on=not exists room1: item : (is_room(room1) and not exists light1: item : (is_light(light1) and inside(light1, room1) and is_on(light1)))
    return all_rooms_have_lights_on

behavior turn_on_light_in_room(room: item):
    body:
        foreach light: item:
            if is_light(light) and inside(light, room) and not is_on(light):
                achieve_once is_on(light)

behavior __goal__():
    body:
        if not is_light_on_in_all_rooms():
            foreach room: item:
                if is_room(room):
                    turn_on_light_in_room(room)

#goal_representation_end

##############################
Goal representation from planning.py

#exp_behavior

#exp_behavior_end

#goal_representation
behavior turn_on_light(room: item, light: item):
    body:
        achieve close_char(char, light)
        achieve is_on(light)

behavior __goal__():
    body:
        foreach light: item:
            if is_light(light) and not visited(light):
                observe(light, "Check if this light is on")
                if is_off(light):
                    bind room: item where:
                        inside(light, room)
                    turn_on_light(room, light)
#goal_representation_end

##############################
VH_pipeline: Fail to generate a valid plan
##############################
Goal representation from planning.py

#exp_behavior

behavior find_iron_2117_around_ironing_board_2099(iron:item):
    goal: not unknown(iron)
    body:
        assert is_iron(iron)
        bind ironing_board_instance:item where:
            is_ironing_board(ironing_board_instance) and id[ironing_board_instance]==2099
        achieve close_char(char,ironing_board_instance)
        if can_open(ironing_board_instance):
            achieve_once open(ironing_board_instance)
            exp(iron,ironing_board_instance)
        else:
            exp(iron,ironing_board_instance)
    eff:
        unknown[iron]=False
        close[iron,ironing_board_instance]=True
        close[ironing_board_instance,iron]=True
    

behavior find_remote_control_2081_around_cutting_board_2080(remote_control:item):
    goal: not unknown(remote_control)
    body:
        assert is_remote_control(remote_control)
        bind cutting_board_instance:item where:
            is_cutting_board(cutting_board_instance) and id[cutting_board_instance]==2080
        achieve close_char(char,cutting_board_instance)
        if can_open(cutting_board_instance):
            achieve_once open(cutting_board_instance)
            exp(remote_control,cutting_board_instance)
        else:
            exp(remote_control,cutting_board_instance)
    eff:
        unknown[remote_control]=False
        close[remote_control,cutting_board_instance]=True
        close[cutting_board_instance,remote_control]=True
    

#exp_behavior_end

#goal_representation
 
def ensure_light_in_room(room: item):
    # Function to ensure that there is at least one light on in the specified room
    symbol light_on=exists light: item : (is_light(light) and inside(light, room) and is_on(light))
    return light_on

behavior turn_on_light_if_off(light: item):
    body:
        achieve_once is_on(light)

behavior __goal__():
    body:
        foreach room: item:
            if (is_bathroom(room) or is_bedroom(room) or is_dining_room(room) or is_home_office(room)) and not ensure_light_in_room(room):
                # If a room is found without a light on, turn on any available light in the room
                foreach light: item:
                    if is_light(light) and inside(light, room) and is_off(light):
                        turn_on_light_if_off(light)

#goal_representation_end

##############################
Goal representation from planning.py

#exp_behavior

behavior find_laser_pointer_2025_around_curtain_293(laser_pointer:item):
    goal: not unknown(laser_pointer)
    body:
        assert is_laser_pointer(laser_pointer)
        bind curtain_instance:item where:
            is_curtain(curtain_instance) and id[curtain_instance]==293
        achieve close_char(char,curtain_instance)
        if can_open(curtain_instance):
            achieve_once open(curtain_instance)
            exp(laser_pointer,curtain_instance)
        else:
            exp(laser_pointer,curtain_instance)
    eff:
        unknown[laser_pointer]=False
        close[laser_pointer,curtain_instance]=True
        close[curtain_instance,laser_pointer]=True
    

#exp_behavior_end

#goal_representation
 
behavior turn_on_light(light:item):
    body:
        achieve is_on(light)

behavior __goal__():
    body:
        foreach light: item:
            if is_light(light) and is_off(light):
                turn_on_light(light)

#goal_representation_end

##############################
Goal representation from planning.py

#exp_behavior

#exp_behavior_end

#goal_representation

behavior walk_to_and_turn_on_light(light:item):
    body:
        achieve_once close_char(char, light)
        achieve is_on(light)

def has_light_off(room:item):
    symbol has_light_off=exists light: item : (is_light(light) and is_off(light) and inside(light, room))
    return has_light_off

behavior __goal__():
    body:
        foreach room: item:
            if is_off(light) and inside(light, room) and not visited(light):
                observe(light, "Check if the light is off and room needs light on")
        
        foreach room: item:
            if has_light_off(room):
                bind light: item where:
                    is_light(light) and is_off(light) and inside(light, room)
                walk_to_and_turn_on_light(light)

#goal_representation_end

##############################
Inner TransformationError Debug
Error trying to process rule "behavior_definition":

Unknown variable: light; available variables: [Variable<room: item>].
##############################
Goal representation after debugging in planning.py
#exp_behavior

#goal_representation
 
def has_light_off(room:item):
    symbol has_light_off=exists light: item : (is_light(light) and is_off(light) and inside(light, room))
    return has_light_off

behavior walk_to_and_turn_on_light(light:item):
    body:
        achieve_once close_char(char, light)
        achieve is_on(light)

behavior __goal__():
    body:
        foreach room: item:
            if not visited(room):
                bind light: item where:
                    is_light(light) and is_off(light) and inside(light, room)
                observe(light, "Check if the light is off and room needs light on")
        
        foreach room: item:
            if has_light_off(room):
                bind light: item where:
                    is_light(light) and is_off(light) and inside(light, room)
                walk_to_and_turn_on_light(light)

#goal_representation_end

##############################
Error is:
'NoneType' object is not iterable
##############################
VH_pipeline: Fail to generate a valid plan
##############################
Goal representation from planning.py

#exp_behavior

#exp_behavior_end

#goal_representation

behavior turn_on_light(light:item):
    body:
        # Turn on the light
        achieve is_on(light)

behavior check_and_turn_on_light_in_room(room:item):
    body:
        bind light: item where:
            is_light(light) and inside(light, room) and is_off(light)
        # Check for lights in the given room and turn it on if off
        turn_on_light(light)

behavior __goal__():
    body:
        foreach room: item:
            if not visited(room):
                observe(room, "Check if there is any light off in the room")
            # For each room that is unvisited, check the state of the lights
            check_and_turn_on_light_in_room(room)

#goal_representation_end

##############################
Error is:
'NoneType' object is not iterable
##############################
Goal representation from planning.py

#exp_behavior

behavior find_remote_control_2081_around_bookshelf_260(remote_control:item):
    goal: not unknown(remote_control)
    body:
        assert is_remote_control(remote_control)
        bind bookshelf_instance:item where:
            is_bookshelf(bookshelf_instance) and id[bookshelf_instance]==260
        achieve close_char(char,bookshelf_instance)
        if can_open(bookshelf_instance):
            achieve_once open(bookshelf_instance)
            exp(remote_control,bookshelf_instance)
        else:
            exp(remote_control,bookshelf_instance)
    eff:
        unknown[remote_control]=False
        close[remote_control,bookshelf_instance]=True
        close[bookshelf_instance,remote_control]=True
    

#exp_behavior_end

#goal_representation

def is_light_off(light:item):
    # Function to check if a light is off
    symbol light_off= is_off(light)
    return light_off

behavior turn_on_light(light:item):
    body:
        achieve_once is_on(light) # Turn on the light

behavior __goal__():
    body:
        foreach light: item:
            # Turn on lights that are off
            if is_light(light) and is_light_off(light):
                turn_on_light(light)

#goal_representation_end

##############################
Goal representation from planning.py

#exp_behavior

behavior find_iron_2117_around_ironing_board_2099(iron:item):
    goal: not unknown(iron)
    body:
        assert is_iron(iron)
        bind ironing_board_instance:item where:
            is_ironing_board(ironing_board_instance) and id[ironing_board_instance]==2099
        achieve close_char(char,ironing_board_instance)
        if can_open(ironing_board_instance):
            achieve_once open(ironing_board_instance)
            exp(iron,ironing_board_instance)
        else:
            exp(iron,ironing_board_instance)
    eff:
        unknown[iron]=False
        close[iron,ironing_board_instance]=True
        close[ironing_board_instance,iron]=True
    

behavior find_video_game_controller_2019_around_desk_261(video_game_controller:item):
    goal: not unknown(video_game_controller)
    body:
        assert is_video_game_controller(video_game_controller)
        bind desk_instance:item where:
            is_desk(desk_instance) and id[desk_instance]==261
        achieve close_char(char,desk_instance)
        if can_open(desk_instance):
            achieve_once open(desk_instance)
            exp(video_game_controller,desk_instance)
        else:
            exp(video_game_controller,desk_instance)
    eff:
        unknown[video_game_controller]=False
        close[video_game_controller,desk_instance]=True
        close[desk_instance,video_game_controller]=True
    

behavior find_remote_control_2081_around_television_216(remote_control:item):
    goal: not unknown(remote_control)
    body:
        assert is_remote_control(remote_control)
        bind television_instance:item where:
            is_television(television_instance) and id[television_instance]==216
        achieve close_char(char,television_instance)
        if can_open(television_instance):
            achieve_once open(television_instance)
            exp(remote_control,television_instance)
        else:
            exp(remote_control,television_instance)
    eff:
        unknown[remote_control]=False
        close[remote_control,television_instance]=True
        close[television_instance,remote_control]=True
    

#exp_behavior_end

#goal_representation
 
def is_light_off(light: item):
    # Function to check if a light item is off
    symbol light_off = is_off(light)
    return light_off

behavior turn_on_light(light: item):
    body:
        achieve_once is_on(light) 
        # Turn on the light, achieving the is_on state temporarily

behavior __goal__():
    body:
        foreach light: item:
            if is_light(light) and is_light_off(light): 
                # Ensure light is categorized as a light and is off
                turn_on_light(light)

#goal_representation_end

##############################
VH_pipeline: Fail to generate a valid plan
##############################
Task Summary:
Task Goal:
Make sure there is at least one light on in every room.
Action History:
['walk_executor(light_49)', 'switchon_executor(light_49)', 'walk_executor(light_217)', 'switchon_executor(light_217)', 'walk_executor(light_258)', 'switchon_executor(light_258)', 'walk_executor(light_325)', 'switchon_executor(light_325)', 'walk_executor(light_384)', 'switchon_executor(light_384)']
Time info:
Time consume: 168 seconds
Exp_helper query times: 0
Guidance query times: 0
library scale: 50
goal generate times: 12
goal correct times: 1
action_num: 10

Task complete rate:
Keystate: k1 - Requires: 0 steps
Action Completion Rate: No actions required
Scene_id: 2
##############################
