From agent.py
Reset goals: The sub-goals are: 
['1. Find a pot and place it on the stove.', '2. Boil the vegetables in the pot.']
##############################
Goal representation from planning.py

#exp_behavior

behavior find_iron_2117_around_ironing_board_2099(iron:item):
    goal: not unknown(iron)
    body:
        assert is_iron(iron)
        bind ironing_board_instance:item where:
            is_ironing_board(ironing_board_instance) and id[ironing_board_instance]==2099
        achieve close_char(char,ironing_board_instance)
        if can_open(ironing_board_instance):
            achieve_once open(ironing_board_instance)
            exp(iron,ironing_board_instance)
        else:
            exp(iron,ironing_board_instance)
    eff:
        unknown[iron]=False
        close[iron,ironing_board_instance]=True
        close[ironing_board_instance,iron]=True
    

behavior find_pot_54_around_kitchen_counter_132(pot:item):
    goal: not unknown(pot)
    body:
        assert is_pot(pot)
        bind kitchen_counter_instance:item where:
            is_kitchen_counter(kitchen_counter_instance) and id[kitchen_counter_instance]==132
        achieve close_char(char,kitchen_counter_instance)
        if can_open(kitchen_counter_instance):
            achieve_once open(kitchen_counter_instance)
            exp(pot,kitchen_counter_instance)
        else:
            exp(pot,kitchen_counter_instance)
    eff:
        unknown[pot]=False
        close[pot,kitchen_counter_instance]=True
        close[kitchen_counter_instance,pot]=True
    

#exp_behavior_end

#goal_representation
 
behavior find_and_place_pot_on_stove(pot:item, stove:item):
    body:
        achieve_once on(pot, stove)
        # Place the pot on the stove

behavior __goal__():
    body:
        bind stove: item where:
            is_stove(stove)
        # Bind to a stove
        if exists pot: item : (is_pot(pot) and close_char(char, pot)):
            # If a pot is found close to the character, bind and place it on the stove
            bind pot: item where:
                is_pot(pot) and close_char(char, pot)
            find_and_place_pot_on_stove(pot, stove)
        else:
            # If no pot is found close to the character, check all items to find a pot
            foreach pot: item:
                if is_pot(pot) and not visited(pot):
                    observe(pot, "Check if the item is a pot that can be used on the stove")
                    # Observe the pot if it is unvisited

#goal_representation_end

##############################
From agent.py->reset_goal
 
behavior find_and_place_pot_on_stove(pot:item, stove:item):
    body:
        achieve_once on(pot, stove)
        # Place the pot on the stove

behavior __goal__():
    body:
        bind stove: item where:
            is_stove(stove)
        # Bind to a stove
        if exists pot: item : (is_pot(pot) and close_char(char, pot)):
            # If a pot is found close to the character, bind and place it on the stove
            bind pot: item where:
                is_pot(pot) and close_char(char, pot)
            find_and_place_pot_on_stove(pot, stove)
        else:
            # If no pot is found close to the character, check all items to find a pot
            foreach pot: item:
                if is_pot(pot) and not visited(pot):
                    observe(pot, "Check if the item is a pot that can be used on the stove")
                    # Observe the pot if it is unvisited

##############################
From agent.py-> find a plan in act()
walk_executor(kitchen_counter_132)exp(pot_2093, kitchen_counter_132)walk_executor(pot_2093)open_executor(pot_2093)obs(pot_2093, Check if the item is a pot that can be used on the stove)walk_executor(kitchen_counter_132)exp(pot_54, kitchen_counter_132)walk_executor(pot_54)open_executor(pot_54)obs(pot_54, Check if the item is a pot that can be used on the stove)
##############################
From agent.py
walk_executor(kitchen_counter_132)
Robot find: pot_54, Robot is close to the kitchen_counter_132. 
##############################
From agent.py
exp(pot_2093, kitchen_counter_132)
Fail to find pot_2093 around kitchen_counter_132. 
##############################
From agent.py-> find a plan in act()
walk_executor(pot_54)open_executor(pot_54)exp(pot_2093, pot_54)walk_executor(pot_2093)open_executor(pot_2093)obs(pot_2093, Check if the item is a pot that can be used on the stove)walk_executor(pot_54)obs(pot_54, Check if the item is a pot that can be used on the stove)
##############################
From agent.py
walk_executor(pot_54)
Robot find: Robot is close to the oven_141. Robot is close to the pot_54. 
##############################
From agent.py
open_executor(pot_54)
Robot find: Robot is close to the oven_141. Robot is close to the pot_54. pot_54 is opened. 
##############################
From agent.py
exp(pot_2093, pot_54)
Fail to find pot_2093 around pot_54. 
##############################
From agent.py-> find a plan in act()
grab_executor(pot_54)walk_executor(stove_2090)put_executor(pot_54, stove_2090)
##############################
From agent.py
grab_executor(pot_54)
Robot find: Robot is close to the oven_141. Robot is close to the pot_54. Grabbing pot_54 by right hand. 
##############################
From agent.py
walk_executor(stove_2090)
Robot find: fryingpan_2107, oil_2102, pot_2093, Robot is close to the pot_54. Robot is close to the kitchen_counter_129. Robot is close to the stove_2090. 
##############################
From agent.py
put_executor(pot_54, stove_2090)
Robot find: Robot is close to the pot_54. Robot is close to the kitchen_counter_129. Robot is close to the stove_2090. pot_54 is on stove_2090. pot_54 is close stove_2090. stove_2090 is close pot_54. pot_54 released by right hand. 
##############################
From agent.py -> evaluate_current_subgoal()
The evaluation result for current subgoal: Yes
The feedback instruction: None
##############################
Goal representation from planning.py

#exp_behavior

behavior find_food_vegetable_2072_around_fridge_140(food_vegetable:item):
    goal: not unknown(food_vegetable)
    body:
        assert is_food_vegetable(food_vegetable)
        bind fridge_instance:item where:
            is_fridge(fridge_instance) and id[fridge_instance]==140
        achieve close_char(char,fridge_instance)
        if can_open(fridge_instance):
            achieve_once open(fridge_instance)
            exp(food_vegetable,fridge_instance)
        else:
            exp(food_vegetable,fridge_instance)
    eff:
        unknown[food_vegetable]=False
        close[food_vegetable,fridge_instance]=True
        close[fridge_instance,food_vegetable]=True
    

#exp_behavior_end

#goal_representation
 
def has_vegetables_in_pot(pot:item):
    # Function to check if there are vegetables in the specified pot
    symbol has_vegetables= exists v: item : (is_food_vegetable(v) and inside(v, pot))
    return has_vegetables

behavior boil_vegetables(pot:item, stove:item):
    body:
        achieve is_on(stove)
        # Turn on the stove to start boiling

behavior __goal__():
    body:
        bind pot: item where:
            is_pot(pot) and on(pot, stove_2090)
        # Select the pot which is on the stove

        bind stove: item where:
            is_stove(stove) and on(pot, stove)
        # Select the stove the pot is on

        if not has_vegetables_in_pot(pot):
            # If the pot does not contain vegetables, explore to find them
            foreach vegetable: item:
                if is_food_vegetable(vegetable) and not inside(vegetable, pot):
                    observe(vegetable, "Check if any vegetables are outside the pot")
                    
        if has_vegetables_in_pot(pot):
            boil_vegetables(pot, stove)

#goal_representation_end

##############################
Inner TransformationError Debug
Error trying to process rule "behavior_definition":

Unknown variable: stove_2090; available variables: [Variable<pot: item>].
##############################
Goal representation after debugging in planning.py
#exp_behavior

behavior find_food_carrot_2047_around_cupboard_130(food_carrot:item):
    goal: not unknown(food_carrot)
    body:
        assert is_food_carrot(food_carrot)
        bind cupboard_instance:item where:
            is_cupboard(cupboard_instance) and id[cupboard_instance]==130
        achieve close_char(char,cupboard_instance)
        if can_open(cupboard_instance):
            achieve_once open(cupboard_instance)
            exp(food_carrot,cupboard_instance)
        else:
            exp(food_carrot,cupboard_instance)
    eff:
        unknown[food_carrot]=False
        close[food_carrot,cupboard_instance]=True
        close[cupboard_instance,food_carrot]=True
    

behavior find_food_onion_2026_around_cutting_board_2080(food_onion:item):
    goal: not unknown(food_onion)
    body:
        assert is_food_onion(food_onion)
        bind cutting_board_instance:item where:
            is_cutting_board(cutting_board_instance) and id[cutting_board_instance]==2080
        achieve close_char(char,cutting_board_instance)
        if can_open(cutting_board_instance):
            achieve_once open(cutting_board_instance)
            exp(food_onion,cutting_board_instance)
        else:
            exp(food_onion,cutting_board_instance)
    eff:
        unknown[food_onion]=False
        close[food_onion,cutting_board_instance]=True
        close[cutting_board_instance,food_onion]=True
    

behavior find_food_vegetable_2072_around_fridge_140(food_vegetable:item):
    goal: not unknown(food_vegetable)
    body:
        assert is_food_vegetable(food_vegetable)
        bind fridge_instance:item where:
            is_fridge(fridge_instance) and id[fridge_instance]==140
        achieve close_char(char,fridge_instance)
        if can_open(fridge_instance):
            achieve_once open(fridge_instance)
            exp(food_vegetable,fridge_instance)
        else:
            exp(food_vegetable,fridge_instance)
    eff:
        unknown[food_vegetable]=False
        close[food_vegetable,fridge_instance]=True
        close[fridge_instance,food_vegetable]=True
    

#goal_representation
 
def has_vegetables_in_pot(pot:item):
    # Function to check if there are vegetables in the specified pot
    symbol has_vegetables= exists v: item : (is_food_vegetable(v) and inside(v, pot))
    return has_vegetables

behavior boil_vegetables(pot:item, stove:item):
    body:
        achieve is_on(stove)
        # Turn on the stove to start boiling

behavior __goal__():
    body:
        bind pot: item where:
            is_pot(pot) and on(pot, stove_2090)
        # Select the pot which is on the stove

        bind stove: item where:
            is_stove(stove) and on(pot, stove)
        # Select the stove the pot is on

        if not has_vegetables_in_pot(pot):
            # If the pot does not contain vegetables, explore to find them
            foreach vegetable: item:
                if is_food_vegetable(vegetable) and not inside(vegetable, pot):
                    observe(vegetable, "Check if any vegetables are outside the pot")
                    
        if has_vegetables_in_pot(pot):
            boil_vegetables(pot, stove_2090)

#goal_representation_end

##############################
Inner TransformationError Debug
Error trying to process rule "behavior_definition":

Unknown variable: stove_2090; available variables: [Variable<pot: item>].
##############################
Goal representation after debugging in planning.py
#exp_behavior

behavior find_food_carrot_2047_around_cupboard_131(food_carrot:item):
    goal: not unknown(food_carrot)
    body:
        assert is_food_carrot(food_carrot)
        bind cupboard_instance:item where:
            is_cupboard(cupboard_instance) and id[cupboard_instance]==131
        achieve close_char(char,cupboard_instance)
        if can_open(cupboard_instance):
            achieve_once open(cupboard_instance)
            exp(food_carrot,cupboard_instance)
        else:
            exp(food_carrot,cupboard_instance)
    eff:
        unknown[food_carrot]=False
        close[food_carrot,cupboard_instance]=True
        close[cupboard_instance,food_carrot]=True
    

behavior find_food_onion_2026_around_cupboard_131(food_onion:item):
    goal: not unknown(food_onion)
    body:
        assert is_food_onion(food_onion)
        bind cupboard_instance:item where:
            is_cupboard(cupboard_instance) and id[cupboard_instance]==131
        achieve close_char(char,cupboard_instance)
        if can_open(cupboard_instance):
            achieve_once open(cupboard_instance)
            exp(food_onion,cupboard_instance)
        else:
            exp(food_onion,cupboard_instance)
    eff:
        unknown[food_onion]=False
        close[food_onion,cupboard_instance]=True
        close[cupboard_instance,food_onion]=True
    

behavior find_food_vegetable_2072_around_fridge_140(food_vegetable:item):
    goal: not unknown(food_vegetable)
    body:
        assert is_food_vegetable(food_vegetable)
        bind fridge_instance:item where:
            is_fridge(fridge_instance) and id[fridge_instance]==140
        achieve close_char(char,fridge_instance)
        if can_open(fridge_instance):
            achieve_once open(fridge_instance)
            exp(food_vegetable,fridge_instance)
        else:
            exp(food_vegetable,fridge_instance)
    eff:
        unknown[food_vegetable]=False
        close[food_vegetable,fridge_instance]=True
        close[fridge_instance,food_vegetable]=True
    

#goal_representation
 
def has_vegetables_in_pot(pot:item):
    # Function to check if there are vegetables in the specified pot
    symbol has_vegetables= exists v: item : (is_food_vegetable(v) and inside(v, pot))
    return has_vegetables

behavior boil_vegetables(pot:item, stove:item):
    body:
        achieve is_on(stove)
        # Turn on the stove to start boiling

behavior __goal__():
    body:
        bind pot: item where:
            is_pot(pot) and on(pot, stove_2090)
        # Select the pot which is on the stove

        bind stove: item where:
            is_stove(stove) and id[stove] == 2090
        # Select the stove using its id

        if not has_vegetables_in_pot(pot):
            # If the pot does not contain vegetables, explore to find them
            foreach vegetable: item:
                if is_food_vegetable(vegetable) and not inside(vegetable, pot):
                    observe(vegetable, "Check if any vegetables are outside the pot")
                    
        if has_vegetables_in_pot(pot):
            boil_vegetables(pot, stove)

#goal_representation_end

##############################
Goal representation from planning.py

#exp_behavior

behavior find_food_carrot_2047_around_fridge_140(food_carrot:item):
    goal: not unknown(food_carrot)
    body:
        assert is_food_carrot(food_carrot)
        bind fridge_instance:item where:
            is_fridge(fridge_instance) and id[fridge_instance]==140
        achieve close_char(char,fridge_instance)
        if can_open(fridge_instance):
            achieve_once open(fridge_instance)
            exp(food_carrot,fridge_instance)
        else:
            exp(food_carrot,fridge_instance)
    eff:
        unknown[food_carrot]=False
        close[food_carrot,fridge_instance]=True
        close[fridge_instance,food_carrot]=True
    

behavior find_food_onion_2026_around_cupboard_131(food_onion:item):
    goal: not unknown(food_onion)
    body:
        assert is_food_onion(food_onion)
        bind cupboard_instance:item where:
            is_cupboard(cupboard_instance) and id[cupboard_instance]==131
        achieve close_char(char,cupboard_instance)
        if can_open(cupboard_instance):
            achieve_once open(cupboard_instance)
            exp(food_onion,cupboard_instance)
        else:
            exp(food_onion,cupboard_instance)
    eff:
        unknown[food_onion]=False
        close[food_onion,cupboard_instance]=True
        close[cupboard_instance,food_onion]=True
    

behavior find_food_vegetable_2072_around_cutting_board_2080(food_vegetable:item):
    goal: not unknown(food_vegetable)
    body:
        assert is_food_vegetable(food_vegetable)
        bind cutting_board_instance:item where:
            is_cutting_board(cutting_board_instance) and id[cutting_board_instance]==2080
        achieve close_char(char,cutting_board_instance)
        if can_open(cutting_board_instance):
            achieve_once open(cutting_board_instance)
            exp(food_vegetable,cutting_board_instance)
        else:
            exp(food_vegetable,cutting_board_instance)
    eff:
        unknown[food_vegetable]=False
        close[food_vegetable,cutting_board_instance]=True
        close[cutting_board_instance,food_vegetable]=True
    

#exp_behavior_end

#goal_representation
 
behavior boil_vegetables(pot:item, stove:item, vegetables:item):
    body:
        achieve has_water(pot)
        # Fill the pot with water
        achieve_once inside(vegetables, pot)
        # Place the vegetables inside the pot
        achieve is_on(stove)
        # Ensure the stove is on to boil the vegetables

behavior __goal__():
    body:
        bind pot: item where:
            is_pot(pot) and on(pot, stove_2090)
        # Select the pot that has been placed on the stove
        
        bind stove: item where:
            is_stove(stove) and id[stove] == 2090
        # Select the stove with ID 2090
        
        bind vegetables: item where:
            is_food_vegetable(vegetables)
        # Assume there are vegetables classified as food_vegetable

        boil_vegetables(pot, stove, vegetables)
        # Call the boil_vegetables behavior

#goal_representation_end

##############################
Inner TransformationError Debug
Error trying to process rule "behavior_definition":

Unknown variable: stove_2090; available variables: [Variable<pot: item>].
##############################
Goal representation after debugging in planning.py
#exp_behavior

behavior find_food_vegetable_2072_around_fridge_140(food_vegetable:item):
    goal: not unknown(food_vegetable)
    body:
        assert is_food_vegetable(food_vegetable)
        bind fridge_instance:item where:
            is_fridge(fridge_instance) and id[fridge_instance]==140
        achieve close_char(char,fridge_instance)
        if can_open(fridge_instance):
            achieve_once open(fridge_instance)
            exp(food_vegetable,fridge_instance)
        else:
            exp(food_vegetable,fridge_instance)
    eff:
        unknown[food_vegetable]=False
        close[food_vegetable,fridge_instance]=True
        close[fridge_instance,food_vegetable]=True
    

#goal_representation
 
behavior boil_vegetables(pot:item, stove:item, vegetables:item):
    body:
        achieve has_water(pot)
        # Fill the pot with water
        achieve_once inside(vegetables, pot)
        # Place the vegetables inside the pot
        achieve is_on(stove)
        # Ensure the stove is on to boil the vegetables

behavior __goal__():
    body:
        bind stove: item where:
            is_stove(stove) and id[stove] == 2090
        # Select the stove with ID 2090
        
        bind pot: item where:
            is_pot(pot) and on(pot, stove)
        # Select the pot that has been placed on the stove
        
        bind vegetables: item where:
            is_food_vegetable(vegetables)
        # Assume there are vegetables classified as food_vegetable

        boil_vegetables(pot, stove, vegetables)
        # Call the boil_vegetables behavior

#goal_representation_end

##############################
From agent.py->reset_sub_goal
 
behavior boil_vegetables(pot:item, stove:item, vegetables:item):
    body:
        achieve has_water(pot)
        # Fill the pot with water
        achieve_once inside(vegetables, pot)
        # Place the vegetables inside the pot
        achieve is_on(stove)
        # Ensure the stove is on to boil the vegetables

behavior __goal__():
    body:
        bind stove: item where:
            is_stove(stove) and id[stove] == 2090
        # Select the stove with ID 2090
        
        bind pot: item where:
            is_pot(pot) and on(pot, stove)
        # Select the pot that has been placed on the stove
        
        bind vegetables: item where:
            is_food_vegetable(vegetables)
        # Assume there are vegetables classified as food_vegetable

        boil_vegetables(pot, stove, vegetables)
        # Call the boil_vegetables behavior

##############################
From agent.py-> find a plan in act()
grab_executor(pot_54)walk_executor(faucet_134)switchoff_executor(faucet_134)walk_executor(fridge_140)switchoff_executor(fridge_140)open_executor(fridge_140)exp(food_vegetable_2072, fridge_140)walk_executor(food_vegetable_2072)grab_executor(food_vegetable_2072)walk_executor(pot_54)putin_executor(food_vegetable_2072, pot_54)walk_executor(stove_2090)switchon_executor(stove_2090)
##############################
From agent.py
grab_executor(pot_54)
Robot find: Robot is close to the pot_54. Robot is close to the kitchen_counter_129. Robot is close to the stove_2090. Grabbing pot_54 by right hand. 
##############################
From agent.py
walk_executor(faucet_134)
Robot find: Robot is close to the pot_54. Robot is close to the kitchen_counter_132. Robot is close to the faucet_134. 
##############################
From agent.py
switchoff_executor(faucet_134)
Robot find: Robot is close to the pot_54. Robot is close to the kitchen_counter_132. Robot is close to the faucet_134. faucet_134 is turned off. 
##############################
From agent.py
walk_executor(fridge_140)
Robot find: chair_138, milk_2074, dry_pasta_2073, Robot is close to the pot_54. Robot is close to the fridge_140. 
##############################
From agent.py
switchoff_executor(fridge_140)
Robot find: Robot is close to the pot_54. Robot is close to the fridge_140. fridge_140 is turned off. 
##############################
From agent.py
open_executor(fridge_140)
Robot find: food_cereal_2048, food_cheese_2049, food_chicken_2050, food_dessert_2051, food_donut_2052, food_egg_2053, food_fish_2054, food_food_2055, food_fruit_2056, food_hamburger_2057, food_ice_cream_2058, food_jam_2059, food_kiwi_2060, food_lemon_2061, food_noodles_2062, food_oatmeal_2063, food_peanut_butter_2064, food_pizza_2065, food_potato_2066, food_rice_2067, food_salt_2068, food_snack_2069, food_sugar_2070, food_turkey_2071, food_vegetable_2072, sauce_2101, food_steak_2042, food_apple_2043, food_bacon_2044, food_banana_2045, food_cake_2046, food_carrot_2047, Robot is close to the pot_54. Robot is close to the food_cereal_2048. Robot is close to the food_cheese_2049. Robot is close to the food_chicken_2050. Robot is close to the food_dessert_2051. Robot is close to the food_donut_2052. Robot is close to the food_egg_2053. Robot is close to the food_fish_2054. Robot is close to the food_food_2055. Robot is close to the food_fruit_2056. Robot is close to the food_hamburger_2057. Robot is close to the food_ice_cream_2058. Robot is close to the food_jam_2059. Robot is close to the fridge_140. Robot is close to the food_kiwi_2060. Robot is close to the food_lemon_2061. Robot is close to the food_noodles_2062. Robot is close to the food_oatmeal_2063. Robot is close to the food_peanut_butter_2064. Robot is close to the food_pizza_2065. Robot is close to the food_potato_2066. Robot is close to the food_rice_2067. Robot is close to the food_salt_2068. Robot is close to the food_snack_2069. Robot is close to the food_sugar_2070. Robot is close to the food_turkey_2071. Robot is close to the food_vegetable_2072. Robot is close to the sauce_2101. Robot is close to the food_steak_2042. Robot is close to the food_apple_2043. Robot is close to the food_bacon_2044. Robot is close to the food_banana_2045. Robot is close to the food_cake_2046. Robot is close to the food_carrot_2047. fridge_140 is opened. 
##############################
From agent.py
exp(food_vegetable_2072, fridge_140)
Find food_vegetable_2072. 
##############################
Goal representation from planning.py

#exp_behavior

behavior find_blender_2032_around_kitchen_counter_128(blender:item):
    goal: not unknown(blender)
    body:
        assert is_blender(blender)
        bind kitchen_counter_instance:item where:
            is_kitchen_counter(kitchen_counter_instance) and id[kitchen_counter_instance]==128
        achieve close_char(char,kitchen_counter_instance)
        if can_open(kitchen_counter_instance):
            achieve_once open(kitchen_counter_instance)
            exp(blender,kitchen_counter_instance)
        else:
            exp(blender,kitchen_counter_instance)
    eff:
        unknown[blender]=False
        close[blender,kitchen_counter_instance]=True
        close[kitchen_counter_instance,blender]=True
    

behavior find_food_onion_2026_around_bench_124(food_onion:item):
    goal: not unknown(food_onion)
    body:
        assert is_food_onion(food_onion)
        bind bench_instance:item where:
            is_bench(bench_instance) and id[bench_instance]==124
        achieve close_char(char,bench_instance)
        if can_open(bench_instance):
            achieve_once open(bench_instance)
            exp(food_onion,bench_instance)
        else:
            exp(food_onion,bench_instance)
    eff:
        unknown[food_onion]=False
        close[food_onion,bench_instance]=True
        close[bench_instance,food_onion]=True
    

#exp_behavior_end

#goal_representation
 
def has_water_in_pot(pot:item):
    # Function to check if the pot has water
    symbol has_water= has_water(pot)
    return has_water

behavior boil_vegetables(pot:item, stove:item, vegetables:item):
    body:
        achieve_once inside(vegetables, pot) # Place the vegetables inside the pot
        achieve is_on(stove) # Ensure the stove is on 

behavior __goal__():
    body:
        bind pot: item where:
            is_pot(pot) and has_water_in_pot(pot) # Select a pot with water inside
        bind stove: item where:
            is_stove(stove) and on(pot, stove) # Select a stove with a pot on it
        bind vegetables: item where:
            is_food_vegetable(vegetables)
        boil_vegetables(pot, stove, vegetables)

#goal_representation_end

##############################
Error is:
'NoneType' object is not iterable
##############################
Goal representation from planning.py

#exp_behavior

behavior find_food_onion_2026_around_bench_124(food_onion:item):
    goal: not unknown(food_onion)
    body:
        assert is_food_onion(food_onion)
        bind bench_instance:item where:
            is_bench(bench_instance) and id[bench_instance]==124
        achieve close_char(char,bench_instance)
        if can_open(bench_instance):
            achieve_once open(bench_instance)
            exp(food_onion,bench_instance)
        else:
            exp(food_onion,bench_instance)
    eff:
        unknown[food_onion]=False
        close[food_onion,bench_instance]=True
        close[bench_instance,food_onion]=True
    

behavior find_blender_2032_around_cupboard_130(blender:item):
    goal: not unknown(blender)
    body:
        assert is_blender(blender)
        bind cupboard_instance:item where:
            is_cupboard(cupboard_instance) and id[cupboard_instance]==130
        achieve close_char(char,cupboard_instance)
        if can_open(cupboard_instance):
            achieve_once open(cupboard_instance)
            exp(blender,cupboard_instance)
        else:
            exp(blender,cupboard_instance)
    eff:
        unknown[blender]=False
        close[blender,cupboard_instance]=True
        close[cupboard_instance,blender]=True
    

behavior find_oil_2005_around_cupboard_131(oil:item):
    goal: not unknown(oil)
    body:
        assert is_oil(oil)
        bind cupboard_instance:item where:
            is_cupboard(cupboard_instance) and id[cupboard_instance]==131
        achieve close_char(char,cupboard_instance)
        if can_open(cupboard_instance):
            achieve_once open(cupboard_instance)
            exp(oil,cupboard_instance)
        else:
            exp(oil,cupboard_instance)
    eff:
        unknown[oil]=False
        close[oil,cupboard_instance]=True
        close[cupboard_instance,oil]=True
    

#exp_behavior_end

#goal_representation
 
behavior bring_water_to_boil(pot: item):
    body:
        achieve has_water(pot) 
        # Ensure the pot is filled with water
        achieve is_on(stove_2090)
        # Ensure the stove is turned on

behavior __goal__():
    body:
        bind pot: item where:
            is_pot(pot) and on(pot, stove_2090)
        # Select the pot that is on the stove
        bring_water_to_boil(pot)

#goal_representation_end

##############################
Inner TransformationError Debug
Error trying to process rule "behavior_definition":

Unknown variable: stove_2090; available variables: [Variable<pot: item>].
##############################
Goal representation after debugging in planning.py
#exp_behavior

behavior find_blender_2032_around_cupboard_130(blender:item):
    goal: not unknown(blender)
    body:
        assert is_blender(blender)
        bind cupboard_instance:item where:
            is_cupboard(cupboard_instance) and id[cupboard_instance]==130
        achieve close_char(char,cupboard_instance)
        if can_open(cupboard_instance):
            achieve_once open(cupboard_instance)
            exp(blender,cupboard_instance)
        else:
            exp(blender,cupboard_instance)
    eff:
        unknown[blender]=False
        close[blender,cupboard_instance]=True
        close[cupboard_instance,blender]=True
    

behavior find_oil_2005_around_cupboard_130(oil:item):
    goal: not unknown(oil)
    body:
        assert is_oil(oil)
        bind cupboard_instance:item where:
            is_cupboard(cupboard_instance) and id[cupboard_instance]==130
        achieve close_char(char,cupboard_instance)
        if can_open(cupboard_instance):
            achieve_once open(cupboard_instance)
            exp(oil,cupboard_instance)
        else:
            exp(oil,cupboard_instance)
    eff:
        unknown[oil]=False
        close[oil,cupboard_instance]=True
        close[cupboard_instance,oil]=True
    

#goal_representation
behavior bring_water_to_boil(pot: item, stove: item):
    body:
        achieve has_water(pot) 
        achieve is_on(stove)

behavior __goal__():
    body:
        bind pot: item where:
            is_pot(pot) and on(pot, stove_2090)
        bind stove: item where:
            is_stove(stove) and id[stove] == stove_2090
        bring_water_to_boil(pot, stove)
#goal_representation_end

##############################
Inner TransformationError Debug
Error trying to process rule "behavior_definition":

Unknown variable: stove_2090; available variables: [Variable<pot: item>].
##############################
Goal representation after debugging in planning.py
#exp_behavior

behavior find_food_onion_2026_around_bench_124(food_onion:item):
    goal: not unknown(food_onion)
    body:
        assert is_food_onion(food_onion)
        bind bench_instance:item where:
            is_bench(bench_instance) and id[bench_instance]==124
        achieve close_char(char,bench_instance)
        if can_open(bench_instance):
            achieve_once open(bench_instance)
            exp(food_onion,bench_instance)
        else:
            exp(food_onion,bench_instance)
    eff:
        unknown[food_onion]=False
        close[food_onion,bench_instance]=True
        close[bench_instance,food_onion]=True
    

#goal_representation
 
behavior bring_water_to_boil(pot: item, stove: item):
    body:
        achieve has_water(pot)
        achieve is_on(stove)

behavior __goal__():
    body:
        bind pot: item where:
            is_pot(pot) and on(pot, stove)
        bind stove: item where:
            is_stove(stove) and id[stove] == stove_2090
        bring_water_to_boil(pot, stove)

#goal_representation_end

##############################
Goal representation from planning.py

#exp_behavior

behavior find_food_onion_2026_around_cupboard_131(food_onion:item):
    goal: not unknown(food_onion)
    body:
        assert is_food_onion(food_onion)
        bind cupboard_instance:item where:
            is_cupboard(cupboard_instance) and id[cupboard_instance]==131
        achieve close_char(char,cupboard_instance)
        if can_open(cupboard_instance):
            achieve_once open(cupboard_instance)
            exp(food_onion,cupboard_instance)
        else:
            exp(food_onion,cupboard_instance)
    eff:
        unknown[food_onion]=False
        close[food_onion,cupboard_instance]=True
        close[cupboard_instance,food_onion]=True
    

#exp_behavior_end

#goal_representation
 
behavior check_faucet(faucet:item):
    body:
        achieve_once is_on(faucet) # Turn the faucet on
        achieve_once has_water(pot) # Fill the pot with water
        achieve_once is_off(faucet) # Turn the faucet off

behavior turn_on_stove(stove:item):
    body:
        achieve_once is_on(stove) # Turn the stove on

behavior boil_vegetables_in_pot(pot:item, stove:item):
    body:
        achieve has_water(pot) # The pot must have water
        achieve on(pot, stove) # The pot must be on the stove

behavior __goal__():
    body:
        bind pot: item where:
            is_pot(pot) and id[pot]==54
        # Select pot with ID 54

        bind stove: item where:
            is_stove(stove) and id[stove]==2090
        # Select stove with ID 2090

        bind faucet: item where:
            is_faucet(faucet) and id[faucet]==134
        # Select faucet with ID 134 (assuming this is the one)

        check_faucet(faucet) # Fill the pot with water using the faucet
        turn_on_stove(stove) # Turn on the stove
        boil_vegetables_in_pot(pot, stove) # Boil the vegetables in the pot

#goal_representation_end

##############################
Inner TransformationError Debug
Error trying to process rule "behavior_definition":

Unknown variable: pot; available variables: [Variable<faucet: item>].
##############################
Goal representation after debugging in planning.py
#exp_behavior

behavior find_food_onion_2026_around_bench_124(food_onion:item):
    goal: not unknown(food_onion)
    body:
        assert is_food_onion(food_onion)
        bind bench_instance:item where:
            is_bench(bench_instance) and id[bench_instance]==124
        achieve close_char(char,bench_instance)
        if can_open(bench_instance):
            achieve_once open(bench_instance)
            exp(food_onion,bench_instance)
        else:
            exp(food_onion,bench_instance)
    eff:
        unknown[food_onion]=False
        close[food_onion,bench_instance]=True
        close[bench_instance,food_onion]=True
    

#goal_representation
 
behavior check_faucet(faucet:item, pot:item):
    body:
        achieve_once is_on(faucet) # Turn the faucet on
        achieve_once has_water(pot) # Fill the pot with water
        achieve_once is_off(faucet) # Turn the faucet off

behavior turn_on_stove(stove:item):
    body:
        achieve_once is_on(stove) # Turn the stove on

behavior boil_vegetables_in_pot(pot:item, stove:item):
    body:
        achieve has_water(pot) # The pot must have water
        achieve on(pot, stove) # The pot must be on the stove

behavior __goal__():
    body:
        bind pot: item where:
            is_pot(pot) and id[pot]==54
        # Select pot with ID 54

        bind stove: item where:
            is_stove(stove) and id[stove]==2090
        # Select stove with ID 2090

        bind faucet: item where:
            is_faucet(faucet) and id[faucet]==134
        # Select faucet with ID 134 (assuming this is the one)

        check_faucet(faucet, pot) # Fill the pot with water using the faucet
        turn_on_stove(stove) # Turn on the stove
        boil_vegetables_in_pot(pot, stove) # Boil the vegetables in the pot

#goal_representation_end

##############################
From agent.py->reset_sub_goal
 
behavior check_faucet(faucet:item, pot:item):
    body:
        achieve_once is_on(faucet) # Turn the faucet on
        achieve_once has_water(pot) # Fill the pot with water
        achieve_once is_off(faucet) # Turn the faucet off

behavior turn_on_stove(stove:item):
    body:
        achieve_once is_on(stove) # Turn the stove on

behavior boil_vegetables_in_pot(pot:item, stove:item):
    body:
        achieve has_water(pot) # The pot must have water
        achieve on(pot, stove) # The pot must be on the stove

behavior __goal__():
    body:
        bind pot: item where:
            is_pot(pot) and id[pot]==54
        # Select pot with ID 54

        bind stove: item where:
            is_stove(stove) and id[stove]==2090
        # Select stove with ID 2090

        bind faucet: item where:
            is_faucet(faucet) and id[faucet]==134
        # Select faucet with ID 134 (assuming this is the one)

        check_faucet(faucet, pot) # Fill the pot with water using the faucet
        turn_on_stove(stove) # Turn on the stove
        boil_vegetables_in_pot(pot, stove) # Boil the vegetables in the pot

##############################
From agent.py-> find a plan in act()
walk_executor(faucet_134)switchon_executor(faucet_134)switchoff_executor(faucet_134)walk_executor(stove_2090)switchon_executor(stove_2090)put_executor(pot_54, stove_2090)
##############################
From agent.py
walk_executor(faucet_134)
Robot find: Robot is close to the pot_54. Robot is close to the kitchen_counter_132. Robot is close to the faucet_134. 
##############################
From agent.py
switchon_executor(faucet_134)
Robot find: Robot is close to the pot_54. Robot is close to the kitchen_counter_132. Robot is close to the faucet_134. faucet_134 is turned on. 
##############################
From agent.py
switchoff_executor(faucet_134)
Robot find: Robot is close to the pot_54. Robot is close to the kitchen_counter_132. Robot is close to the faucet_134. faucet_134 is turned off. 
##############################
From agent.py
walk_executor(stove_2090)
Robot find: Robot is close to the pot_54. Robot is close to the kitchen_counter_129. Robot is close to the stove_2090. 
##############################
From agent.py
switchon_executor(stove_2090)
Robot find: Robot is close to the pot_54. Robot is close to the kitchen_counter_129. Robot is close to the stove_2090. stove_2090 is turned on. 
##############################
From agent.py
put_executor(pot_54, stove_2090)
Robot find: Robot is close to the pot_54. Robot is close to the kitchen_counter_129. Robot is close to the stove_2090. pot_54 is on stove_2090. pot_54 is close stove_2090. pot_54 released by right hand. 
##############################
From agent.py -> evaluate_current_subgoal()
The evaluation result for current subgoal: No
The feedback instruction: The robot needs to put the food_vegetable_2072 into the pot_54 and ensure that the pot_54 contains water to effectively boil the vegetables.
##############################
From agent.py
Human Instruction: The robot needs to put the food_vegetable_2072 into the pot_54 and ensure that the pot_54 contains water to effectively boil the vegetables.

The actions you have taken:
Action 1: Walk to kitchen_counter_132.
Action 2: look for pot_2093 around kitchen_counter_132.
Action 3: Walk to pot_54.
Action 4: Open pot_54.
Action 5: look for pot_2093 around pot_54.
Action 6: Grab pot_54.
Action 7: Walk to stove_2090.
Action 8: Put pot_54 on stove_2090.
Action 9: Grab pot_54.
Action 10: Walk to faucet_134.
Action 11: Switch off faucet_134.
Action 12: Walk to fridge_140.
Action 13: Switch off fridge_140.
Action 14: Open fridge_140.
Action 15: look for food_vegetable_2072 around fridge_140.
Action 16: Walk to faucet_134.
Action 17: Switch on faucet_134.
Action 18: Switch off faucet_134.
Action 19: Walk to stove_2090.
Action 20: Switch on stove_2090.
Action 21: Put pot_54 on stove_2090.

##############################
Goal representation from planning.py

#exp_behavior

behavior find_soap_2037_around_sink_133(soap:item):
    goal: not unknown(soap)
    body:
        assert is_soap(soap)
        bind sink_instance:item where:
            is_sink(sink_instance) and id[sink_instance]==133
        achieve close_char(char,sink_instance)
        if can_open(sink_instance):
            achieve_once open(sink_instance)
            exp(soap,sink_instance)
        else:
            exp(soap,sink_instance)
    eff:
        unknown[soap]=False
        close[soap,sink_instance]=True
        close[sink_instance,soap]=True
    

behavior find_blender_2032_around_cupboard_130(blender:item):
    goal: not unknown(blender)
    body:
        assert is_blender(blender)
        bind cupboard_instance:item where:
            is_cupboard(cupboard_instance) and id[cupboard_instance]==130
        achieve close_char(char,cupboard_instance)
        if can_open(cupboard_instance):
            achieve_once open(cupboard_instance)
            exp(blender,cupboard_instance)
        else:
            exp(blender,cupboard_instance)
    eff:
        unknown[blender]=False
        close[blender,cupboard_instance]=True
        close[cupboard_instance,blender]=True
    

#exp_behavior_end

#goal_representation
behavior add_vegetables_to_pot(vegetable:item, pot:item):
    body:
        achieve_once inside(vegetable, pot)

behavior ensure_water_in_pot(pot:item):
    body:
        observe(pot, "Check if there is water in the pot")
        if not has_water(pot):
            achieve has_water(pot)

behavior turn_on_stove(stove:item):
    body:
        achieve_once is_on(stove)

behavior __goal__():
    body:
        bind vegetable: item where:
            is_food_vegetable(vegetable) and id[vegetable] == 2072
        bind pot: item where:
            is_pot(pot) and id[pot] == 54
        add_vegetables_to_pot(vegetable, pot)
        ensure_water_in_pot(pot)

        bind stove: item where:
            is_stove(stove) and id[stove] == 2090
        turn_on_stove(stove)
        achieve on(pot, stove)
#goal_representation_end

##############################
From agent.py->reset_sub_goal
behavior add_vegetables_to_pot(vegetable:item, pot:item):
    body:
        achieve_once inside(vegetable, pot)

behavior ensure_water_in_pot(pot:item):
    body:
        observe(pot, "Check if there is water in the pot")
        if not has_water(pot):
            achieve has_water(pot)

behavior turn_on_stove(stove:item):
    body:
        achieve_once is_on(stove)

behavior __goal__():
    body:
        bind vegetable: item where:
            is_food_vegetable(vegetable) and id[vegetable] == 2072
        bind pot: item where:
            is_pot(pot) and id[pot] == 54
        add_vegetables_to_pot(vegetable, pot)
        ensure_water_in_pot(pot)

        bind stove: item where:
            is_stove(stove) and id[stove] == 2090
        turn_on_stove(stove)
        achieve on(pot, stove)
##############################
From agent.py-> find a plan in act()
walk_executor(food_vegetable_2072)grab_executor(food_vegetable_2072)walk_executor(pot_54)putin_executor(food_vegetable_2072, pot_54)obs(pot_54, Check if there is water in the pot)
##############################
From agent.py
walk_executor(food_vegetable_2072)
Robot find: Robot is close to the food_vegetable_2072. Robot is close to the fridge_140. 
##############################
From agent.py
grab_executor(food_vegetable_2072)
Robot find: Robot is close to the food_vegetable_2072. Robot is close to the fridge_140. Grabbing food_vegetable_2072 by right hand. 
##############################
From agent.py
walk_executor(pot_54)
Robot find: Robot is close to the food_vegetable_2072. Robot is close to the stove_2090. Robot is close to the pot_54. 
##############################
From agent.py
putin_executor(food_vegetable_2072, pot_54)
Robot find: Robot is close to the food_vegetable_2072. Robot is close to the stove_2090. Robot is close to the pot_54. food_vegetable_2072 is close pot_54. pot_54 is close food_vegetable_2072. food_vegetable_2072 is inside pot_54. food_vegetable_2072 released by right hand. 
##############################
From agent.py
obs(pot_54, Check if there is water in the pot)
Get this information:  pot_54 is on stove_2090. pot_54 is close to stove_2090. pot_54 is close to character_219. pot_54 is close to food_vegetable_2072. food_vegetable_2072 is inside pot_54. pot_54 is inside dining_room_1. pot_54 is OPEN. pot_54 is CLEAN.
##############################
From agent.py -> evaluate_current_subgoal()
The evaluation result for current subgoal: No
The feedback instruction: Make sure the pot contains water to effectively boil the vegetables.
##############################
From agent.py
Human Instruction: Make sure the pot contains water to effectively boil the vegetables.

The actions you have taken:
Action 1: Walk to kitchen_counter_132.
Action 2: look for pot_2093 around kitchen_counter_132.
Action 3: Walk to pot_54.
Action 4: Open pot_54.
Action 5: look for pot_2093 around pot_54.
Action 6: Grab pot_54.
Action 7: Walk to stove_2090.
Action 8: Put pot_54 on stove_2090.
Action 9: Grab pot_54.
Action 10: Walk to faucet_134.
Action 11: Switch off faucet_134.
Action 12: Walk to fridge_140.
Action 13: Switch off fridge_140.
Action 14: Open fridge_140.
Action 15: look for food_vegetable_2072 around fridge_140.
Action 16: Walk to faucet_134.
Action 17: Switch on faucet_134.
Action 18: Switch off faucet_134.
Action 19: Walk to stove_2090.
Action 20: Switch on stove_2090.
Action 21: Put pot_54 on stove_2090.
Action 22: Walk to food_vegetable_2072.
Action 23: Grab food_vegetable_2072.
Action 24: Walk to pot_54.
Action 25: Put food_vegetable_2072 into pot_54.
Action 26: Observe around pot_54 with the question of Check if there is water in the pot.

##############################
Goal representation from planning.py

#exp_behavior

behavior find_cd_2100_around_computer_379(cd:item):
    goal: not unknown(cd)
    body:
        assert is_cd(cd)
        bind computer_instance:item where:
            is_computer(computer_instance) and id[computer_instance]==379
        achieve close_char(char,computer_instance)
        if can_open(computer_instance):
            achieve_once open(computer_instance)
            exp(cd,computer_instance)
        else:
            exp(cd,computer_instance)
    eff:
        unknown[cd]=False
        close[cd,computer_instance]=True
        close[computer_instance,cd]=True
    

behavior find_novel_2010_around_bookshelf_189(novel:item):
    goal: not unknown(novel)
    body:
        assert is_novel(novel)
        bind bookshelf_instance:item where:
            is_bookshelf(bookshelf_instance) and id[bookshelf_instance]==189
        achieve close_char(char,bookshelf_instance)
        if can_open(bookshelf_instance):
            achieve_once open(bookshelf_instance)
            exp(novel,bookshelf_instance)
        else:
            exp(novel,bookshelf_instance)
    eff:
        unknown[novel]=False
        close[novel,bookshelf_instance]=True
        close[bookshelf_instance,novel]=True
    

#exp_behavior_end

#goal_representation
 
def observe_pot_for_water(pot:item):
    # Function to check if there is water in the specified pot
    observe(pot, "Check if there is water in the pot")
    symbol has_water_pot=has_water(pot)
    return has_water_pot

behavior fill_pot_with_water(pot:item, faucet:item):
    body:
        bind stove: item where:
            is_stove(stove) and on(pot, stove) and not inhand(pot)
        # Ensure the pot is not inhand when placed on the stove
        achieve_once inhand(pot)
        # Temporarily hold the pot to fill with water
        achieve close_char(char, faucet)
        # Move close to the faucet
        achieve has_water(pot)
        # Fill the pot with water at the faucet

behavior boil_the_vegetables(pot:item, stove:item):
    body:
        achieve on(pot, stove)
        # Ensure the pot is on the stove
        achieve is_on(stove)
        # Turn on the stove to boil the water

behavior __goal__():
    body:
        bind pot: item where:
            is_pot(pot) 
        bind stove: item where:
            is_stove(stove) and on(pot, stove)
        if not observe_pot_for_water(pot):
            bind faucet: item where:
                is_faucet(faucet)
            fill_pot_with_water(pot, faucet)
        boil_the_vegetables(pot, stove)

#goal_representation_end

##############################
Inner TransformationError Debug
Error trying to process rule "function_definition":

Behavior body statements are not allowed in the current mode: SymbolicExecutionMode.DERIVED
##############################
Goal representation after debugging in planning.py
#exp_behavior

behavior find_food_onion_2026_around_cupboard_131(food_onion:item):
    goal: not unknown(food_onion)
    body:
        assert is_food_onion(food_onion)
        bind cupboard_instance:item where:
            is_cupboard(cupboard_instance) and id[cupboard_instance]==131
        achieve close_char(char,cupboard_instance)
        if can_open(cupboard_instance):
            achieve_once open(cupboard_instance)
            exp(food_onion,cupboard_instance)
        else:
            exp(food_onion,cupboard_instance)
    eff:
        unknown[food_onion]=False
        close[food_onion,cupboard_instance]=True
        close[cupboard_instance,food_onion]=True
    

behavior find_knife_2036_around_knifeblock_52(knife:item):
    goal: not unknown(knife)
    body:
        assert is_knife(knife)
        bind knifeblock_instance:item where:
            is_knifeblock(knifeblock_instance) and id[knifeblock_instance]==52
        achieve close_char(char,knifeblock_instance)
        if can_open(knifeblock_instance):
            achieve_once open(knifeblock_instance)
            exp(knife,knifeblock_instance)
        else:
            exp(knife,knifeblock_instance)
    eff:
        unknown[knife]=False
        close[knife,knifeblock_instance]=True
        close[knifeblock_instance,knife]=True
    

#goal_representation
 
def observe_pot_for_water(pot:item):
    # Function to check if there is water in the specified pot
    observe(pot, "Check if there is water in the pot")
    symbol has_water_pot=has_water(pot)
    return has_water_pot

behavior fill_pot_with_water(pot:item, faucet:item):
    body:
        achieve_once inhand(pot)
        # Temporarily hold the pot to fill with water
        achieve close_char(char, faucet)
        # Move close to the faucet
        achieve has_water(pot)
        # Fill the pot with water at the faucet

behavior boil_the_vegetables(pot:item, stove:item):
    body:
        achieve on(pot, stove)
        # Ensure the pot is on the stove
        achieve is_on(stove)
        # Turn on the stove to boil the water

behavior __goal__():
    body:
        bind pot: item where:
            is_pot(pot) 
        bind stove: item where:
            is_stove(stove) and on(pot, stove)
        if not observe_pot_for_water(pot):
            bind faucet: item where:
                is_faucet(faucet)
            fill_pot_with_water(pot, faucet)
        boil_the_vegetables(pot, stove)

#goal_representation_end

##############################
Inner TransformationError Debug
Error trying to process rule "function_definition":

Behavior body statements are not allowed in the current mode: SymbolicExecutionMode.DERIVED
##############################
Goal representation after debugging in planning.py
#exp_behavior

behavior find_blender_2032_around_microwave_149(blender:item):
    goal: not unknown(blender)
    body:
        assert is_blender(blender)
        bind microwave_instance:item where:
            is_microwave(microwave_instance) and id[microwave_instance]==149
        achieve close_char(char,microwave_instance)
        if can_open(microwave_instance):
            achieve_once open(microwave_instance)
            exp(blender,microwave_instance)
        else:
            exp(blender,microwave_instance)
    eff:
        unknown[blender]=False
        close[blender,microwave_instance]=True
        close[microwave_instance,blender]=True
    

#goal_representation
 
def observe_pot_for_water(pot:item):
    # Function to check if there is water in the specified pot
    observe(pot, "Check if there is water in the pot")
    symbol has_water_pot=has_water(pot)
    return has_water_pot

behavior fill_pot_with_water(pot:item, faucet:item):
    body:
        achieve_once inhand(pot)
        # Temporarily hold the pot to fill with water
        achieve close_char(char, faucet)
        # Move close to the faucet
        achieve has_water(pot)
        # Fill the pot with water at the faucet

behavior boil_the_vegetables(pot:item, stove:item):
    body:
        achieve on(pot, stove)
        # Ensure the pot is on the stove
        achieve is_on(stove)
        # Turn on the stove to boil the water

behavior __goal__():
    body:
        bind pot: item where:
            is_pot(pot) 
        bind stove: item where:
            is_stove(stove) and on(pot, stove)
        if not observe_pot_for_water(pot):
            bind faucet: item where:
                is_faucet(faucet)
            fill_pot_with_water(pot, faucet)
        boil_the_vegetables(pot, stove)

#goal_representation_end

##############################
Goal representation from planning.py

#exp_behavior

behavior find_cd_2100_around_tablelamp_358(cd:item):
    goal: not unknown(cd)
    body:
        assert is_cd(cd)
        bind tablelamp_instance:item where:
            is_tablelamp(tablelamp_instance) and id[tablelamp_instance]==358
        achieve close_char(char,tablelamp_instance)
        if can_open(tablelamp_instance):
            achieve_once open(tablelamp_instance)
            exp(cd,tablelamp_instance)
        else:
            exp(cd,tablelamp_instance)
    eff:
        unknown[cd]=False
        close[cd,tablelamp_instance]=True
        close[tablelamp_instance,cd]=True
    

behavior find_food_onion_2026_around_cupboard_131(food_onion:item):
    goal: not unknown(food_onion)
    body:
        assert is_food_onion(food_onion)
        bind cupboard_instance:item where:
            is_cupboard(cupboard_instance) and id[cupboard_instance]==131
        achieve close_char(char,cupboard_instance)
        if can_open(cupboard_instance):
            achieve_once open(cupboard_instance)
            exp(food_onion,cupboard_instance)
        else:
            exp(food_onion,cupboard_instance)
    eff:
        unknown[food_onion]=False
        close[food_onion,cupboard_instance]=True
        close[cupboard_instance,food_onion]=True
    

#exp_behavior_end

#goal_representation
 
def check_water_in_pot(pot:item):
    # Function to check if there is water in the specified pot
    symbol has_water=has_water(pot)
    return has_water

behavior add_water_to_pot(pot:item, faucet:item):
    # Behavior to add water to the pot from the faucet
    body:
        achieve close_char(char, faucet) # Move close to the faucet
        achieve_once inhand(pot) # Pick up the pot
        achieve has_water(pot) # Add water to the pot

behavior position_pot_on_stove(pot:item, stove:item):
    # Behavior to position the pot on the stove
    body:
        achieve once close_char(char, stove) # Move close to the stove
        achieve on(pot, stove) # Put the pot on the stove

behavior start_boiling(pot:item, stove:item):
    # Behavior to start boiling the contents of the pot on the stove
    body:
        achieve is_on(stove) # Turn on the stove

behavior __goal__():
    body:
        bind pot: item where:
            is_pot(pot) and on(pot, stove_2090)
        # Select pot on the stove

        bind stove: item where:
            is_stove(stove) and id[stove] == 2090
        # Select the stove with ID 2090

        if not check_water_in_pot(pot):
            # Check if the pot has water
            bind faucet: item where:
                is_faucet(faucet) and id[faucet] == 134
            # Select faucet with ID 134 using found faucets ID
            add_water_to_pot(pot, faucet)
        
        start_boiling(pot, stove) # Begin boiling the water in the pot

#goal_representation_end

##############################
Inner TransformationError Debug
Unexpected token Token('VARNAME', 'close_char') at line 5901, column 22.
Expected one of: 
	* _NEWLINE
	* SEMICOLON

##############################
Goal representation after debugging in planning.py
#exp_behavior

behavior find_blender_2032_around_kitchen_counter_128(blender:item):
    goal: not unknown(blender)
    body:
        assert is_blender(blender)
        bind kitchen_counter_instance:item where:
            is_kitchen_counter(kitchen_counter_instance) and id[kitchen_counter_instance]==128
        achieve close_char(char,kitchen_counter_instance)
        if can_open(kitchen_counter_instance):
            achieve_once open(kitchen_counter_instance)
            exp(blender,kitchen_counter_instance)
        else:
            exp(blender,kitchen_counter_instance)
    eff:
        unknown[blender]=False
        close[blender,kitchen_counter_instance]=True
        close[kitchen_counter_instance,blender]=True
    

behavior find_food_onion_2026_around_cutting_board_2080(food_onion:item):
    goal: not unknown(food_onion)
    body:
        assert is_food_onion(food_onion)
        bind cutting_board_instance:item where:
            is_cutting_board(cutting_board_instance) and id[cutting_board_instance]==2080
        achieve close_char(char,cutting_board_instance)
        if can_open(cutting_board_instance):
            achieve_once open(cutting_board_instance)
            exp(food_onion,cutting_board_instance)
        else:
            exp(food_onion,cutting_board_instance)
    eff:
        unknown[food_onion]=False
        close[food_onion,cutting_board_instance]=True
        close[cutting_board_instance,food_onion]=True
    

behavior find_knife_2036_around_knifeblock_52(knife:item):
    goal: not unknown(knife)
    body:
        assert is_knife(knife)
        bind knifeblock_instance:item where:
            is_knifeblock(knifeblock_instance) and id[knifeblock_instance]==52
        achieve close_char(char,knifeblock_instance)
        if can_open(knifeblock_instance):
            achieve_once open(knifeblock_instance)
            exp(knife,knifeblock_instance)
        else:
            exp(knife,knifeblock_instance)
    eff:
        unknown[knife]=False
        close[knife,knifeblock_instance]=True
        close[knifeblock_instance,knife]=True
    

#goal_representation
 
def check_water_in_pot(pot: item):
    # Function to check if there is water in the specified pot
    symbol has_water = has_water(pot)
    return has_water

behavior add_water_to_pot(pot: item, faucet: item):
    # Behavior to add water to the pot from the faucet
    body:
        achieve_once close_char(char, faucet) # Move close to the faucet
        achieve_once inhand(pot) # Pick up the pot
        achieve_once has_water(pot) # Add water to the pot

behavior position_pot_on_stove(pot: item, stove: item):
    # Behavior to position the pot on the stove
    body:
        achieve_once close_char(char, stove) # Move close to the stove
        achieve_once on(pot, stove) # Put the pot on the stove

behavior start_boiling(pot: item, stove: item):
    # Behavior to start boiling the contents of the pot on the stove
    body:
        achieve is_on(stove) # Turn on the stove

behavior __goal__():
    body:
        bind pot: item where:
            is_pot(pot) and on(pot, stove_2090)
        # Select pot on the stove

        bind stove: item where:
            is_stove(stove) and id[stove] == 2090
        # Select the stove with ID 2090

        if not check_water_in_pot(pot):
            # Check if the pot has water
            bind faucet: item where:
                is_faucet(faucet) and id[faucet] == 134
            # Select faucet with ID 134 using found faucets ID
            add_water_to_pot(pot, faucet)
        
        start_boiling(pot, stove) # Begin boiling the water in the pot

#goal_representation_end

##############################
Inner TransformationError Debug
Error trying to process rule "behavior_definition":

Unknown variable: stove_2090; available variables: [Variable<pot: item>].
##############################
Goal representation after debugging in planning.py
#exp_behavior

behavior find_food_onion_2026_around_bench_124(food_onion:item):
    goal: not unknown(food_onion)
    body:
        assert is_food_onion(food_onion)
        bind bench_instance:item where:
            is_bench(bench_instance) and id[bench_instance]==124
        achieve close_char(char,bench_instance)
        if can_open(bench_instance):
            achieve_once open(bench_instance)
            exp(food_onion,bench_instance)
        else:
            exp(food_onion,bench_instance)
    eff:
        unknown[food_onion]=False
        close[food_onion,bench_instance]=True
        close[bench_instance,food_onion]=True
    

behavior find_knife_2036_around_knifeblock_52(knife:item):
    goal: not unknown(knife)
    body:
        assert is_knife(knife)
        bind knifeblock_instance:item where:
            is_knifeblock(knifeblock_instance) and id[knifeblock_instance]==52
        achieve close_char(char,knifeblock_instance)
        if can_open(knifeblock_instance):
            achieve_once open(knifeblock_instance)
            exp(knife,knifeblock_instance)
        else:
            exp(knife,knifeblock_instance)
    eff:
        unknown[knife]=False
        close[knife,knifeblock_instance]=True
        close[knifeblock_instance,knife]=True
    

#goal_representation
def check_water_in_pot(pot: item):
    # Function to check if there is water in the specified pot
    symbol has_water = has_water(pot)
    return has_water

behavior add_water_to_pot(pot: item, faucet: item):
    # Behavior to add water to the pot from the faucet
    body:
        achieve_once close_char(char, faucet) # Move close to the faucet
        achieve_once inhand(pot) # Pick up the pot
        achieve_once has_water(pot) # Add water to the pot

behavior position_pot_on_stove(pot: item, stove: item):
    # Behavior to position the pot on the stove
    body:
        achieve_once close_char(char, stove) # Move close to the stove
        achieve_once on(pot, stove) # Put the pot on the stove

behavior start_boiling(pot: item, stove: item):
    # Behavior to start boiling the contents of the pot on the stove
    body:
        achieve is_on(stove) # Turn on the stove

behavior __goal__():
    body:
        bind pot: item where:
            is_pot(pot) and on(pot, stove)
        # Select pot on the stove

        bind stove: item where:
            is_stove(stove) and id[stove] == 2090
        # Select the stove with ID 2090

        if not check_water_in_pot(pot):
            # Check if the pot has water
            bind faucet: item where:
                is_faucet(faucet) and id[faucet] == 134
            # Select faucet with ID 134 using found faucets ID
            add_water_to_pot(pot, faucet)
        
        start_boiling(pot, stove) # Begin boiling the water in the pot
#goal_representation_end

##############################
Goal representation from planning.py

#exp_behavior

behavior find_cd_2100_around_computer_379(cd:item):
    goal: not unknown(cd)
    body:
        assert is_cd(cd)
        bind computer_instance:item where:
            is_computer(computer_instance) and id[computer_instance]==379
        achieve close_char(char,computer_instance)
        if can_open(computer_instance):
            achieve_once open(computer_instance)
            exp(cd,computer_instance)
        else:
            exp(cd,computer_instance)
    eff:
        unknown[cd]=False
        close[cd,computer_instance]=True
        close[computer_instance,cd]=True
    

behavior find_blender_2032_around_cupboard_131(blender:item):
    goal: not unknown(blender)
    body:
        assert is_blender(blender)
        bind cupboard_instance:item where:
            is_cupboard(cupboard_instance) and id[cupboard_instance]==131
        achieve close_char(char,cupboard_instance)
        if can_open(cupboard_instance):
            achieve_once open(cupboard_instance)
            exp(blender,cupboard_instance)
        else:
            exp(blender,cupboard_instance)
    eff:
        unknown[blender]=False
        close[blender,cupboard_instance]=True
        close[cupboard_instance,blender]=True
    

#exp_behavior_end

#goal_representation
 
def has_water_in_pot(pot:item):
    # Function to check if the pot has water
    symbol contains_water = exists o: item : (has_water(o) and inside(o, pot))
    return contains_water

behavior boil_vegetables(pot:item, stove:item):
    body:
        achieve is_on(stove)
        # Ensure the stove is turned on
        achieve has_water(pot)
        # Ensure the pot has water
        achieve_on(pot, stove)
        # Ensure the pot is placed on the stove

behavior __goal__():
    body:
        bind pot: item where:
            is_pot(pot) and on(pot, stove)
        # Select the placed pot on the stove
        
        bind stove: item where:
            is_stove(stove)

        if not has_water_in_pot(pot):
            # If the pot does not already contain water, observe to verify
            observe(pot, "Check if there is water in the pot")

        boil_vegetables(pot, stove)
        # Call the behavior to boil the vegetables in the pot

#goal_representation_end

##############################
Inner TransformationError Debug
Error trying to process rule "behavior_definition":

'Function achieve_on not found. Note that recursive function calls are not supported in the current version.'
##############################
Goal representation after debugging in planning.py
#exp_behavior

behavior find_cd_2100_around_computer_379(cd:item):
    goal: not unknown(cd)
    body:
        assert is_cd(cd)
        bind computer_instance:item where:
            is_computer(computer_instance) and id[computer_instance]==379
        achieve close_char(char,computer_instance)
        if can_open(computer_instance):
            achieve_once open(computer_instance)
            exp(cd,computer_instance)
        else:
            exp(cd,computer_instance)
    eff:
        unknown[cd]=False
        close[cd,computer_instance]=True
        close[computer_instance,cd]=True
    

behavior find_blender_2032_around_kitchen_counter_128(blender:item):
    goal: not unknown(blender)
    body:
        assert is_blender(blender)
        bind kitchen_counter_instance:item where:
            is_kitchen_counter(kitchen_counter_instance) and id[kitchen_counter_instance]==128
        achieve close_char(char,kitchen_counter_instance)
        if can_open(kitchen_counter_instance):
            achieve_once open(kitchen_counter_instance)
            exp(blender,kitchen_counter_instance)
        else:
            exp(blender,kitchen_counter_instance)
    eff:
        unknown[blender]=False
        close[blender,kitchen_counter_instance]=True
        close[kitchen_counter_instance,blender]=True
    

#goal_representation
 
def has_water_in_pot(pot:item):
    # Function to check if the pot has water
    symbol contains_water = exists o: item : (has_water(o) and inside(o, pot))
    return contains_water

behavior boil_vegetables(pot:item, stove:item):
    body:
        achieve is_on(stove)
        # Ensure the stove is turned on
        achieve has_water(pot)
        # Ensure the pot has water
        achieve on(pot, stove)
        # Ensure the pot is placed on the stove

behavior __goal__():
    body:
        bind pot: item where:
            is_pot(pot) and on(pot, stove)
        # Select the placed pot on the stove
        
        bind stove: item where:
            is_stove(stove)

        if not has_water_in_pot(pot):
            # If the pot does not already contain water, observe to verify
            observe(pot, "Check if there is water in the pot")

        boil_vegetables(pot, stove)
        # Call the behavior to boil the vegetables in the pot

#goal_representation_end

##############################
Inner TransformationError Debug
Error trying to process rule "behavior_definition":

Unknown variable: stove; available variables: [Variable<pot: item>].
##############################
Goal representation after debugging in planning.py
#exp_behavior

behavior find_oil_2005_around_cupboard_131(oil:item):
    goal: not unknown(oil)
    body:
        assert is_oil(oil)
        bind cupboard_instance:item where:
            is_cupboard(cupboard_instance) and id[cupboard_instance]==131
        achieve close_char(char,cupboard_instance)
        if can_open(cupboard_instance):
            achieve_once open(cupboard_instance)
            exp(oil,cupboard_instance)
        else:
            exp(oil,cupboard_instance)
    eff:
        unknown[oil]=False
        close[oil,cupboard_instance]=True
        close[cupboard_instance,oil]=True
    

#goal_representation
 
def has_water_in_pot(pot:item):
    # Function to check if the pot has water
    symbol contains_water = exists o: item : (has_water(o) and inside(o, pot))
    return contains_water

behavior boil_vegetables(pot:item, stove:item):
    body:
        achieve is_on(stove)
        # Ensure the stove is turned on
        achieve has_water(pot)
        # Ensure the pot has water
        achieve on(pot, stove)
        # Ensure the pot is placed on the stove

behavior __goal__():
    body:
        bind pot: item where:
            is_pot(pot)

        bind stove: item where:
            is_stove(stove)

        if not has_water_in_pot(pot):
            # If the pot does not already contain water, observe to verify
            observe(pot, "Check if there is water in the pot")

        boil_vegetables(pot, stove)
        # Call the behavior to boil the vegetables in the pot

#goal_representation_end

##############################
From agent.py->reset_sub_goal
 
def has_water_in_pot(pot:item):
    # Function to check if the pot has water
    symbol contains_water = exists o: item : (has_water(o) and inside(o, pot))
    return contains_water

behavior boil_vegetables(pot:item, stove:item):
    body:
        achieve is_on(stove)
        # Ensure the stove is turned on
        achieve has_water(pot)
        # Ensure the pot has water
        achieve on(pot, stove)
        # Ensure the pot is placed on the stove

behavior __goal__():
    body:
        bind pot: item where:
            is_pot(pot)

        bind stove: item where:
            is_stove(stove)

        if not has_water_in_pot(pot):
            # If the pot does not already contain water, observe to verify
            observe(pot, "Check if there is water in the pot")

        boil_vegetables(pot, stove)
        # Call the behavior to boil the vegetables in the pot

##############################
From agent.py-> find a plan in act()
obs(pot_54, Check if there is water in the pot)
##############################
From agent.py
obs(pot_54, Check if there is water in the pot)
Get this information:  pot_54 is on stove_2090. pot_54 is close to stove_2090. pot_54 is close to character_219. pot_54 is close to food_vegetable_2072. food_vegetable_2072 is inside pot_54. pot_54 is inside dining_room_1. pot_54 is OPEN. pot_54 is CLEAN.
##############################
From agent.py -> evaluate_current_subgoal()
The evaluation result for current subgoal: No
The feedback instruction: You need to ensure that there is water in the pot to boil the vegetables effectively. The current observations indicate that there is food_vegetable_2072 inside pot_54, but no information confirms the presence of water in the pot. You should fill pot_54 with water by switching the faucet on while holding pot_54 under it, then switch off the faucet before placing the pot back on the stove to boil the vegetables.
##############################
Task Summary:
Task Goal:
Boil vegetables with a pot on the stove.
Action History:
['walk_executor(kitchen_counter_132)', 'walk_executor(pot_54)', 'open_executor(pot_54)', 'grab_executor(pot_54)', 'walk_executor(stove_2090)', 'put_executor(pot_54, stove_2090)', 'grab_executor(pot_54)', 'walk_executor(faucet_134)', 'switchoff_executor(faucet_134)', 'walk_executor(fridge_140)', 'switchoff_executor(fridge_140)', 'open_executor(fridge_140)', 'walk_executor(faucet_134)', 'switchon_executor(faucet_134)', 'switchoff_executor(faucet_134)', 'walk_executor(stove_2090)', 'switchon_executor(stove_2090)', 'put_executor(pot_54, stove_2090)', 'walk_executor(food_vegetable_2072)', 'grab_executor(food_vegetable_2072)', 'walk_executor(pot_54)', 'putin_executor(food_vegetable_2072, pot_54)']
Time info:
Time consume: 327 seconds
Exp_helper query times: 0
Guidance query times: 0
library scale: 44
goal generate times: 10
goal correct times: 4
action_num: 22

Task complete rate:
Keystate: k1 - Requires: 6 steps
Keystate: k2 - Requires: 5 steps
Action Completion Rate: 1.0
Scene_id: 2
##############################
