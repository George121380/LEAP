From agent.py
Reset goals: The sub-goals are: 
['1. Locate a pot and fill it with water.', '2. Place the pot on the stove and bring the water to a boil.', '3. Once boiling, add the vegetables to the pot.']
##############################
Goal representation from planning.py

#exp_behavior

behavior find_knife_2050_around_cupboard_229(knife:item):
    goal: not unknown(knife)
    body:
        assert is_knife(knife)
        bind cupboard_instance:item where:
            is_cupboard(cupboard_instance) and id[cupboard_instance]==229
        achieve close_char(char,cupboard_instance)
        if can_open(cupboard_instance):
            achieve_once open(cupboard_instance)
            exp(knife,cupboard_instance)
        else:
            exp(knife,cupboard_instance)
    eff:
        unknown[knife]=False
        close[knife,cupboard_instance]=True
        close[cupboard_instance,knife]=True
    

behavior find_pot_2069_around_cupboard_229(pot:item):
    goal: not unknown(pot)
    body:
        assert is_pot(pot)
        bind cupboard_instance:item where:
            is_cupboard(cupboard_instance) and id[cupboard_instance]==229
        achieve close_char(char,cupboard_instance)
        if can_open(cupboard_instance):
            achieve_once open(cupboard_instance)
            exp(pot,cupboard_instance)
        else:
            exp(pot,cupboard_instance)
    eff:
        unknown[pot]=False
        close[pot,cupboard_instance]=True
        close[cupboard_instance,pot]=True
    

#exp_behavior_end

#goal_representation
 
def has_pot_with_water(pot:item):
    # Function to check if the pot has water
    symbol has_water_content=has_water(pot)
    return has_water_content

behavior fill_pot_with_water(pot:item, faucet:item, sink:item):
    body:
        achieve_once inhand(pot)
        # Hold the pot to carry to sink for filling with water

        achieve_once inside(pot, sink)
        # Place the pot inside the sink

        if is_faucet(faucet) and close(faucet, sink):
            achieve_once is_on(faucet)
            # Turn on the faucet to fill the pot
            achieve has_water(pot)
            # Ensure pot has water

            achieve_once is_off(faucet)
            # Turn off the faucet

behavior __goal__():
    body:
        # Locate a pot
        bind pot: item where:
            is_pot(pot) and not has_pot_with_water(pot)
        # Locate a sink and faucet for filling
        bind sink: item where:
            is_sink(sink)
        bind faucet: item where:
            is_faucet(faucet) and close(faucet, sink)
        
        fill_pot_with_water(pot, faucet, sink)


#goal_representation_end

##############################
From agent.py->reset_goal
 
def has_pot_with_water(pot:item):
    # Function to check if the pot has water
    symbol has_water_content=has_water(pot)
    return has_water_content

behavior fill_pot_with_water(pot:item, faucet:item, sink:item):
    body:
        achieve_once inhand(pot)
        # Hold the pot to carry to sink for filling with water

        achieve_once inside(pot, sink)
        # Place the pot inside the sink

        if is_faucet(faucet) and close(faucet, sink):
            achieve_once is_on(faucet)
            # Turn on the faucet to fill the pot
            achieve has_water(pot)
            # Ensure pot has water

            achieve_once is_off(faucet)
            # Turn off the faucet

behavior __goal__():
    body:
        # Locate a pot
        bind pot: item where:
            is_pot(pot) and not has_pot_with_water(pot)
        # Locate a sink and faucet for filling
        bind sink: item where:
            is_sink(sink)
        bind faucet: item where:
            is_faucet(faucet) and close(faucet, sink)
        
        fill_pot_with_water(pot, faucet, sink)


##############################
From agent.py-> find a plan in act()
walk_executor(cupboard_229)open_executor(cupboard_229)exp(pot_2069, cupboard_229)walk_executor(pot_2069)grab_executor(pot_2069)walk_executor(sink_42)putin_executor(pot_2069, sink_42)walk_executor(faucet_43)switchon_executor(faucet_43)walk_executor(pot_2069)open_executor(pot_2069)grab_executor(pot_2069)walk_executor(faucet_43)switchoff_executor(faucet_43)
##############################
From agent.py
walk_executor(cupboard_229)
Robot find: Robot is close to the cupboard_229. 
##############################
From agent.py
open_executor(cupboard_229)
Robot find: Robot is close to the cupboard_229. cupboard_229 is opened. 
##############################
From agent.py
exp(pot_2069, cupboard_229)
Fail to find pot_2069 around cupboard_229. 
##############################
From agent.py-> find a plan in act()
walk_executor(oven_295)open_executor(oven_295)exp(pot_2069, oven_295)walk_executor(pot_2069)grab_executor(pot_2069)walk_executor(sink_42)putin_executor(pot_2069, sink_42)walk_executor(faucet_43)switchon_executor(faucet_43)walk_executor(pot_2069)open_executor(pot_2069)grab_executor(pot_2069)walk_executor(faucet_43)switchoff_executor(faucet_43)
##############################
From agent.py
walk_executor(oven_295)
Robot find: drawing_240, drawing_238, drawing_239, Robot is close to the oven_295. 
##############################
From agent.py
open_executor(oven_295)
Robot find: tray_296, Robot is close to the tray_296. Robot is close to the oven_295. oven_295 is opened. 
##############################
From agent.py
exp(pot_2069, oven_295)
Fail to find pot_2069 around oven_295. 
##############################
From agent.py-> find a plan in act()
walk_executor(stove_2065)open_executor(stove_2065)exp(pot_2069, stove_2065)walk_executor(pot_2069)grab_executor(pot_2069)walk_executor(sink_42)putin_executor(pot_2069, sink_42)walk_executor(faucet_43)switchon_executor(faucet_43)walk_executor(pot_2069)open_executor(pot_2069)grab_executor(pot_2069)walk_executor(faucet_43)switchoff_executor(faucet_43)
##############################
From agent.py
walk_executor(stove_2065)
Robot find: cutting_board_2051, drawing_241, drawing_242, drawing_243, napkin_2005, oil_2079, cup_2063, knife_2050, cup_2064, pot_2069, fryingpan_2083, Robot is close to the stove_2065. Robot is close to the kitchen_counter_230. 
##############################
From agent.py
open_executor(stove_2065)
Robot find: Robot is close to the stove_2065. Robot is close to the kitchen_counter_230. stove_2065 is opened. 
##############################
From agent.py
exp(pot_2069, stove_2065)
Find pot_2069. 
##############################
From agent.py-> find a plan in act()
walk_executor(pot_2069)grab_executor(pot_2069)walk_executor(sink_42)putin_executor(pot_2069, sink_42)walk_executor(faucet_43)switchon_executor(faucet_43)walk_executor(pot_2069)open_executor(pot_2069)grab_executor(pot_2069)walk_executor(faucet_43)switchoff_executor(faucet_43)
##############################
From agent.py
walk_executor(pot_2069)
Robot find: Robot is close to the kitchen_counter_230. Robot is close to the pot_2069. 
##############################
From agent.py
grab_executor(pot_2069)
Robot find: Robot is close to the kitchen_counter_230. Robot is close to the pot_2069. Grabbing pot_2069 by right hand. 
##############################
From agent.py
walk_executor(sink_42)
Robot find: detergent_2084, cleaning_solution_2073, towel_rack_31, soap_2053, basket_for_clothes_2006, towel_rack_32, towel_rack_34, Robot is close to the pot_2069. Robot is close to the bathroom_counter_41. Robot is close to the sink_42. 
##############################
From agent.py
putin_executor(pot_2069, sink_42)
Robot find: Robot is close to the pot_2069. Robot is close to the bathroom_counter_41. Robot is close to the sink_42. pot_2069 is inside sink_42. pot_2069 is close sink_42. sink_42 is close pot_2069. pot_2069 released by right hand. 
##############################
From agent.py
walk_executor(faucet_43)
Robot find: Robot is close to the bathroom_counter_41. Robot is close to the faucet_43. 
##############################
From agent.py
switchon_executor(faucet_43)
Robot find: Robot is close to the bathroom_counter_41. Robot is close to the faucet_43. faucet_43 is turned on. 
##############################
From agent.py
walk_executor(pot_2069)
Robot find: Robot is close to the sink_42. Robot is close to the pot_2069. 
##############################
From agent.py
open_executor(pot_2069)
Robot find: Robot is close to the sink_42. Robot is close to the pot_2069. pot_2069 is opened. 
##############################
From agent.py
grab_executor(pot_2069)
Robot find: Robot is close to the sink_42. Robot is close to the pot_2069. Grabbing pot_2069 by right hand. 
##############################
From agent.py
walk_executor(faucet_43)
Robot find: Robot is close to the pot_2069. Robot is close to the bathroom_counter_41. Robot is close to the faucet_43. 
##############################
From agent.py
switchoff_executor(faucet_43)
Robot find: Robot is close to the pot_2069. Robot is close to the bathroom_counter_41. Robot is close to the faucet_43. faucet_43 is turned off. 
##############################
From agent.py -> evaluate_current_subgoal()
The evaluation result for current subgoal: Yes
The feedback instruction: None
##############################
Goal representation from planning.py

#exp_behavior

behavior find_food_bacon_2010_around_fridge_289(food_bacon:item):
    goal: not unknown(food_bacon)
    body:
        assert is_food_bacon(food_bacon)
        bind fridge_instance:item where:
            is_fridge(fridge_instance) and id[fridge_instance]==289
        achieve close_char(char,fridge_instance)
        if can_open(fridge_instance):
            achieve_once open(fridge_instance)
            exp(food_bacon,fridge_instance)
        else:
            exp(food_bacon,fridge_instance)
    eff:
        unknown[food_bacon]=False
        close[food_bacon,fridge_instance]=True
        close[fridge_instance,food_bacon]=True
    

behavior find_cat_2055_around_basket_for_clothes_2006(cat:item):
    goal: not unknown(cat)
    body:
        assert is_cat(cat)
        bind basket_for_clothes_instance:item where:
            is_basket_for_clothes(basket_for_clothes_instance) and id[basket_for_clothes_instance]==2006
        achieve close_char(char,basket_for_clothes_instance)
        if can_open(basket_for_clothes_instance):
            achieve_once open(basket_for_clothes_instance)
            exp(cat,basket_for_clothes_instance)
        else:
            exp(cat,basket_for_clothes_instance)
    eff:
        unknown[cat]=False
        close[cat,basket_for_clothes_instance]=True
        close[basket_for_clothes_instance,cat]=True
    

#exp_behavior_end

#goal_representation
 
behavior place_pot_on_stove_and_boil_water(pot:item, stove:item):
    body:
        achieve on(pot, stove)
        # Place the pot on the stove
        achieve is_on(stove)
        # Turn on the stove to boil the water

behavior __goal__():
    body:
        bind stove: item where:
            is_stove(stove) and id[stove]==2065
        # Select the stove with ID 2065

        bind pot: item where:
            is_pot(pot) and id[pot]==2069
        # Select the pot with ID 2069

        place_pot_on_stove_and_boil_water(pot, stove)

#goal_representation_end

##############################
From agent.py->reset_sub_goal
 
behavior place_pot_on_stove_and_boil_water(pot:item, stove:item):
    body:
        achieve on(pot, stove)
        # Place the pot on the stove
        achieve is_on(stove)
        # Turn on the stove to boil the water

behavior __goal__():
    body:
        bind stove: item where:
            is_stove(stove) and id[stove]==2065
        # Select the stove with ID 2065

        bind pot: item where:
            is_pot(pot) and id[pot]==2069
        # Select the pot with ID 2069

        place_pot_on_stove_and_boil_water(pot, stove)

##############################
From agent.py-> find a plan in act()
walk_executor(stove_2065)put_executor(pot_2069, stove_2065)switchon_executor(stove_2065)
##############################
From agent.py
walk_executor(stove_2065)
Robot find: Robot is close to the pot_2069. Robot is close to the stove_2065. Robot is close to the kitchen_counter_230. 
##############################
From agent.py
put_executor(pot_2069, stove_2065)
Robot find: Robot is close to the pot_2069. Robot is close to the stove_2065. Robot is close to the kitchen_counter_230. pot_2069 is close stove_2065. pot_2069 is on stove_2065. stove_2065 is close pot_2069. pot_2069 released by right hand. 
##############################
From agent.py
switchon_executor(stove_2065)
Robot find: Robot is close to the pot_2069. Robot is close to the stove_2065. Robot is close to the kitchen_counter_230. stove_2065 is turned on. 
##############################
From agent.py -> evaluate_current_subgoal()
The evaluation result for current subgoal: Yes
The feedback instruction: None
##############################
Goal representation from planning.py

#exp_behavior

behavior find_food_vegetable_2041_around_fridge_289(food_vegetable:item):
    goal: not unknown(food_vegetable)
    body:
        assert is_food_vegetable(food_vegetable)
        bind fridge_instance:item where:
            is_fridge(fridge_instance) and id[fridge_instance]==289
        achieve close_char(char,fridge_instance)
        if can_open(fridge_instance):
            achieve_once open(fridge_instance)
            exp(food_vegetable,fridge_instance)
        else:
            exp(food_vegetable,fridge_instance)
    eff:
        unknown[food_vegetable]=False
        close[food_vegetable,fridge_instance]=True
        close[fridge_instance,food_vegetable]=True
    

behavior find_food_carrot_2014_around_fridge_289(food_carrot:item):
    goal: not unknown(food_carrot)
    body:
        assert is_food_carrot(food_carrot)
        bind fridge_instance:item where:
            is_fridge(fridge_instance) and id[fridge_instance]==289
        achieve close_char(char,fridge_instance)
        if can_open(fridge_instance):
            achieve_once open(fridge_instance)
            exp(food_carrot,fridge_instance)
        else:
            exp(food_carrot,fridge_instance)
    eff:
        unknown[food_carrot]=False
        close[food_carrot,fridge_instance]=True
        close[fridge_instance,food_carrot]=True
    

#exp_behavior_end

#goal_representation
 
def has_water_in_pot(pot: item):
    # Function to check if there is water in the pot
    symbol water_inside=has_water(pot)
    return water_inside

behavior add_vegetables_to_pot(vegetables: item, pot: item):
    body:
        achieve inside(vegetables, pot)
        # Ensure vegetables are placed inside the pot

behavior __goal__():
    body:
        bind pot: item where:
            is_pot(pot) and has_water_in_pot(pot)
        # Select the pot that contains water

        bind vegetables: item where:
            is_food_vegetable(vegetables)
        # Select vegetables

        add_vegetables_to_pot(vegetables, pot)
 
#goal_representation_end

##############################
Error is:
'NoneType' object is not iterable
##############################
Goal representation from planning.py

#exp_behavior

behavior find_food_vegetable_2041_around_fridge_289(food_vegetable:item):
    goal: not unknown(food_vegetable)
    body:
        assert is_food_vegetable(food_vegetable)
        bind fridge_instance:item where:
            is_fridge(fridge_instance) and id[fridge_instance]==289
        achieve close_char(char,fridge_instance)
        if can_open(fridge_instance):
            achieve_once open(fridge_instance)
            exp(food_vegetable,fridge_instance)
        else:
            exp(food_vegetable,fridge_instance)
    eff:
        unknown[food_vegetable]=False
        close[food_vegetable,fridge_instance]=True
        close[fridge_instance,food_vegetable]=True
    

#exp_behavior_end

#goal_representation
 
behavior add_vegetables_to_boiling_water(vegetables:item, pot:item):
    body:
        achieve inside(vegetables, pot)
        # This behavior ensures that the vegetables are added to the boiling water inside the pot

behavior __goal__():
    body:
        bind pot: item where:
            is_pot(pot) and on(pot, stove_2065)
        # Select the pot on the stove

        bind vegetables: item where:
            is_food_vegetable(vegetables)
        # Select the vegetables to be boiled

        if has_water(pot):
            # Ensure water is present in the pot before adding vegetables
            add_vegetables_to_boiling_water(vegetables, pot)
 
#goal_representation_end

##############################
Inner TransformationError Debug
Error trying to process rule "behavior_definition":

Unknown variable: stove_2065; available variables: [Variable<pot: item>].
##############################
Goal representation after debugging in planning.py
#exp_behavior

behavior find_food_vegetable_2041_around_fridge_289(food_vegetable:item):
    goal: not unknown(food_vegetable)
    body:
        assert is_food_vegetable(food_vegetable)
        bind fridge_instance:item where:
            is_fridge(fridge_instance) and id[fridge_instance]==289
        achieve close_char(char,fridge_instance)
        if can_open(fridge_instance):
            achieve_once open(fridge_instance)
            exp(food_vegetable,fridge_instance)
        else:
            exp(food_vegetable,fridge_instance)
    eff:
        unknown[food_vegetable]=False
        close[food_vegetable,fridge_instance]=True
        close[fridge_instance,food_vegetable]=True
    

#goal_representation
 
behavior add_vegetables_to_boiling_water(vegetables:item, pot:item):
    body:
        achieve inside(vegetables, pot)
        # This behavior ensures that the vegetables are added to the boiling water inside the pot

behavior __goal__():
    body:
        bind pot: item where:
            is_pot(pot) and on(pot, stove)
        # Select the pot that is on any stove (corrected from a specific stove ID)

        bind vegetables: item where:
            is_food_vegetable(vegetables)
        # Select the vegetables to be boiled

        if has_water(pot):
            # Ensure water is present in the pot before adding vegetables
            add_vegetables_to_boiling_water(vegetables, pot)

#goal_representation_end

##############################
Inner TransformationError Debug
Error trying to process rule "behavior_definition":

Unknown variable: stove; available variables: [Variable<pot: item>].
##############################
Goal representation after debugging in planning.py
#exp_behavior

behavior find_food_vegetable_2041_around_fridge_289(food_vegetable:item):
    goal: not unknown(food_vegetable)
    body:
        assert is_food_vegetable(food_vegetable)
        bind fridge_instance:item where:
            is_fridge(fridge_instance) and id[fridge_instance]==289
        achieve close_char(char,fridge_instance)
        if can_open(fridge_instance):
            achieve_once open(fridge_instance)
            exp(food_vegetable,fridge_instance)
        else:
            exp(food_vegetable,fridge_instance)
    eff:
        unknown[food_vegetable]=False
        close[food_vegetable,fridge_instance]=True
        close[fridge_instance,food_vegetable]=True
    

behavior find_food_carrot_2014_around_fridge_289(food_carrot:item):
    goal: not unknown(food_carrot)
    body:
        assert is_food_carrot(food_carrot)
        bind fridge_instance:item where:
            is_fridge(fridge_instance) and id[fridge_instance]==289
        achieve close_char(char,fridge_instance)
        if can_open(fridge_instance):
            achieve_once open(fridge_instance)
            exp(food_carrot,fridge_instance)
        else:
            exp(food_carrot,fridge_instance)
    eff:
        unknown[food_carrot]=False
        close[food_carrot,fridge_instance]=True
        close[fridge_instance,food_carrot]=True
    

#goal_representation
behavior add_vegetables_to_boiling_water(vegetables:item, pot:item):
    body:
        achieve inside(vegetables, pot)
        # This behavior ensures that the vegetables are added to the boiling water inside the pot

behavior __goal__():
    body:
        bind pot: item where:
            is_pot(pot) and exists stove: item : is_stove(stove) and on(pot, stove)
        # Select the pot that is on any stove
        
        bind vegetables: item where:
            is_food_vegetable(vegetables)
        # Select the vegetables to be boiled

        if has_water(pot):
            # Ensure water is present in the pot before adding vegetables
            add_vegetables_to_boiling_water(vegetables, pot)
#goal_representation_end

##############################
Goal representation from planning.py

#exp_behavior

behavior find_food_vegetable_2041_around_fridge_289(food_vegetable:item):
    goal: not unknown(food_vegetable)
    body:
        assert is_food_vegetable(food_vegetable)
        bind fridge_instance:item where:
            is_fridge(fridge_instance) and id[fridge_instance]==289
        achieve close_char(char,fridge_instance)
        if can_open(fridge_instance):
            achieve_once open(fridge_instance)
            exp(food_vegetable,fridge_instance)
        else:
            exp(food_vegetable,fridge_instance)
    eff:
        unknown[food_vegetable]=False
        close[food_vegetable,fridge_instance]=True
        close[fridge_instance,food_vegetable]=True
    

behavior find_food_potato_2035_around_fridge_289(food_potato:item):
    goal: not unknown(food_potato)
    body:
        assert is_food_potato(food_potato)
        bind fridge_instance:item where:
            is_fridge(fridge_instance) and id[fridge_instance]==289
        achieve close_char(char,fridge_instance)
        if can_open(fridge_instance):
            achieve_once open(fridge_instance)
            exp(food_potato,fridge_instance)
        else:
            exp(food_potato,fridge_instance)
    eff:
        unknown[food_potato]=False
        close[food_potato,fridge_instance]=True
        close[fridge_instance,food_potato]=True
    

behavior find_food_carrot_2014_around_fridge_289(food_carrot:item):
    goal: not unknown(food_carrot)
    body:
        assert is_food_carrot(food_carrot)
        bind fridge_instance:item where:
            is_fridge(fridge_instance) and id[fridge_instance]==289
        achieve close_char(char,fridge_instance)
        if can_open(fridge_instance):
            achieve_once open(fridge_instance)
            exp(food_carrot,fridge_instance)
        else:
            exp(food_carrot,fridge_instance)
    eff:
        unknown[food_carrot]=False
        close[food_carrot,fridge_instance]=True
        close[fridge_instance,food_carrot]=True
    

#exp_behavior_end

#goal_representation
 
def has_vegetables():
    # Function to check if there are vegetables known
    symbol has_items=exists o: item : is_food_vegetable(o)
    return has_items

behavior add_vegetables_to_pot(vegetable:item, pot:item):
    body:
        achieve inside(vegetable, pot) # Place the vegetable inside the pot

behavior __goal__():
    body:
        if has_vegetables():
            # If there are known vegetables, add them to the pot
            bind pot: item where:
                is_pot(pot) and on(pot, stove_2065)
            foreach vegetable: item:
                if is_food_vegetable(vegetable):
                    add_vegetables_to_pot(vegetable, pot)
        else:
            # If no vegetables are known, locate them and then add to the pot
            foreach o: item:
                if is_food_vegetable(o) and not visited(o):
                    observe(o, "Locate vegetables to add to the pot")

#goal_representation_end

##############################
Inner TransformationError Debug
Error trying to process rule "behavior_definition":

Unknown variable: stove_2065; available variables: [Variable<pot: item>].
##############################
Goal representation after debugging in planning.py
#exp_behavior

behavior find_food_vegetable_2041_around_fridge_289(food_vegetable:item):
    goal: not unknown(food_vegetable)
    body:
        assert is_food_vegetable(food_vegetable)
        bind fridge_instance:item where:
            is_fridge(fridge_instance) and id[fridge_instance]==289
        achieve close_char(char,fridge_instance)
        if can_open(fridge_instance):
            achieve_once open(fridge_instance)
            exp(food_vegetable,fridge_instance)
        else:
            exp(food_vegetable,fridge_instance)
    eff:
        unknown[food_vegetable]=False
        close[food_vegetable,fridge_instance]=True
        close[fridge_instance,food_vegetable]=True
    

behavior find_food_carrot_2014_around_fridge_289(food_carrot:item):
    goal: not unknown(food_carrot)
    body:
        assert is_food_carrot(food_carrot)
        bind fridge_instance:item where:
            is_fridge(fridge_instance) and id[fridge_instance]==289
        achieve close_char(char,fridge_instance)
        if can_open(fridge_instance):
            achieve_once open(fridge_instance)
            exp(food_carrot,fridge_instance)
        else:
            exp(food_carrot,fridge_instance)
    eff:
        unknown[food_carrot]=False
        close[food_carrot,fridge_instance]=True
        close[fridge_instance,food_carrot]=True
    

behavior find_food_onion_2032_around_fridge_289(food_onion:item):
    goal: not unknown(food_onion)
    body:
        assert is_food_onion(food_onion)
        bind fridge_instance:item where:
            is_fridge(fridge_instance) and id[fridge_instance]==289
        achieve close_char(char,fridge_instance)
        if can_open(fridge_instance):
            achieve_once open(fridge_instance)
            exp(food_onion,fridge_instance)
        else:
            exp(food_onion,fridge_instance)
    eff:
        unknown[food_onion]=False
        close[food_onion,fridge_instance]=True
        close[fridge_instance,food_onion]=True
    

behavior find_food_potato_2035_around_fridge_289(food_potato:item):
    goal: not unknown(food_potato)
    body:
        assert is_food_potato(food_potato)
        bind fridge_instance:item where:
            is_fridge(fridge_instance) and id[fridge_instance]==289
        achieve close_char(char,fridge_instance)
        if can_open(fridge_instance):
            achieve_once open(fridge_instance)
            exp(food_potato,fridge_instance)
        else:
            exp(food_potato,fridge_instance)
    eff:
        unknown[food_potato]=False
        close[food_potato,fridge_instance]=True
        close[fridge_instance,food_potato]=True
    

#goal_representation
 
def has_vegetables():
    # Function to check if there are vegetables known
    symbol has_items=exists o: item : is_food_vegetable(o)
    return has_items

behavior add_vegetables_to_pot(vegetable:item, pot:item):
    body:
        achieve inside(vegetable, pot) # Place the vegetable inside the pot

behavior __goal__():
    body:
        if has_vegetables():
            # If there are known vegetables, add them to the pot
            bind pot: item where:
                is_pot(pot) and exists stove: item : is_stove(stove) and id[stove] == 2065 and on(pot, stove)
            foreach vegetable: item:
                if is_food_vegetable(vegetable):
                    add_vegetables_to_pot(vegetable, pot)
        else:
            # If no vegetables are known, locate them and then add to the pot
            foreach o: item:
                if is_food_vegetable(o) and not visited(o):
                    observe(o, "Locate vegetables to add to the pot")

#goal_representation_end

##############################
Inner TransformationError Debug
Unexpected token Token('VARNAME', 'stove') at line 5779, column 40.
Expected one of: 
	* _NEWLINE
	* SEMICOLON
	* COMMA

##############################
Goal representation after debugging in planning.py
#exp_behavior

behavior find_food_vegetable_2041_around_fridge_289(food_vegetable:item):
    goal: not unknown(food_vegetable)
    body:
        assert is_food_vegetable(food_vegetable)
        bind fridge_instance:item where:
            is_fridge(fridge_instance) and id[fridge_instance]==289
        achieve close_char(char,fridge_instance)
        if can_open(fridge_instance):
            achieve_once open(fridge_instance)
            exp(food_vegetable,fridge_instance)
        else:
            exp(food_vegetable,fridge_instance)
    eff:
        unknown[food_vegetable]=False
        close[food_vegetable,fridge_instance]=True
        close[fridge_instance,food_vegetable]=True
    

#goal_representation
 
def has_vegetables():
    # Function to check if there are vegetables known
    symbol has_items=exists o: item : is_food_vegetable(o)
    return has_items

behavior add_vegetables_to_pot(vegetable:item, pot:item):
    body:
        achieve inside(vegetable, pot) # Place the vegetable inside the pot

behavior __goal__():
    body:
        if has_vegetables():
            # If there are known vegetables, add them to the pot
            bind pot: item where:
                is_pot(pot) and exists stove: item : is_stove(stove) and id[stove] == 2065 and on(pot, stove)
            foreach vegetable: item:
                if is_food_vegetable(vegetable):
                    add_vegetables_to_pot(vegetable, pot)
        else:
            # If no vegetables are known, locate them and then add to the pot
            foreach o: item:
                if is_food_vegetable(o) and not visited(o):
                    observe(o, "Locate vegetables to add to the pot")

#goal_representation_end

##############################
VH_pipeline: Fail to generate a valid plan
##############################
Error record: Error during problem transformation
##############################
Task Summary:
Task Goal:
Syntax Error
Action History:
['walk_executor(cupboard_229)', 'open_executor(cupboard_229)', 'walk_executor(oven_295)', 'open_executor(oven_295)', 'walk_executor(stove_2065)', 'open_executor(stove_2065)', 'walk_executor(pot_2069)', 'grab_executor(pot_2069)', 'walk_executor(sink_42)', 'putin_executor(pot_2069, sink_42)', 'walk_executor(faucet_43)', 'switchon_executor(faucet_43)', 'walk_executor(pot_2069)', 'open_executor(pot_2069)', 'grab_executor(pot_2069)', 'walk_executor(faucet_43)', 'switchoff_executor(faucet_43)', 'walk_executor(stove_2065)', 'put_executor(pot_2069, stove_2065)', 'switchon_executor(stove_2065)']
Time info:
Time consume: 167 seconds
Exp_helper query times: 0
Guidance query times: 0
library scale: 23
goal generate times: 5
goal correct times: 2

Task complete rate:
Keystate: k1 - Requires: 19 steps
Keystate: k2 - Requires: 10 steps
Action Completion Rate: 1.0
Scene_id: 0
##############################
