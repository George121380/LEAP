From agent.py
Reset goals: The sub-goals are: 
['Slice the bread and toast it.']
##############################
Goal representation from planning.py

#exp_behavior

behavior find_knife_2050_around_kitchen_counter_230(knife:item):
    goal: not unknown(knife)
    body:
        assert is_knife(knife)
        bind kitchen_counter_instance:item where:
            is_kitchen_counter(kitchen_counter_instance) and id[kitchen_counter_instance]==230
        achieve close_char(char,kitchen_counter_instance)
        if can_open(kitchen_counter_instance):
            achieve_once open(kitchen_counter_instance)
            exp(knife,kitchen_counter_instance)
        else:
            exp(knife,kitchen_counter_instance)
    eff:
        unknown[knife]=False
        close[knife,kitchen_counter_instance]=True
        close[kitchen_counter_instance,knife]=True
    

behavior find_food_bread_2012_around_fridge_289(food_bread:item):
    goal: not unknown(food_bread)
    body:
        assert is_food_bread(food_bread)
        bind fridge_instance:item where:
            is_fridge(fridge_instance) and id[fridge_instance]==289
        achieve close_char(char,fridge_instance)
        if can_open(fridge_instance):
            achieve_once open(fridge_instance)
            exp(food_bread,fridge_instance)
        else:
            exp(food_bread,fridge_instance)
    eff:
        unknown[food_bread]=False
        close[food_bread,fridge_instance]=True
        close[fridge_instance,food_bread]=True
    

#exp_behavior_end

#goal_representation
 
def has_cuttable_bread():
    # Function to check if there is cuttable bread known
    symbol has_bread=exists o: item : is_food_bread(o) and cuttable(o)
    return has_bread

def has_available_toaster():
    # Function to check if there is an available toaster in the known environment
    symbol has_toaster=exists toaster: item : is_toaster(toaster) and plugged(toaster) and has_switch(toaster)
    return has_toaster

behavior slice_bread(bread:item):
    body:
        achieve cut(bread) # Slice the bread

behavior toast_bread(bread:item, toaster:item):
    body:
        achieve inside(bread, toaster) # Place the sliced bread inside the toaster
        achieve is_on(toaster) # Turn on the toaster

behavior __goal__():
    body:
        if has_cuttable_bread() and has_available_toaster():
            # If there is cuttable bread and a toaster available, proceed
            bind bread: item where:
                is_food_bread(bread) and cuttable(bread)
            bind toaster: item where:
                is_toaster(toaster) and plugged(toaster) and has_switch(toaster)
            
            slice_bread(bread)
            toast_bread(bread, toaster)
        else:
            # Explore to find an unvisited bread or an available toaster if needed
            foreach o: item:
                if is_food_bread(o) and cuttable(o) and not visited(o):
                    observe(o, "Check if the bread is available for slicing and toasting")
                if is_toaster(o) and not visited(o):
                    observe(o, "Check if the toaster is ready for use")

#goal_representation_end

##############################
Error is:
'NoneType' object is not iterable
##############################
Goal representation from planning.py

#exp_behavior

behavior find_knife_2050_around_cupboard_229(knife:item):
    goal: not unknown(knife)
    body:
        assert is_knife(knife)
        bind cupboard_instance:item where:
            is_cupboard(cupboard_instance) and id[cupboard_instance]==229
        achieve close_char(char,cupboard_instance)
        if can_open(cupboard_instance):
            achieve_once open(cupboard_instance)
            exp(knife,cupboard_instance)
        else:
            exp(knife,cupboard_instance)
    eff:
        unknown[knife]=False
        close[knife,cupboard_instance]=True
        close[cupboard_instance,knife]=True
    

behavior find_cutting_board_2051_around_kitchen_counter_230(cutting_board:item):
    goal: not unknown(cutting_board)
    body:
        assert is_cutting_board(cutting_board)
        bind kitchen_counter_instance:item where:
            is_kitchen_counter(kitchen_counter_instance) and id[kitchen_counter_instance]==230
        achieve close_char(char,kitchen_counter_instance)
        if can_open(kitchen_counter_instance):
            achieve_once open(kitchen_counter_instance)
            exp(cutting_board,kitchen_counter_instance)
        else:
            exp(cutting_board,kitchen_counter_instance)
    eff:
        unknown[cutting_board]=False
        close[cutting_board,kitchen_counter_instance]=True
        close[kitchen_counter_instance,cutting_board]=True
    

behavior find_food_bread_2012_around_fridge_289(food_bread:item):
    goal: not unknown(food_bread)
    body:
        assert is_food_bread(food_bread)
        bind fridge_instance:item where:
            is_fridge(fridge_instance) and id[fridge_instance]==289
        achieve close_char(char,fridge_instance)
        if can_open(fridge_instance):
            achieve_once open(fridge_instance)
            exp(food_bread,fridge_instance)
        else:
            exp(food_bread,fridge_instance)
    eff:
        unknown[food_bread]=False
        close[food_bread,fridge_instance]=True
        close[fridge_instance,food_bread]=True
    

#exp_behavior_end

#goal_representation
 
def has_cutting_board():
    # Function to check if a cutting board is available
    symbol cutting_board_exists=exists cb: item : is_cutting_board(cb)
    return cutting_board_exists

def is_collision_free_bread_placement(bread:item, cutting_board:item):
    # Check that the bread can be safely placed on the cutting board without conflicts
    symbol collision_free= not exists o: item : (on(o, cutting_board) and o=bread)
    return collision_free

behavior prepare_slicing(bread:item, cutting_board:item, knife:item):
    body:
        achieve on(bread, cutting_board) # Place bread on the cutting board
        observe(bread, "Is it on a clean surface and ready for slicing")
        # Ensure the bread is placed correctly

behavior slice_bread(bread:item, knife:item):
    body:
        achieve cut(bread) # Achieve the cut state for the bread
        # This ensures the bread is sliced

behavior prepare_toasting(bread:item, toaster:item):
    body:
        achieve inside(bread, toaster) # Place bread inside the toaster
        # Prepare bread for toasting

behavior toast_bread(toaster:item):
    body:
        achieve closed(toaster) # Close the toaster during operation
        achieve plugged(toaster) # Ensure toaster is plugged in
        achieve is_on(toaster) # Turn the toaster on

behavior __goal__():
    body:
        bind bread: item where:
            is_food_bread(bread)
        # Select a bread item

        bind toaster: item where:
            is_toaster(toaster)
        # Select a toaster

        if has_cutting_board():
            bind cutting_board: item where:
                is_cutting_board(cutting_board) and is_collision_free_bread_placement(bread, cutting_board)
            # Check and bind to a collisionfree cutting board

            bind knife: item where:
                is_knife(knife)
            # Select a knife

            prepare_slicing(bread, cutting_board, knife)
            slice_bread(bread, knife)
        
        prepare_toasting(bread, toaster)
        toast_bread(toaster)

#goal_representation_end

##############################
Inner TransformationError Debug
Unexpected token Token('VARNAME', 'o') at line 5678, column 39.
Expected one of: 
	* _NEWLINE
	* SEMICOLON

##############################
Goal representation after debugging in planning.py
#exp_behavior

behavior find_knife_2050_around_kitchen_counter_230(knife:item):
    goal: not unknown(knife)
    body:
        assert is_knife(knife)
        bind kitchen_counter_instance:item where:
            is_kitchen_counter(kitchen_counter_instance) and id[kitchen_counter_instance]==230
        achieve close_char(char,kitchen_counter_instance)
        if can_open(kitchen_counter_instance):
            achieve_once open(kitchen_counter_instance)
            exp(knife,kitchen_counter_instance)
        else:
            exp(knife,kitchen_counter_instance)
    eff:
        unknown[knife]=False
        close[knife,kitchen_counter_instance]=True
        close[kitchen_counter_instance,knife]=True
    

behavior find_cutting_board_2051_around_kitchen_counter_230(cutting_board:item):
    goal: not unknown(cutting_board)
    body:
        assert is_cutting_board(cutting_board)
        bind kitchen_counter_instance:item where:
            is_kitchen_counter(kitchen_counter_instance) and id[kitchen_counter_instance]==230
        achieve close_char(char,kitchen_counter_instance)
        if can_open(kitchen_counter_instance):
            achieve_once open(kitchen_counter_instance)
            exp(cutting_board,kitchen_counter_instance)
        else:
            exp(cutting_board,kitchen_counter_instance)
    eff:
        unknown[cutting_board]=False
        close[cutting_board,kitchen_counter_instance]=True
        close[kitchen_counter_instance,cutting_board]=True
    

behavior find_food_bread_2012_around_kitchen_counter_230(food_bread:item):
    goal: not unknown(food_bread)
    body:
        assert is_food_bread(food_bread)
        bind kitchen_counter_instance:item where:
            is_kitchen_counter(kitchen_counter_instance) and id[kitchen_counter_instance]==230
        achieve close_char(char,kitchen_counter_instance)
        if can_open(kitchen_counter_instance):
            achieve_once open(kitchen_counter_instance)
            exp(food_bread,kitchen_counter_instance)
        else:
            exp(food_bread,kitchen_counter_instance)
    eff:
        unknown[food_bread]=False
        close[food_bread,kitchen_counter_instance]=True
        close[kitchen_counter_instance,food_bread]=True
    

#goal_representation
 
def has_cutting_board():
    # Function to check if a cutting board is available
    symbol cutting_board_exists=exists cb: item : is_cutting_board(cb)
    return cutting_board_exists

def is_collision_free_bread_placement(bread:item, cutting_board:item):
    # Check that the bread can be safely placed on the cutting board without conflicts
    symbol collision_free= not exists o: item : (on(o, cutting_board) and o is bread)
    return collision_free

behavior prepare_slicing(bread:item, cutting_board:item, knife:item):
    body:
        achieve on(bread, cutting_board) # Place bread on the cutting board
        observe(bread, "Is it on a clean surface and ready for slicing")
        # Ensure the bread is placed correctly

behavior slice_bread(bread:item, knife:item):
    body:
        achieve cut(bread) # Achieve the cut state for the bread
        # This ensures the bread is sliced

behavior prepare_toasting(bread:item, toaster:item):
    body:
        achieve inside(bread, toaster) # Place bread inside the toaster
        # Prepare bread for toasting

behavior toast_bread(toaster:item):
    body:
        achieve closed(toaster) # Close the toaster during operation
        achieve plugged(toaster) # Ensure toaster is plugged in
        achieve is_on(toaster) # Turn the toaster on

behavior __goal__():
    body:
        bind bread: item where:
            is_food_bread(bread)
        # Select a bread item

        bind toaster: item where:
            is_toaster(toaster)
        # Select a toaster

        if has_cutting_board():
            bind cutting_board: item where:
                is_cutting_board(cutting_board) and is_collision_free_bread_placement(bread, cutting_board)
            # Check and bind to a collisionfree cutting board

            bind knife: item where:
                is_knife(knife)
            # Select a knife

            prepare_slicing(bread, cutting_board, knife)
            slice_bread(bread, knife)
        
        prepare_toasting(bread, toaster)
        toast_bread(toaster)

#goal_representation_end

##############################
Inner TransformationError Debug
Unexpected token Token('VARNAME', 'o') at line 5678, column 39.
Expected one of: 
	* _NEWLINE
	* SEMICOLON

##############################
Goal representation after debugging in planning.py
#exp_behavior

behavior find_knife_2050_around_cupboard_229(knife:item):
    goal: not unknown(knife)
    body:
        assert is_knife(knife)
        bind cupboard_instance:item where:
            is_cupboard(cupboard_instance) and id[cupboard_instance]==229
        achieve close_char(char,cupboard_instance)
        if can_open(cupboard_instance):
            achieve_once open(cupboard_instance)
            exp(knife,cupboard_instance)
        else:
            exp(knife,cupboard_instance)
    eff:
        unknown[knife]=False
        close[knife,cupboard_instance]=True
        close[cupboard_instance,knife]=True
    

behavior find_food_bread_2012_around_fridge_289(food_bread:item):
    goal: not unknown(food_bread)
    body:
        assert is_food_bread(food_bread)
        bind fridge_instance:item where:
            is_fridge(fridge_instance) and id[fridge_instance]==289
        achieve close_char(char,fridge_instance)
        if can_open(fridge_instance):
            achieve_once open(fridge_instance)
            exp(food_bread,fridge_instance)
        else:
            exp(food_bread,fridge_instance)
    eff:
        unknown[food_bread]=False
        close[food_bread,fridge_instance]=True
        close[fridge_instance,food_bread]=True
    

behavior find_cutting_board_2051_around_kitchen_counter_230(cutting_board:item):
    goal: not unknown(cutting_board)
    body:
        assert is_cutting_board(cutting_board)
        bind kitchen_counter_instance:item where:
            is_kitchen_counter(kitchen_counter_instance) and id[kitchen_counter_instance]==230
        achieve close_char(char,kitchen_counter_instance)
        if can_open(kitchen_counter_instance):
            achieve_once open(kitchen_counter_instance)
            exp(cutting_board,kitchen_counter_instance)
        else:
            exp(cutting_board,kitchen_counter_instance)
    eff:
        unknown[cutting_board]=False
        close[cutting_board,kitchen_counter_instance]=True
        close[kitchen_counter_instance,cutting_board]=True
    

#goal_representation
 
def has_cutting_board():
    # Function to check if a cutting board is available
    symbol cutting_board_exists=exists cb: item : is_cutting_board(cb)
    return cutting_board_exists

def is_collision_free_bread_placement(bread:item, cutting_board:item):
    # Check that the bread can be safely placed on the cutting board without conflicts
    symbol collision_free= not exists item1: item : (on(item1, cutting_board) and item1 is bread)
    return collision_free

behavior prepare_slicing(bread:item, cutting_board:item, knife:item):
    body:
        achieve on(bread, cutting_board) # Place bread on the cutting board
        observe(bread, "Is it on a clean surface and ready for slicing")
        # Ensure the bread is placed correctly

behavior slice_bread(bread:item, knife:item):
    body:
        achieve cut(bread) # Achieve the cut state for the bread
        # This ensures the bread is sliced

behavior prepare_toasting(bread:item, toaster:item):
    body:
        achieve inside(bread, toaster) # Place bread inside the toaster
        # Prepare bread for toasting

behavior toast_bread(toaster:item):
    body:
        achieve closed(toaster) # Close the toaster during operation
        achieve plugged(toaster) # Ensure toaster is plugged in
        achieve is_on(toaster) # Turn the toaster on

behavior __goal__():
    body:
        bind bread: item where:
            is_food_bread(bread)
        # Select a bread item

        bind toaster: item where:
            is_toaster(toaster)
        # Select a toaster

        if has_cutting_board():
            bind cutting_board: item where:
                is_cutting_board(cutting_board) and is_collision_free_bread_placement(bread, cutting_board)
            # Check and bind to a collisionfree cutting board

            bind knife: item where:
                is_knife(knife)
            # Select a knife

            prepare_slicing(bread, cutting_board, knife)
            slice_bread(bread, knife)
        
        prepare_toasting(bread, toaster)
        toast_bread(toaster)

#goal_representation_end

##############################
Goal representation from planning.py

#exp_behavior

behavior find_knife_2050_around_cupboard_229(knife:item):
    goal: not unknown(knife)
    body:
        assert is_knife(knife)
        bind cupboard_instance:item where:
            is_cupboard(cupboard_instance) and id[cupboard_instance]==229
        achieve close_char(char,cupboard_instance)
        if can_open(cupboard_instance):
            achieve_once open(cupboard_instance)
            exp(knife,cupboard_instance)
        else:
            exp(knife,cupboard_instance)
    eff:
        unknown[knife]=False
        close[knife,cupboard_instance]=True
        close[cupboard_instance,knife]=True
    

behavior find_cutting_board_2051_around_kitchen_counter_230(cutting_board:item):
    goal: not unknown(cutting_board)
    body:
        assert is_cutting_board(cutting_board)
        bind kitchen_counter_instance:item where:
            is_kitchen_counter(kitchen_counter_instance) and id[kitchen_counter_instance]==230
        achieve close_char(char,kitchen_counter_instance)
        if can_open(kitchen_counter_instance):
            achieve_once open(kitchen_counter_instance)
            exp(cutting_board,kitchen_counter_instance)
        else:
            exp(cutting_board,kitchen_counter_instance)
    eff:
        unknown[cutting_board]=False
        close[cutting_board,kitchen_counter_instance]=True
        close[kitchen_counter_instance,cutting_board]=True
    

behavior find_food_bread_2012_around_fridge_289(food_bread:item):
    goal: not unknown(food_bread)
    body:
        assert is_food_bread(food_bread)
        bind fridge_instance:item where:
            is_fridge(fridge_instance) and id[fridge_instance]==289
        achieve close_char(char,fridge_instance)
        if can_open(fridge_instance):
            achieve_once open(fridge_instance)
            exp(food_bread,fridge_instance)
        else:
            exp(food_bread,fridge_instance)
    eff:
        unknown[food_bread]=False
        close[food_bread,fridge_instance]=True
        close[fridge_instance,food_bread]=True
    

#exp_behavior_end

#goal_representation

def has_cutting_board():
    # Function to check if there is a cutting board available
    symbol available=exists c: item : is_cutting_board(c)
    return available

def has_knife():
    # Function to check if there is a knife available
    symbol available=exists k: item : is_knife(k)
    return available

def has_toaster():
    # Function to check if there is a toaster available
    symbol available=exists t: item : is_toaster(t)
    return available

behavior slice_bread(bread:item, cutting_board:item, knife:item):
    body:
        achieve on(bread, cutting_board) # Place the bread on the cutting board
        achieve cut(bread) # Cut the bread using the knife

behavior toast_bread(bread:item, toaster:item):
    body:
        achieve inside(bread, toaster)
        achieve plugged(toaster)
        achieve is_on(toaster)

behavior __goal__():
    body:
        bind bread: item where:
            is_food_bread(bread)
        # Select the bread to be sliced and toasted
        
        bind cutting_board: item where:
            is_cutting_board(cutting_board)
        # Select a cutting board
        
        bind knife: item where:
            is_knife(knife)
        # Select a knife
        
        bind toaster: item where:
            is_toaster(toaster)
        # Select a toaster
        
        slice_bread(bread, cutting_board, knife) # Slice the bread using the cutting board and knife
        toast_bread(bread, toaster) # Toast the bread using the toaster

#goal_representation_end

##############################
Error is:
'NoneType' object is not iterable
##############################
VH_pipeline: Fail to generate a valid plan
##############################
From agent.py->reset_goal
Fail to generate the goal representation
##############################
Error record: object of type 'NoneType' has no len()
##############################
Task Summary:
Task Goal:
Syntax Error
Action History:
[]
Time info:
Time consume: 101 seconds
Exp_helper query times: 0
Guidance query times: 0
library scale: 4
goal generate times: 3
goal correct times: 0

Task complete rate:
Keystate: k1 - Requires: 15 steps
Action Completion Rate: No actions required
Scene_id: 0
##############################
